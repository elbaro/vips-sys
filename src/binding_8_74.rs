/* automatically generated by rust-bindgen */
// generated in mac mojave, libvips 8.7.4, installed with brew install vips

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const G_GNUC_FUNCTION: &'static [u8; 1usize] = b"\0";
pub const G_GNUC_PRETTY_FUNCTION: &'static [u8; 1usize] = b"\0";
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 262144;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 8192;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const G_MINSHORT: i32 = -32768;
pub const G_MAXSHORT: u32 = 32767;
pub const G_MAXUSHORT: u32 = 65535;
pub const G_MININT: i32 = -2147483648;
pub const G_MAXINT: u32 = 2147483647;
pub const G_MAXUINT: u32 = 4294967295;
pub const G_MINLONG: i64 = -9223372036854775808;
pub const G_MAXLONG: u64 = 9223372036854775807;
pub const G_MAXULONG: i32 = -1;
pub const G_GINT16_MODIFIER: &'static [u8; 2usize] = b"h\0";
pub const G_GINT16_FORMAT: &'static [u8; 3usize] = b"hi\0";
pub const G_GUINT16_FORMAT: &'static [u8; 3usize] = b"hu\0";
pub const G_GINT32_MODIFIER: &'static [u8; 1usize] = b"\0";
pub const G_GINT32_FORMAT: &'static [u8; 2usize] = b"i\0";
pub const G_GUINT32_FORMAT: &'static [u8; 2usize] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &'static [u8; 3usize] = b"ll\0";
pub const G_GINT64_FORMAT: &'static [u8; 4usize] = b"lli\0";
pub const G_GUINT64_FORMAT: &'static [u8; 4usize] = b"llu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GSSIZE_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GSIZE_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const G_GSSIZE_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_MAXSIZE: i32 = -1;
pub const G_MINSSIZE: i64 = -9223372036854775808;
pub const G_MAXSSIZE: u64 = 9223372036854775807;
pub const G_GOFFSET_MODIFIER: &'static [u8; 3usize] = b"ll\0";
pub const G_GOFFSET_FORMAT: &'static [u8; 4usize] = b"lli\0";
pub const G_POLLFD_FORMAT: &'static [u8; 3usize] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GINTPTR_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GUINTPTR_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 60;
pub const GLIB_MICRO_VERSION: u32 = 1;
pub const G_VA_COPY_AS_ARRAY: u32 = 1;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_MODULE_SUFFIX: &'static [u8; 3usize] = b"so\0";
pub const G_PID_FORMAT: &'static [u8; 2usize] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 30;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &'static [u8; 2usize] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &'static [u8; 2usize] = b":\0";
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101401;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _I386_SIGNAL_H_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const FP_PREC_24B: u32 = 0;
pub const FP_PREC_53B: u32 = 2;
pub const FP_PREC_64B: u32 = 3;
pub const FP_RND_NEAR: u32 = 0;
pub const FP_RND_DOWN: u32 = 1;
pub const FP_RND_UP: u32 = 2;
pub const FP_CHOP: u32 = 3;
pub const FP_STATE_BYTES: u32 = 512;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_CURRENT: u32 = 4;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const __DARWIN_MAXNAMLEN: u32 = 255;
pub const __DARWIN_MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DIRBLKSIZ: u32 = 1024;
pub const DTF_HIDEW: u32 = 1;
pub const DTF_NODUP: u32 = 2;
pub const DTF_REWIND: u32 = 4;
pub const __DTF_READALL: u32 = 8;
pub const __DTF_SKIPREAD: u32 = 16;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_KEY_FILE_DESKTOP_GROUP: &'static [u8; 14usize] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &'static [u8; 5usize] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &'static [u8; 8usize] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &'static [u8; 5usize] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &'static [u8; 12usize] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &'static [u8; 10usize] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &'static [u8; 8usize] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &'static [u8; 5usize] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &'static [u8; 7usize] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &'static [u8; 11usize] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &'static [u8; 10usize] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &'static [u8; 8usize] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &'static [u8; 5usize] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &'static [u8; 5usize] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &'static [u8; 9usize] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &'static [u8; 9usize] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &'static [u8; 11usize] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &'static [u8; 14usize] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &'static [u8; 15usize] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &'static [u8; 4usize] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &'static [u8; 16usize] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &'static [u8; 8usize] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &'static [u8; 12usize] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &'static [u8; 5usize] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &'static [u8; 10usize] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &'static [u8; 1usize] = b"\0";
pub const G_CSET_A_2_Z: &'static [u8; 27usize] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &'static [u8; 27usize] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &'static [u8; 11usize] = b"0123456789\0";
pub const G_CSET_LATINC: [u8; 31usize] = [
    192u8, 193u8, 194u8, 195u8, 196u8, 197u8, 198u8, 199u8, 200u8, 201u8, 202u8, 203u8, 204u8,
    205u8, 206u8, 207u8, 208u8, 209u8, 210u8, 211u8, 212u8, 213u8, 214u8, 216u8, 217u8, 218u8,
    219u8, 220u8, 221u8, 222u8, 0u8,
];
pub const G_CSET_LATINS: [u8; 33usize] = [
    223u8, 224u8, 225u8, 226u8, 227u8, 228u8, 229u8, 230u8, 231u8, 232u8, 233u8, 234u8, 235u8,
    236u8, 237u8, 238u8, 239u8, 240u8, 241u8, 242u8, 243u8, 244u8, 245u8, 246u8, 248u8, 249u8,
    250u8, 251u8, 252u8, 253u8, 254u8, 255u8, 0u8,
];
pub const G_STR_DELIMITERS: &'static [u8; 8usize] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const G_TEST_OPTION_ISOLATE_DIRS: &'static [u8; 13usize] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &'static [u8; 8usize] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &'static [u8; 12usize] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &'static [u8; 14usize] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &'static [u8; 15usize] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &'static [u8; 13usize] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const __CTERMID_DEFINED: u32 = 1;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const UF_SETTABLE: u32 = 65535;
pub const UF_NODUMP: u32 = 1;
pub const UF_IMMUTABLE: u32 = 2;
pub const UF_APPEND: u32 = 4;
pub const UF_OPAQUE: u32 = 8;
pub const UF_COMPRESSED: u32 = 32;
pub const UF_TRACKED: u32 = 64;
pub const UF_DATAVAULT: u32 = 128;
pub const UF_HIDDEN: u32 = 32768;
pub const SF_SUPPORTED: u32 = 2031616;
pub const SF_SETTABLE: u32 = 4294901760;
pub const SF_ARCHIVED: u32 = 65536;
pub const SF_IMMUTABLE: u32 = 131072;
pub const SF_APPEND: u32 = 262144;
pub const SF_RESTRICTED: u32 = 524288;
pub const SF_NOUNLINK: u32 = 1048576;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const G_TYPE_FUNDAMENTAL_SHIFT: u32 = 2;
pub const G_TYPE_RESERVED_GLIB_FIRST: u32 = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: u32 = 31;
pub const G_TYPE_RESERVED_BSE_FIRST: u32 = 32;
pub const G_TYPE_RESERVED_BSE_LAST: u32 = 48;
pub const G_TYPE_RESERVED_USER_FIRST: u32 = 49;
pub const G_VALUE_NOCOPY_CONTENTS: u32 = 134217728;
pub const G_PARAM_MASK: u32 = 255;
pub const G_PARAM_USER_SHIFT: u32 = 8;
pub const G_SIGNAL_FLAGS_MASK: u32 = 511;
pub const G_SIGNAL_MATCH_MASK: u32 = 63;
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const VIPS_PI: f64 = 3.141592653589793;
pub const VIPS_PATH_MAX: u32 = 4096;
pub const VIPS_VERSION: &'static [u8; 6usize] = b"8.7.4\0";
pub const VIPS_VERSION_STRING: &'static [u8; 35usize] = b"8.7.4-Fri Jan 18 12:51:47 UTC 2019\0";
pub const VIPS_MAJOR_VERSION: u32 = 8;
pub const VIPS_MINOR_VERSION: u32 = 7;
pub const VIPS_MICRO_VERSION: u32 = 4;
pub const VIPS_LIBRARY_CURRENT: u32 = 51;
pub const VIPS_LIBRARY_REVISION: u32 = 5;
pub const VIPS_LIBRARY_AGE: u32 = 9;
pub const VIPS_SONAME: &'static [u8; 17usize] = b"libvips.42.dylib\0";
pub const VIPS_EXEEXT: &'static [u8; 1usize] = b"\0";
pub const VIPS_ENABLE_DEPRECATED: u32 = 1;
pub const VIPS_SPARE: u32 = 8;
pub const VIPS__WINDOW_MARGIN_PIXELS: u32 = 128;
pub const VIPS__WINDOW_MARGIN_BYTES: u32 = 10485760;
pub const VIPS_SIZEOF_HEADER: u32 = 64;
pub const VIPS__TILE_WIDTH: u32 = 128;
pub const VIPS__TILE_HEIGHT: u32 = 128;
pub const VIPS__THINSTRIP_HEIGHT: u32 = 1;
pub const VIPS__FATSTRIP_HEIGHT: u32 = 16;
pub const VIPS_MAGIC_INTEL: u32 = 3064394248;
pub const VIPS_MAGIC_SPARC: u32 = 150120118;
pub const VIPS_MAX_COORD: u32 = 10000000;
pub const VIPS_TRANSFORM_SHIFT: u32 = 6;
pub const VIPS_TRANSFORM_SCALE: u32 = 64;
pub const VIPS_INTERPOLATE_SHIFT: u32 = 12;
pub const VIPS_INTERPOLATE_SCALE: u32 = 4096;
pub const VIPS_META_EXIF_NAME: &'static [u8; 10usize] = b"exif-data\0";
pub const VIPS_META_XMP_NAME: &'static [u8; 9usize] = b"xmp-data\0";
pub const VIPS_META_IPTC_NAME: &'static [u8; 10usize] = b"iptc-data\0";
pub const VIPS_META_PHOTOSHOP_NAME: &'static [u8; 15usize] = b"photoshop-data\0";
pub const VIPS_META_ICC_NAME: &'static [u8; 17usize] = b"icc-profile-data\0";
pub const VIPS_META_IMAGEDESCRIPTION: &'static [u8; 18usize] = b"image-description\0";
pub const VIPS_META_RESOLUTION_UNIT: &'static [u8; 16usize] = b"resolution-unit\0";
pub const VIPS_META_LOADER: &'static [u8; 12usize] = b"vips-loader\0";
pub const VIPS_META_SEQUENTIAL: &'static [u8; 16usize] = b"vips-sequential\0";
pub const VIPS_META_ORIENTATION: &'static [u8; 12usize] = b"orientation\0";
pub const VIPS_META_PAGE_HEIGHT: &'static [u8; 12usize] = b"page-height\0";
pub const VIPS_META_N_PAGES: &'static [u8; 8usize] = b"n-pages\0";
pub const VIPS_D93_X0: f64 = 89.74;
pub const VIPS_D93_Y0: f64 = 100.0;
pub const VIPS_D93_Z0: f64 = 130.77;
pub const VIPS_D75_X0: f64 = 94.9682;
pub const VIPS_D75_Y0: f64 = 100.0;
pub const VIPS_D75_Z0: f64 = 122.571;
pub const VIPS_D65_X0: f64 = 95.047;
pub const VIPS_D65_Y0: f64 = 100.0;
pub const VIPS_D65_Z0: f64 = 108.8827;
pub const VIPS_D55_X0: f64 = 95.6831;
pub const VIPS_D55_Y0: f64 = 100.0;
pub const VIPS_D55_Z0: f64 = 92.0871;
pub const VIPS_D50_X0: f64 = 96.425;
pub const VIPS_D50_Y0: f64 = 100.0;
pub const VIPS_D50_Z0: f64 = 82.468;
pub const VIPS_A_X0: f64 = 109.8503;
pub const VIPS_A_Y0: f64 = 100.0;
pub const VIPS_A_Z0: f64 = 35.5849;
pub const VIPS_B_X0: f64 = 99.072;
pub const VIPS_B_Y0: f64 = 100.0;
pub const VIPS_B_Z0: f64 = 85.223;
pub const VIPS_C_X0: f64 = 98.07;
pub const VIPS_C_Y0: f64 = 100.0;
pub const VIPS_C_Z0: f64 = 118.23;
pub const VIPS_E_X0: f64 = 100.0;
pub const VIPS_E_Y0: f64 = 100.0;
pub const VIPS_E_Z0: f64 = 100.0;
pub const VIPS_D3250_X0: f64 = 105.659;
pub const VIPS_D3250_Y0: f64 = 100.0;
pub const VIPS_D3250_Z0: f64 = 45.8501;
pub type wchar_t = ::std::os::raw::c_int;
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_longlong;
pub type guint64 = ::std::os::raw::c_ulonglong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_getdate_err"]
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_asctime"]
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_clock"]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[link_name = "\u{1}_ctime"]
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_difftime"]
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_getdate"]
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_gmtime"]
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_localtime"]
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_mktime"]
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_strftime"]
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_strptime"]
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_time"]
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_tzset"]
    pub fn tzset();
}
extern "C" {
    #[link_name = "\u{1}_asctime_r"]
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ctime_r"]
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gmtime_r"]
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_localtime_r"]
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_posix2time"]
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_tzsetwall"]
    pub fn tzsetwall();
}
extern "C" {
    #[link_name = "\u{1}_time2posix"]
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_timelocal"]
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_timegm"]
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_nanosleep"]
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clockid_t {
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16,
}
extern "C" {
    #[link_name = "\u{1}_clock_getres"]
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_clock_gettime"]
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_clock_gettime_nsec_np"]
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    #[link_name = "\u{1}_clock_settime"]
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GFreeFunc:"]
#[doc = " @data: a data pointer"]
#[doc = ""]
#[doc = " Declares a type of function which takes an arbitrary"]
#[doc = " data pointer argument and has no return value. It is"]
#[doc = " not currently used in GLib or GTK+."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:"]
#[doc = " @str: the untranslated string"]
#[doc = " @data: user data specified when installing the function, e.g."]
#[doc = "  in g_option_group_set_translate_func()"]
#[doc = ""]
#[doc = " The type of functions which are used to translate user-visible"]
#[doc = " strings, for <option>--help</option> output."]
#[doc = ""]
#[doc = " Returns: a translation of the string for the current locale."]
#[doc = "  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFloatIEEE754>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFloatIEEE754>())).mpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDoubleIEEE754>())).v_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDoubleIEEE754>())).mpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    assert_eq!(
        ::std::mem::size_of::<_GTimeVal>(),
        16usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTimeVal>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTimeVal>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTimeVal>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type grefcount = gint;
pub type gatomicrefcount = gint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    assert_eq!(
        ::std::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    assert_eq!(
        ::std::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GByteArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GByteArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    assert_eq!(
        ::std::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPtrArray>())).pdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPtrArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_array_new"]
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_sized_new"]
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_free"]
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_array_ref"]
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_unref"]
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    #[link_name = "\u{1}_g_array_get_element_size"]
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_array_append_vals"]
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_prepend_vals"]
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_insert_vals"]
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_set_size"]
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_remove_index"]
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_remove_index_fast"]
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_remove_range"]
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_sort"]
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_array_sort_with_data"]
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_array_set_clear_func"]
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_new"]
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_new_with_free_func"]
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_sized_new"]
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_new_full"]
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_free"]
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_ref"]
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_unref"]
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_set_free_func"]
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_set_size"]
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove_index"]
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove_index_fast"]
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_steal_index"]
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_steal_index_fast"]
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove"]
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove_fast"]
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove_range"]
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_add"]
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_insert"]
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_sort"]
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_sort_with_data"]
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_foreach"]
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_find"]
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_find_with_equal_func"]
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_new"]
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_new_take"]
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_sized_new"]
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_free"]
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_free_to_bytes"]
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_ref"]
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_unref"]
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_append"]
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_prepend"]
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_set_size"]
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_remove_index"]
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_remove_index_fast"]
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_remove_range"]
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_sort"]
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_sort_with_data"]
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_get"]
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_set"]
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_inc"]
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_dec_and_test"]
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_compare_and_exchange"]
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_add"]
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_and"]
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_or"]
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_xor"]
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_get"]
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_set"]
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_compare_and_exchange"]
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_add"]
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_and"]
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_or"]
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_xor"]
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_exchange_and_add"]
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
extern "C" {
    #[link_name = "\u{1}_g_quark_try_string"]
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_quark_from_static_string"]
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_quark_from_string"]
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_quark_to_string"]
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_intern_string"]
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_intern_static_string"]
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:"]
#[doc = " @domain: error domain, e.g. #G_FILE_ERROR"]
#[doc = " @code: error code, e.g. %G_FILE_ERROR_NOENT"]
#[doc = " @message: human-readable informative error message"]
#[doc = ""]
#[doc = " The `GError` structure contains information about"]
#[doc = " an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_error_new"]
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_error_new_literal"]
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_error_new_valist"]
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_error_free"]
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_g_error_copy"]
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_error_matches"]
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_set_error"]
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_set_error_literal"]
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_propagate_error"]
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_g_clear_error"]
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_g_prefix_error"]
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_propagate_prefixed_error"]
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_name"]
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_real_name"]
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_home_dir"]
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_tmp_dir"]
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_host_name"]
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_prgname"]
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_set_prgname"]
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_get_application_name"]
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_set_application_name"]
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_reload_user_special_dirs_cache"]
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_data_dir"]
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_config_dir"]
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_cache_dir"]
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_system_data_dirs"]
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_system_config_dirs"]
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_runtime_dir"]
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
#[repr(u32)]
#[doc = " GUserDirectory:"]
#[doc = " @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory"]
#[doc = " @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory"]
#[doc = " @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory"]
#[doc = " @G_USER_DIRECTORY_MUSIC: the user's Music directory"]
#[doc = " @G_USER_DIRECTORY_PICTURES: the user's Pictures directory"]
#[doc = " @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory"]
#[doc = " @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory"]
#[doc = " @G_USER_DIRECTORY_VIDEOS: the user's Movies directory"]
#[doc = " @G_USER_N_DIRECTORIES: the number of enum values"]
#[doc = ""]
#[doc = " These are logical ids for special directories which are defined"]
#[doc = " depending on the platform used. You should use g_get_user_special_dir()"]
#[doc = " to retrieve the full path associated to the logical id."]
#[doc = ""]
#[doc = " The #GUserDirectory enumeration can be extended at later date. Not"]
#[doc = " every platform has a directory for every logical id in this"]
#[doc = " enumeration."]
#[doc = ""]
#[doc = " Since: 2.14"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GUserDirectory {
    G_USER_DIRECTORY_DESKTOP = 0,
    G_USER_DIRECTORY_DOCUMENTS = 1,
    G_USER_DIRECTORY_DOWNLOAD = 2,
    G_USER_DIRECTORY_MUSIC = 3,
    G_USER_DIRECTORY_PICTURES = 4,
    G_USER_DIRECTORY_PUBLIC_SHARE = 5,
    G_USER_DIRECTORY_TEMPLATES = 6,
    G_USER_DIRECTORY_VIDEOS = 7,
    G_USER_N_DIRECTORIES = 8,
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_special_dir"]
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:"]
#[doc = " @key: the string"]
#[doc = " @value: the flag"]
#[doc = ""]
#[doc = " Associates a string with a bit flag."]
#[doc = " Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    assert_eq!(
        ::std::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDebugKey>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDebugKey>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_parse_debug_string"]
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_snprintf"]
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_vsnprintf"]
    pub fn g_vsnprintf(
        string: *mut gchar,
        n: gulong,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_nullify_pointer"]
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GFormatSizeFlags {
    G_FORMAT_SIZE_DEFAULT = 0,
    G_FORMAT_SIZE_LONG_FORMAT = 1,
    G_FORMAT_SIZE_IEC_UNITS = 2,
    G_FORMAT_SIZE_BITS = 4,
}
extern "C" {
    #[link_name = "\u{1}_g_format_size_full"]
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_format_size"]
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_format_size_for_display"]
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:"]
#[doc = ""]
#[doc = " Declares a type of function which takes no arguments"]
#[doc = " and has no return value. It is used to specify the type"]
#[doc = " function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_g_atexit"]
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_find_program_in_path"]
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_nth_lsf"]
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_nth_msf"]
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_storage"]
    pub fn g_bit_storage(number: gulong) -> guint;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_control {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ymm_reg>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ymm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ymm_reg>())).__ymm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ymm_reg),
            "::",
            stringify!(__ymm_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_zmm_reg>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_zmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_zmm_reg>())).__zmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_zmm_reg),
            "::",
            stringify!(__zmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_opmask_reg>(),
        8usize,
        concat!("Size of: ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_opmask_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_opmask_reg>())).__opmask_reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_opmask_reg),
            "::",
            stringify!(__opmask_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx512_state>(),
        1036usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx512_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k0 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k1 as *const _ as usize
        },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k2 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k3 as *const _ as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k4 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k5 as *const _ as usize
        },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k6 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k7 as *const _ as usize
        },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh0 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh1 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh2 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh3 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh4 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh5 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh6 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh7 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx512_state64>(),
        2444usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx512_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh10 as *const _
                as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh11 as *const _
                as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh12 as *const _
                as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh13 as *const _
                as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh14 as *const _
                as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh15 as *const _
                as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k0 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k1 as *const _ as usize
        },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k2 as *const _ as usize
        },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k3 as *const _ as usize
        },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k4 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k5 as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k6 as *const _ as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k7 as *const _ as usize
        },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh0 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh1 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh2 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh3 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh4 as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh5 as *const _ as usize
        },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh6 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh7 as *const _ as usize
        },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh8 as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh9 as *const _ as usize
        },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh10 as *const _
                as usize
        },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh11 as *const _
                as usize
        },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh12 as *const _
                as usize
        },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh13 as *const _
                as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh14 as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh15 as *const _
                as usize
        },
        1388usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm16 as *const _ as usize
        },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm17 as *const _ as usize
        },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm18 as *const _ as usize
        },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm19 as *const _ as usize
        },
        1612usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm20 as *const _ as usize
        },
        1676usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm21 as *const _ as usize
        },
        1740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm22 as *const _ as usize
        },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm23 as *const _ as usize
        },
        1868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm24 as *const _ as usize
        },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm25 as *const _ as usize
        },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm26 as *const _ as usize
        },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm27 as *const _ as usize
        },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm28 as *const _ as usize
        },
        2188usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm29 as *const _ as usize
        },
        2252usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm30 as *const _ as usize
        },
        2316usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm31 as *const _ as usize
        },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm31)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_cpmu_state64>())).__ctrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64>(),
        2632usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__fs as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__fs)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_signal"]
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_unused: [u64; 1usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interval_max_phys_footprint as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_unused as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_unused)
        )
    );
}
pub type rusage_info_current = rusage_info_v4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_getpriority"]
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getiopolicy_np"]
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getrlimit"]
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getrusage"]
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setpriority"]
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setiopolicy_np"]
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setrlimit"]
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_T as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_S as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    #[link_name = "\u{1}_wait"]
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_waitpid"]
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_waitid"]
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_wait3"]
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_wait4"]
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}___builtin_alloca"]
    pub fn __builtin_alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}___mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_malloc"]
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_calloc"]
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_free"]
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_realloc"]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_valloc"]
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_posix_memalign"]
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_abort"]
    pub fn abort();
}
extern "C" {
    #[link_name = "\u{1}_abs"]
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atexit"]
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atof"]
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atoi"]
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atol"]
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_atoll"]
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_bsearch"]
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_div"]
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    #[link_name = "\u{1}_exit"]
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_getenv"]
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_labs"]
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ldiv"]
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_llabs"]
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_lldiv"]
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_mblen"]
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mbstowcs"]
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_mbtowc"]
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_qsort"]
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_rand"]
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_srand"]
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_strtod"]
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_strtof"]
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_strtol"]
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_strtold"]
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_strtoll"]
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_strtoul"]
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strtoull"]
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_system"]
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_wcstombs"]
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_wctomb"]
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__Exit"]
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_a64l"]
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_drand48"]
    pub fn drand48() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ecvt"]
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_erand48"]
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fcvt"]
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gcvt"]
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getsubopt"]
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_grantpt"]
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_initstate"]
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_jrand48"]
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_l64a"]
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_lcong48"]
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    #[link_name = "\u{1}_lrand48"]
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_mktemp"]
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_mkstemp"]
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mrand48"]
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_nrand48"]
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_posix_openpt"]
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ptsname"]
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ptsname_r"]
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putenv"]
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_random"]
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_rand_r"]
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_seed48"]
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}_setenv"]
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setkey"]
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_setstate"]
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_srand48"]
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_srandom"]
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_unlockpt"]
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_unsetenv"]
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    #[link_name = "\u{1}_arc4random"]
    pub fn arc4random() -> u32;
}
extern "C" {
    #[link_name = "\u{1}_arc4random_addrandom"]
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_arc4random_buf"]
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    #[link_name = "\u{1}_arc4random_stir"]
    pub fn arc4random_stir();
}
extern "C" {
    #[link_name = "\u{1}_arc4random_uniform"]
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_atexit_b"]
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bsearch_b"]
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_cgetcap"]
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_cgetclose"]
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetent"]
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetfirst"]
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetmatch"]
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetnext"]
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetnum"]
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetset"]
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetstr"]
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetustr"]
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_daemon$1050"]
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_devname"]
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_devname_r"]
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getbsize"]
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getloadavg"]
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getprogname"]
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_heapsort"]
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_heapsort_b"]
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mergesort"]
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mergesort_b"]
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_psort"]
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_psort_b"]
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_psort_r"]
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_qsort_b"]
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_radixsort"]
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setprogname"]
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_sradixsort"]
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sranddev"]
    pub fn sranddev();
}
extern "C" {
    #[link_name = "\u{1}_srandomdev"]
    pub fn srandomdev();
}
extern "C" {
    #[link_name = "\u{1}_reallocf"]
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_strtoq"]
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_strtouq"]
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_error_quark"]
    pub fn g_thread_error_quark() -> GQuark;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GThreadError {
    G_THREAD_ERROR_AGAIN = 0,
}
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMutex>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    assert_eq!(
        ::std::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRWLock>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRWLock>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    assert_eq!(
        ::std::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCond>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCond>())).i as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRecMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRecMutex>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    assert_eq!(
        ::std::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).future as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(future)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GOnceStatus {
    G_ONCE_STATUS_NOTCALLED = 0,
    G_ONCE_STATUS_PROGRESS = 1,
    G_ONCE_STATUS_READY = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    assert_eq!(
        ::std::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOnce>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOnce>())).retval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_thread_ref"]
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_unref"]
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_new"]
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_try_new"]
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_self"]
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_exit"]
    pub fn g_thread_exit(retval: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_join"]
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_yield"]
    pub fn g_thread_yield();
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_init"]
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_clear"]
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_lock"]
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_trylock"]
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_unlock"]
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_init"]
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_clear"]
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_writer_lock"]
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_writer_trylock"]
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_writer_unlock"]
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_reader_lock"]
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_reader_trylock"]
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_reader_unlock"]
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_init"]
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_clear"]
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_lock"]
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_trylock"]
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_unlock"]
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_init"]
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_clear"]
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_wait"]
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_signal"]
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_broadcast"]
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_wait_until"]
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_private_get"]
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_private_set"]
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_private_replace"]
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_once_impl"]
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_once_init_enter"]
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_once_init_leave"]
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_get_num_processors"]
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_mutex_locker_new() for details."]
#[doc = " Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[doc = " GRecMutexLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_rec_mutex_locker_new() for details."]
#[doc = " Since: 2.60"]
pub type GRecMutexLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    #[link_name = "\u{1}_g_async_queue_new"]
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_new_full"]
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_lock"]
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_unlock"]
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_ref"]
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_unref"]
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_ref_unlocked"]
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_unref_and_unlock"]
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push"]
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_unlocked"]
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_sorted"]
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_sorted_unlocked"]
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_pop"]
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_pop_unlocked"]
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_try_pop"]
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_try_pop_unlocked"]
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_timeout_pop"]
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_timeout_pop_unlocked"]
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_length"]
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_length_unlocked"]
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_sort"]
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_sort_unlocked"]
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_remove"]
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_remove_unlocked"]
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_front"]
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_front_unlocked"]
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_timed_pop"]
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_timed_pop_unlocked"]
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type pthread_t = __darwin_pthread_t;
extern "C" {
    #[link_name = "\u{1}_sys_signame"]
    pub static mut sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    #[link_name = "\u{1}_sys_siglist"]
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    #[link_name = "\u{1}_raise"]
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bsd_signal"]
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    #[link_name = "\u{1}_kill"]
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_killpg"]
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_kill"]
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_sigmask"]
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigaction"]
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigaddset"]
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigaltstack"]
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigdelset"]
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigemptyset"]
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigfillset"]
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sighold"]
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigignore"]
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_siginterrupt"]
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigismember"]
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigpause"]
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigpending"]
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigprocmask"]
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigrelse"]
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigset"]
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    #[link_name = "\u{1}_sigsuspend"]
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigwait"]
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_psignal"]
    pub fn psignal(arg1: ::std::os::raw::c_uint, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_sigblock"]
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigsetmask"]
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigvec"]
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_on_error_query"]
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_on_error_stack_trace"]
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_base64_encode_step"]
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_encode_close"]
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_encode"]
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_decode_step"]
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_decode"]
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_decode_inplace"]
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_lock"]
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_bit_trylock"]
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_unlock"]
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_pointer_bit_lock"]
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_pointer_bit_trylock"]
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pointer_bit_unlock"]
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
#[repr(u32)]
#[doc = " GBookmarkFileError:"]
#[doc = " @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed"]
#[doc = " @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found"]
#[doc = " @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did"]
#[doc = "     not register a bookmark"]
#[doc = " @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found"]
#[doc = " @G_BOOKMARK_FILE_ERROR_READ: document was ill formed"]
#[doc = " @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was"]
#[doc = "     in an unknown encoding"]
#[doc = " @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing"]
#[doc = " @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found"]
#[doc = ""]
#[doc = " Error codes returned by bookmark file parsing."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GBookmarkFileError {
    G_BOOKMARK_FILE_ERROR_INVALID_URI = 0,
    G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1,
    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2,
    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3,
    G_BOOKMARK_FILE_ERROR_READ = 4,
    G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5,
    G_BOOKMARK_FILE_ERROR_WRITE = 6,
    G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7,
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_error_quark"]
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:"]
#[doc = ""]
#[doc = " The `GBookmarkFile` structure contains only"]
#[doc = " private data and should not be directly accessed."]
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_new"]
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_free"]
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_load_from_file"]
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_load_from_data"]
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_load_from_data_dirs"]
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_to_data"]
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_to_file"]
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_title"]
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_title"]
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_description"]
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_description"]
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_mime_type"]
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_mime_type"]
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_groups"]
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_add_group"]
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_has_group"]
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_groups"]
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_add_application"]
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_has_application"]
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_applications"]
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_app_info"]
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_app_info"]
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_is_private"]
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_is_private"]
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_icon"]
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_icon"]
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_added"]
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_added"]
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_modified"]
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_modified"]
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_visited"]
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_visited"]
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_has_item"]
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_size"]
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_uris"]
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_remove_group"]
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_remove_application"]
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_remove_item"]
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_move_item"]
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new"]
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new_take"]
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new_static"]
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new_with_free_func"]
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new_from_bytes"]
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_get_data"]
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_get_size"]
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_ref"]
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_unref"]
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_unref_to_data"]
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_unref_to_array"]
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_hash"]
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_equal"]
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_compare"]
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_get_charset"]
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_get_codeset"]
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_language_names"]
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_language_names_with_category"]
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_locale_variants"]
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
#[repr(u32)]
#[doc = " GChecksumType:"]
#[doc = " @G_CHECKSUM_MD5: Use the MD5 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)"]
#[doc = " @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)"]
#[doc = ""]
#[doc = " The hashing algorithm to be used by #GChecksum when performing the"]
#[doc = " digest of some data."]
#[doc = ""]
#[doc = " Note that the #GChecksumType enumeration may be extended at a later"]
#[doc = " date to include new hashing algorithm types."]
#[doc = ""]
#[doc = " Since: 2.16"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GChecksumType {
    G_CHECKSUM_MD5 = 0,
    G_CHECKSUM_SHA1 = 1,
    G_CHECKSUM_SHA256 = 2,
    G_CHECKSUM_SHA512 = 3,
    G_CHECKSUM_SHA384 = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:"]
#[doc = ""]
#[doc = " An opaque structure representing a checksumming operation."]
#[doc = " To create a new GChecksum, use g_checksum_new(). To free"]
#[doc = " a GChecksum, use g_checksum_free()."]
#[doc = ""]
#[doc = " Since: 2.16"]
pub type GChecksum = _GChecksum;
extern "C" {
    #[link_name = "\u{1}_g_checksum_type_get_length"]
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_new"]
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_reset"]
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_copy"]
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_free"]
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_update"]
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_get_string"]
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_get_digest"]
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_compute_checksum_for_data"]
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_compute_checksum_for_string"]
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_compute_checksum_for_bytes"]
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
#[repr(u32)]
#[doc = " GConvertError:"]
#[doc = " @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character"]
#[doc = "     sets is not supported."]
#[doc = " @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;"]
#[doc = "    or the character sequence could not be represented in the target"]
#[doc = "    character set."]
#[doc = " @G_CONVERT_ERROR_FAILED: Conversion failed for some reason."]
#[doc = " @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input."]
#[doc = " @G_CONVERT_ERROR_BAD_URI: URI is invalid."]
#[doc = " @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path."]
#[doc = " @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40"]
#[doc = " @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in"]
#[doc = "     conversion output where a NUL-terminated string is expected."]
#[doc = "     Since: 2.56"]
#[doc = ""]
#[doc = " Error codes returned by character set conversion routines."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GConvertError {
    G_CONVERT_ERROR_NO_CONVERSION = 0,
    G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1,
    G_CONVERT_ERROR_FAILED = 2,
    G_CONVERT_ERROR_PARTIAL_INPUT = 3,
    G_CONVERT_ERROR_BAD_URI = 4,
    G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5,
    G_CONVERT_ERROR_NO_MEMORY = 6,
    G_CONVERT_ERROR_EMBEDDED_NUL = 7,
}
extern "C" {
    #[link_name = "\u{1}_g_convert_error_quark"]
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)"]
#[doc = ""]
#[doc = " The GIConv struct wraps an iconv() conversion descriptor. It contains"]
#[doc = " private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
extern "C" {
    #[link_name = "\u{1}_g_iconv_open"]
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    #[link_name = "\u{1}_g_iconv"]
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_iconv_close"]
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_convert"]
    pub fn g_convert(
        str: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_convert_with_iconv"]
    pub fn g_convert_with_iconv(
        str: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_convert_with_fallback"]
    pub fn g_convert_with_fallback(
        str: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_locale_to_utf8"]
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_locale_from_utf8"]
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_to_utf8"]
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_from_utf8"]
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_from_uri"]
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_to_uri"]
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_display_name"]
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_filename_charsets"]
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_display_basename"]
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_list_extract_uris"]
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
extern "C" {
    #[link_name = "\u{1}_g_datalist_init"]
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_clear"]
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_get_data"]
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_set_data_full"]
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_dup_data"]
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_replace_data"]
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_remove_no_notify"]
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_foreach"]
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_set_flags"]
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_unset_flags"]
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_get_flags"]
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_destroy"]
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_id_get_data"]
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_get_data"]
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_id_set_data_full"]
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_id_remove_no_notify"]
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_foreach"]
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GDateDMY {
    G_DATE_DAY = 0,
    G_DATE_MONTH = 1,
    G_DATE_YEAR = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GDateWeekday {
    G_DATE_BAD_WEEKDAY = 0,
    G_DATE_MONDAY = 1,
    G_DATE_TUESDAY = 2,
    G_DATE_WEDNESDAY = 3,
    G_DATE_THURSDAY = 4,
    G_DATE_FRIDAY = 5,
    G_DATE_SATURDAY = 6,
    G_DATE_SUNDAY = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GDateMonth {
    G_DATE_BAD_MONTH = 0,
    G_DATE_JANUARY = 1,
    G_DATE_FEBRUARY = 2,
    G_DATE_MARCH = 3,
    G_DATE_APRIL = 4,
    G_DATE_MAY = 5,
    G_DATE_JUNE = 6,
    G_DATE_JULY = 7,
    G_DATE_AUGUST = 8,
    G_DATE_SEPTEMBER = 9,
    G_DATE_OCTOBER = 10,
    G_DATE_NOVEMBER = 11,
    G_DATE_DECEMBER = 12,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::std::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}_g_date_new"]
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    #[link_name = "\u{1}_g_date_new_dmy"]
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    #[link_name = "\u{1}_g_date_new_julian"]
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    #[link_name = "\u{1}_g_date_free"]
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    #[link_name = "\u{1}_g_date_copy"]
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid"]
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_day"]
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_month"]
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_year"]
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_weekday"]
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_julian"]
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_dmy"]
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_weekday"]
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_month"]
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_year"]
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_day"]
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_julian"]
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_day_of_year"]
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_monday_week_of_year"]
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_sunday_week_of_year"]
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_iso8601_week_of_year"]
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_clear"]
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_parse"]
    pub fn g_date_set_parse(date: *mut GDate, str: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_time_t"]
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_time_val"]
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_time"]
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_month"]
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_day"]
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_year"]
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_dmy"]
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_julian"]
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_date_is_first_of_month"]
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_is_last_of_month"]
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_add_days"]
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_subtract_days"]
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_add_months"]
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_subtract_months"]
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_add_years"]
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_subtract_years"]
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_is_leap_year"]
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_days_in_month"]
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_monday_weeks_in_year"]
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_sunday_weeks_in_year"]
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_date_days_between"]
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_compare"]
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_to_struct_tm"]
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    #[link_name = "\u{1}_g_date_clamp"]
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    #[link_name = "\u{1}_g_date_order"]
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    #[link_name = "\u{1}_g_date_strftime"]
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
#[repr(u32)]
#[doc = " GTimeType:"]
#[doc = " @G_TIME_TYPE_STANDARD: the time is in local standard time"]
#[doc = " @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time"]
#[doc = " @G_TIME_TYPE_UNIVERSAL: the time is in UTC"]
#[doc = ""]
#[doc = " Disambiguates a given time in two ways."]
#[doc = ""]
#[doc = " First, specifies if the given time is in universal or local time."]
#[doc = ""]
#[doc = " Second, if the time is in local time, specifies if it is local"]
#[doc = " standard time or local daylight time.  This is important for the case"]
#[doc = " where the same local time occurs twice (during daylight savings time"]
#[doc = " transitions, for example)."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTimeType {
    G_TIME_TYPE_STANDARD = 0,
    G_TIME_TYPE_DAYLIGHT = 1,
    G_TIME_TYPE_UNIVERSAL = 2,
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_new"]
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_new_utc"]
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_new_local"]
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_new_offset"]
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_ref"]
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_unref"]
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_find_interval"]
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_adjust_time"]
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_get_abbreviation"]
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_get_offset"]
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_is_dst"]
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_get_identifier"]
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:"]
#[doc = ""]
#[doc = " A value representing an interval of time, in microseconds."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:"]
#[doc = ""]
#[doc = " `GDateTime` is an opaque structure whose members"]
#[doc = " cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GDateTime = _GDateTime;
extern "C" {
    #[link_name = "\u{1}_g_date_time_unref"]
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_ref"]
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_now"]
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_now_local"]
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_now_utc"]
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_unix_local"]
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_unix_utc"]
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_timeval_local"]
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_timeval_utc"]
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_iso8601"]
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new"]
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_local"]
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_utc"]
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add"]
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_years"]
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_months"]
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_weeks"]
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_days"]
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_hours"]
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_minutes"]
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_seconds"]
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_full"]
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_compare"]
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_difference"]
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_hash"]
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_equal"]
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_ymd"]
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_year"]
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_month"]
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_day_of_month"]
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_week_numbering_year"]
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_week_of_year"]
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_day_of_week"]
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_day_of_year"]
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_hour"]
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_minute"]
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_second"]
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_microsecond"]
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_seconds"]
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_unix"]
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_timeval"]
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_utc_offset"]
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_timezone"]
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_timezone_abbreviation"]
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_is_daylight_savings"]
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_timezone"]
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_local"]
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_utc"]
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_format"]
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
pub type ino_t = __darwin_ino_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        1048usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_seekoff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_seekoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_namlen as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_name as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DIR {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: *mut ::std::os::raw::c_char,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __padding: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut _telldir,
}
#[test]
fn bindgen_test_layout_DIR() {
    assert_eq!(
        ::std::mem::size_of::<DIR>(),
        136usize,
        concat!("Size of: ", stringify!(DIR))
    );
    assert_eq!(
        ::std::mem::align_of::<DIR>(),
        8usize,
        concat!("Alignment of ", stringify!(DIR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_loc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_loc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__padding as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_td as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_td)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_closedir"]
    pub fn closedir(arg1: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_opendir$INODE64"]
    pub fn opendir(arg1: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    #[link_name = "\u{1}_readdir$INODE64"]
    pub fn readdir(arg1: *mut DIR) -> *mut dirent;
}
extern "C" {
    #[link_name = "\u{1}_readdir_r$INODE64"]
    pub fn readdir_r(
        arg1: *mut DIR,
        arg2: *mut dirent,
        arg3: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rewinddir$INODE64"]
    pub fn rewinddir(arg1: *mut DIR);
}
extern "C" {
    #[link_name = "\u{1}_seekdir$INODE64"]
    pub fn seekdir(arg1: *mut DIR, arg2: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_telldir$INODE64"]
    pub fn telldir(arg1: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_fdopendir$INODE64"]
    pub fn fdopendir(arg1: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    #[link_name = "\u{1}_alphasort$INODE64"]
    pub fn alphasort(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_dirfd"]
    pub fn dirfd(dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_scandir$INODE64"]
    pub fn scandir(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_scandir_b$INODE64"]
    pub fn scandir_b(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdirentries_is_not_available_when_64_bit_inodes_are_in_effect"]
    pub fn getdirentries(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___opendir2$INODE64"]
    pub fn __opendir2(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int)
        -> *mut DIR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    #[link_name = "\u{1}_g_dir_open"]
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    #[link_name = "\u{1}_g_dir_read_name"]
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dir_rewind"]
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    #[link_name = "\u{1}_g_dir_close"]
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    #[link_name = "\u{1}_g_getenv"]
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_setenv"]
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unsetenv"]
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_listenv"]
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_environ"]
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_environ_getenv"]
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_environ_setenv"]
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_environ_unsetenv"]
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GFileError {
    G_FILE_ERROR_EXIST = 0,
    G_FILE_ERROR_ISDIR = 1,
    G_FILE_ERROR_ACCES = 2,
    G_FILE_ERROR_NAMETOOLONG = 3,
    G_FILE_ERROR_NOENT = 4,
    G_FILE_ERROR_NOTDIR = 5,
    G_FILE_ERROR_NXIO = 6,
    G_FILE_ERROR_NODEV = 7,
    G_FILE_ERROR_ROFS = 8,
    G_FILE_ERROR_TXTBSY = 9,
    G_FILE_ERROR_FAULT = 10,
    G_FILE_ERROR_LOOP = 11,
    G_FILE_ERROR_NOSPC = 12,
    G_FILE_ERROR_NOMEM = 13,
    G_FILE_ERROR_MFILE = 14,
    G_FILE_ERROR_NFILE = 15,
    G_FILE_ERROR_BADF = 16,
    G_FILE_ERROR_INVAL = 17,
    G_FILE_ERROR_PIPE = 18,
    G_FILE_ERROR_AGAIN = 19,
    G_FILE_ERROR_INTR = 20,
    G_FILE_ERROR_IO = 21,
    G_FILE_ERROR_PERM = 22,
    G_FILE_ERROR_NOSYS = 23,
    G_FILE_ERROR_FAILED = 24,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GFileTest {
    G_FILE_TEST_IS_REGULAR = 1,
    G_FILE_TEST_IS_SYMLINK = 2,
    G_FILE_TEST_IS_DIR = 4,
    G_FILE_TEST_IS_EXECUTABLE = 8,
    G_FILE_TEST_EXISTS = 16,
}
extern "C" {
    #[link_name = "\u{1}_g_file_error_quark"]
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_file_error_from_errno"]
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    #[link_name = "\u{1}_g_file_test"]
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_contents"]
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_contents"]
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_read_link"]
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mkdtemp"]
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mkdtemp_full"]
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mkstemp"]
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_mkstemp_full"]
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_file_open_tmp"]
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_dir_make_tmp"]
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_path"]
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_pathv"]
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_filename"]
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_filenamev"]
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_filename_valist"]
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mkdir_with_parents"]
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_path_is_absolute"]
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_path_skip_root"]
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_basename"]
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_current_dir"]
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_path_get_basename"]
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_path_get_dirname"]
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_canonicalize_filename"]
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strip_context"]
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dgettext"]
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dcgettext"]
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dngettext"]
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dpgettext"]
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dpgettext2"]
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:"]
#[doc = " @malloc: function to use for allocating memory."]
#[doc = " @realloc: function to use for reallocating memory."]
#[doc = " @free: function to use to free memory."]
#[doc = " @calloc: function to use for allocating zero-filled memory."]
#[doc = " @try_malloc: function to use for allocating memory without a default error handler."]
#[doc = " @try_realloc: function to use for reallocating memory without a default error handler."]
#[doc = ""]
#[doc = " A set of functions used to perform memory allocation. The same #GMemVTable must"]
#[doc = " be used for all allocations in the same program; a call to g_mem_set_vtable(),"]
#[doc = " if it exists, should be prior to any use of GLib."]
#[doc = ""]
#[doc = " This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
extern "C" {
    #[link_name = "\u{1}_g_free"]
    pub fn g_free(mem: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_clear_pointer"]
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_malloc"]
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_malloc0"]
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_realloc"]
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_malloc"]
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_malloc0"]
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_realloc"]
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_malloc_n"]
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_malloc0_n"]
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_realloc_n"]
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_malloc_n"]
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_malloc0_n"]
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_realloc_n"]
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    assert_eq!(
        ::std::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).malloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).realloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).calloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).try_malloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).try_realloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_realloc)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mem_set_vtable"]
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_is_system_malloc"]
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_gc_friendly"]
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    #[link_name = "\u{1}_glib_mem_profiler_table"]
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_profile"]
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
impl GTraverseFlags {
    pub const G_TRAVERSE_MASK: GTraverseFlags = GTraverseFlags::G_TRAVERSE_ALL;
}
impl GTraverseFlags {
    pub const G_TRAVERSE_LEAFS: GTraverseFlags = GTraverseFlags::G_TRAVERSE_LEAVES;
}
impl GTraverseFlags {
    pub const G_TRAVERSE_NON_LEAFS: GTraverseFlags = GTraverseFlags::G_TRAVERSE_NON_LEAVES;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTraverseFlags {
    G_TRAVERSE_LEAVES = 1,
    G_TRAVERSE_NON_LEAVES = 2,
    G_TRAVERSE_ALL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTraverseType {
    G_IN_ORDER = 0,
    G_PRE_ORDER = 1,
    G_POST_ORDER = 2,
    G_LEVEL_ORDER = 3,
}
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[doc = " GCopyFunc:"]
#[doc = " @src: (not nullable): A pointer to the data which should be copied"]
#[doc = " @data: Additional data"]
#[doc = ""]
#[doc = " A function of this signature is used to copy the node data"]
#[doc = " when doing a deep-copy of a tree."]
#[doc = ""]
#[doc = " Returns: (not nullable): A pointer to the copy"]
#[doc = ""]
#[doc = " Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    assert_eq!(
        ::std::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).children as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(children)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_node_new"]
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_destroy"]
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    #[link_name = "\u{1}_g_node_unlink"]
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    #[link_name = "\u{1}_g_node_copy_deep"]
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_copy"]
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_insert"]
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_insert_before"]
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_insert_after"]
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_prepend"]
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_n_nodes"]
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_get_root"]
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_is_ancestor"]
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_node_depth"]
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_find"]
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_traverse"]
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_node_max_height"]
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_children_foreach"]
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_node_reverse_children"]
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    #[link_name = "\u{1}_g_node_n_children"]
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_nth_child"]
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_last_child"]
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_find_child"]
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_child_position"]
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_child_index"]
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_first_sibling"]
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_last_sibling"]
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_list_alloc"]
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_free"]
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_list_free_1"]
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_list_free_full"]
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_list_append"]
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_prepend"]
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_insert"]
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_insert_sorted"]
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_insert_sorted_with_data"]
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_insert_before"]
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_concat"]
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_remove"]
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_remove_all"]
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_remove_link"]
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_delete_link"]
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_reverse"]
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_copy"]
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_copy_deep"]
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_nth"]
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_nth_prev"]
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_find"]
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_find_custom"]
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_position"]
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_list_index"]
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_list_last"]
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_first"]
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_length"]
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_list_foreach"]
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_list_sort"]
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_sort_with_data"]
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_nth_data"]
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    assert_eq!(
        ::std::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy5 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy6 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy6)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_new"]
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_new_full"]
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_destroy"]
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_insert"]
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_replace"]
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_add"]
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_remove"]
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_remove_all"]
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_steal"]
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_steal_extended"]
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_steal_all"]
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_lookup"]
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_contains"]
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_lookup_extended"]
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_foreach"]
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_find"]
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_foreach_remove"]
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_foreach_steal"]
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_size"]
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_get_keys"]
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_get_values"]
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_get_keys_as_array"]
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_init"]
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_next"]
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_get_hash_table"]
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_remove"]
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_replace"]
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_steal"]
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_ref"]
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_unref"]
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_str_equal"]
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_str_hash"]
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_int_equal"]
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_int_hash"]
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_int64_equal"]
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_int64_hash"]
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_double_equal"]
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_double_hash"]
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_direct_hash"]
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_direct_equal"]
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:"]
#[doc = ""]
#[doc = " An opaque structure representing a HMAC operation."]
#[doc = " To create a new GHmac, use g_hmac_new(). To free"]
#[doc = " a GHmac, use g_hmac_unref()."]
#[doc = ""]
#[doc = " Since: 2.30"]
pub type GHmac = _GHmac;
extern "C" {
    #[link_name = "\u{1}_g_hmac_new"]
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_copy"]
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_ref"]
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_unref"]
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_update"]
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_get_string"]
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_get_digest"]
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_compute_hmac_for_data"]
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_compute_hmac_for_string"]
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_compute_hmac_for_bytes"]
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GHookFlagMask {
    G_HOOK_FLAG_ACTIVE = 1,
    G_HOOK_FLAG_IN_CALL = 2,
    G_HOOK_FLAG_MASK = 15,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    assert_eq!(
        ::std::mem::size_of::<_GHookList>(),
        56usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).seq_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).hooks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).dummy3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).finalize_hook as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(finalize_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).dummy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy)
        )
    );
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    assert_eq!(
        ::std::mem::size_of::<_GHook>(),
        64usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).ref_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).hook_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(hook_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).destroy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(destroy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_init"]
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_clear"]
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_alloc"]
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_free"]
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_ref"]
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_unref"]
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_destroy"]
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_destroy_link"]
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_prepend"]
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_insert_before"]
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_insert_sorted"]
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hook_get"]
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_find"]
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_find_data"]
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_find_func"]
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_find_func_data"]
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_first_valid"]
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_next_valid"]
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_compare_ids"]
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_invoke"]
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_invoke_check"]
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_marshal"]
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_marshal_check"]
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_is_non_ascii"]
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_is_ascii_encoded"]
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_is_ip_address"]
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_to_ascii"]
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_to_unicode"]
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:"]
#[doc = " @ufds: an array of #GPollFD elements"]
#[doc = " @nfsd: the number of elements in @ufds"]
#[doc = " @timeout_: the maximum time to wait for an event of the file descriptors."]
#[doc = "     A negative value indicates an infinite timeout."]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_main_context_set_poll_func()."]
#[doc = " The semantics of the function should match those of the poll() system call."]
#[doc = ""]
#[doc = " Returns: the number of #GPollFD elements which have events or errors"]
#[doc = "     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:"]
#[doc = " @fd: the file descriptor to poll (or a HANDLE on Win32)"]
#[doc = " @events: a bitwise combination from #GIOCondition, specifying which"]
#[doc = "     events should be polled for. Typically for reading from a file"]
#[doc = "     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and"]
#[doc = "     for writing you would use %G_IO_OUT | %G_IO_ERR."]
#[doc = " @revents: a bitwise combination of flags from #GIOCondition, returned"]
#[doc = "     from the poll() function to indicate which events occurred."]
#[doc = ""]
#[doc = " Represents a file descriptor, which events to poll for, and which events"]
#[doc = " occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    assert_eq!(
        ::std::mem::size_of::<_GPollFD>(),
        8usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollFD>(),
        4usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    #[doc = " G_POLLFD_FORMAT:"]
    #[doc = ""]
    #[doc = " A format specifier that can be used in printf()-style format strings"]
    #[doc = " when printing the @fd member of a #GPollFD."]
    #[link_name = "\u{1}_g_poll"]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_slist_alloc"]
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_free"]
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_free_1"]
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_free_full"]
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_append"]
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_prepend"]
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_insert"]
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_insert_sorted"]
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_insert_sorted_with_data"]
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_insert_before"]
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_concat"]
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_remove"]
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_remove_all"]
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_remove_link"]
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_delete_link"]
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_reverse"]
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_copy"]
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_copy_deep"]
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_nth"]
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_find"]
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_find_custom"]
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_position"]
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_index"]
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_last"]
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_length"]
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_foreach"]
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_sort"]
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_sort_with_data"]
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_nth_data"]
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GIOCondition {
    G_IO_IN = 1,
    G_IO_OUT = 4,
    G_IO_PRI = 2,
    G_IO_ERR = 8,
    G_IO_HUP = 16,
    G_IO_NVAL = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:"]
#[doc = ""]
#[doc = " The `GMainContext` struct is an opaque data"]
#[doc = " type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:"]
#[doc = ""]
#[doc = " The `GMainLoop` struct is an opaque data type"]
#[doc = " representing the main event loop of a GLib or GTK+ application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:"]
#[doc = ""]
#[doc = " The `GSource` struct is an opaque data type"]
#[doc = " representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:"]
#[doc = " @ref: Called when a reference is added to the callback object"]
#[doc = " @unref: Called when a reference to the callback object is dropped"]
#[doc = " @get: Called to extract the callback function and data from the"]
#[doc = "     callback object."]
#[doc = ""]
#[doc = " The `GSourceCallbackFuncs` struct contains"]
#[doc = " functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:"]
#[doc = " @prepare: Called before all the file descriptors are polled. If the"]
#[doc = "     source can determine that it is ready here (without waiting for the"]
#[doc = "     results of the poll() call) it should return %TRUE. It can also return"]
#[doc = "     a @timeout_ value which should be the maximum timeout (in milliseconds)"]
#[doc = "     which should be passed to the poll() call. The actual timeout used will"]
#[doc = "     be -1 if all sources returned -1, or it will be the minimum of all"]
#[doc = "     the @timeout_ values returned which were >= 0.  Since 2.36 this may"]
#[doc = "     be %NULL, in which case the effect is as if the function always returns"]
#[doc = "     %FALSE with a timeout of -1.  If @prepare returns a"]
#[doc = "     timeout and the source also has a ready time set, then the"]
#[doc = "     lower of the two will be used."]
#[doc = " @check: Called after all the file descriptors are polled. The source"]
#[doc = "     should return %TRUE if it is ready to be dispatched. Note that some"]
#[doc = "     time may have passed since the previous prepare function was called,"]
#[doc = "     so the source should be checked again here.  Since 2.36 this may"]
#[doc = "     be %NULL, in which case the effect is as if the function always returns"]
#[doc = "     %FALSE."]
#[doc = " @dispatch: Called to dispatch the event source, after it has returned"]
#[doc = "     %TRUE in either its @prepare or its @check function, or if a ready time"]
#[doc = "     has been reached. The @dispatch function receives a callback function and"]
#[doc = "     user data. The callback function may be %NULL if the source was never"]
#[doc = "     connected to a callback using g_source_set_callback(). The @dispatch"]
#[doc = "     function should call the callback function with @user_data and whatever"]
#[doc = "     additional parameters are needed for this type of event source. The"]
#[doc = "     return value of the @dispatch function should be #G_SOURCE_REMOVE if the"]
#[doc = "     source should be removed or #G_SOURCE_CONTINUE to keep it."]
#[doc = " @finalize: Called when the source is finalized. At this point, the source"]
#[doc = "     will have been destroyed, had its callback cleared, and have been removed"]
#[doc = "     from its #GMainContext, but it will still have its final reference count,"]
#[doc = "     so methods can be called on it from within this function."]
#[doc = ""]
#[doc = " The `GSourceFuncs` struct contains a table of"]
#[doc = " functions used to handle event sources in a generic manner."]
#[doc = ""]
#[doc = " For idle sources, the prepare and check functions always return %TRUE"]
#[doc = " to indicate that the source is always ready to be processed. The prepare"]
#[doc = " function also returns a timeout value of 0 to ensure that the poll() call"]
#[doc = " doesn't block (since that would be time wasted which could have been spent"]
#[doc = " running the idle function)."]
#[doc = ""]
#[doc = " For timeout sources, the prepare and check functions both return %TRUE"]
#[doc = " if the timeout interval has expired. The prepare function also returns"]
#[doc = " a timeout value to ensure that the poll() call doesn't block too long"]
#[doc = " and miss the next timeout."]
#[doc = ""]
#[doc = " For file descriptor sources, the prepare function typically returns %FALSE,"]
#[doc = " since it must wait until poll() has been called before it knows whether"]
#[doc = " any events need to be processed. It sets the returned timeout to -1 to"]
#[doc = " indicate that it doesn't mind how long the poll() call blocks. In the"]
#[doc = " check function, it tests the results of the poll() call to see if the"]
#[doc = " required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:"]
#[doc = " @user_data: data passed to the function, set when the source was"]
#[doc = "     created with one of the above functions"]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_timeout_add(),"]
#[doc = " g_timeout_add_full(), g_idle_add(), and g_idle_add_full()."]
#[doc = ""]
#[doc = " When calling g_source_set_callback(), you may need to cast a function of a"]
#[doc = " different type to this type. Use G_SOURCE_FUNC() to avoid warnings about"]
#[doc = " incompatible function types."]
#[doc = ""]
#[doc = " Returns: %FALSE if the source should be removed. #G_SOURCE_CONTINUE and"]
#[doc = " #G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GChildWatchFunc:"]
#[doc = " @pid: the process id of the child process"]
#[doc = " @status: Status information about the child process, encoded"]
#[doc = "     in a platform-specific manner"]
#[doc = " @user_data: user data passed to g_child_watch_add()"]
#[doc = ""]
#[doc = " Prototype of a #GChildWatchSource callback, called when a child"]
#[doc = " process has exited.  To interpret @status, see the documentation"]
#[doc = " for g_spawn_check_exit_status()."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, status: gint, user_data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    assert_eq!(
        ::std::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).callback_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).callback_funcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).source_funcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).ref_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).context as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).priority as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).source_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).poll_fds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(poll_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).prev as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).priv_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).ref_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).unref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(unref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(get)
        )
    );
}
#[doc = " GSourceDummyMarshal:"]
#[doc = ""]
#[doc = " This is just a placeholder for #GClosureMarshal,"]
#[doc = " which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).prepare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).check as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).dispatch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).finalize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).closure_callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).closure_marshal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_marshal)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_new"]
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_ref"]
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_unref"]
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_default"]
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_iteration"]
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_pending"]
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_find_source_by_id"]
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_find_source_by_user_data"]
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_find_source_by_funcs_user_data"]
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_wakeup"]
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_acquire"]
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_release"]
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_is_owner"]
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_wait"]
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_prepare"]
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_query"]
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_check"]
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_dispatch"]
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_set_poll_func"]
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_get_poll_func"]
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_add_poll"]
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_remove_poll"]
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    #[link_name = "\u{1}_g_main_depth"]
    pub fn g_main_depth() -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_main_current_source"]
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_push_thread_default"]
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_pop_thread_default"]
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_get_thread_default"]
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_ref_thread_default"]
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_new"]
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_run"]
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_quit"]
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_ref"]
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_unref"]
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_is_running"]
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_get_context"]
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_source_new"]
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_source_ref"]
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_source_unref"]
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    #[link_name = "\u{1}_g_source_attach"]
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_source_destroy"]
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_priority"]
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_priority"]
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_can_recurse"]
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_can_recurse"]
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_id"]
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_context"]
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_callback"]
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_funcs"]
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    #[link_name = "\u{1}_g_source_is_destroyed"]
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_name"]
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_name"]
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_name_by_id"]
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_ready_time"]
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_ready_time"]
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_source_add_unix_fd"]
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_source_modify_unix_fd"]
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_unix_fd"]
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_source_query_unix_fd"]
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_callback_indirect"]
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_source_add_poll"]
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_poll"]
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    #[link_name = "\u{1}_g_source_add_child_source"]
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_child_source"]
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_current_time"]
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_time"]
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_source_new"]
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_child_watch_source_new"]
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_source_new"]
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_source_new_seconds"]
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_get_current_time"]
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    #[link_name = "\u{1}_g_get_monotonic_time"]
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_get_real_time"]
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove"]
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_by_user_data"]
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_by_funcs_user_data"]
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:"]
#[doc = " @handle_id: the handle ID to clear"]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_clear_handle_id()."]
#[doc = " The implementation is expected to free the resource identified"]
#[doc = " by @handle_id; for instance, if @handle_id is a #GSource ID,"]
#[doc = " g_source_remove() can be used."]
#[doc = ""]
#[doc = " Since: 2.56"]
pub type GClearHandleFunc = ::std::option::Option<unsafe extern "C" fn(handle_id: guint)>;
extern "C" {
    #[link_name = "\u{1}_g_clear_handle_id"]
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_add_full"]
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_add"]
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_add_seconds_full"]
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_add_seconds"]
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_child_watch_add_full"]
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_child_watch_add"]
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_add"]
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_add_full"]
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_remove_by_data"]
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_invoke_full"]
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_invoke"]
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_funcs"]
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    #[link_name = "\u{1}_g_child_watch_funcs"]
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_funcs"]
    pub static mut g_idle_funcs: GSourceFuncs;
}
extern "C" {
    #[link_name = "\u{1}_g_unix_signal_funcs"]
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
extern "C" {
    #[link_name = "\u{1}_g_unix_fd_source_funcs"]
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
#[doc = " gunichar:"]
#[doc = ""]
#[doc = " A type which can hold any UTF-32 or UCS-4 character code,"]
#[doc = " also known as a Unicode code point."]
#[doc = ""]
#[doc = " If you want to produce the UTF-8 representation of a #gunichar,"]
#[doc = " use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse"]
#[doc = " process."]
#[doc = ""]
#[doc = " To print/scan values of this type as integer, use"]
#[doc = " %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT."]
#[doc = ""]
#[doc = " The notation to express a Unicode code point in running text is"]
#[doc = " as a hexadecimal number with four to six digits and uppercase"]
#[doc = " letters, prefixed by the string \"U+\". Leading zeros are omitted,"]
#[doc = " unless the code point would have fewer than four hexadecimal digits."]
#[doc = " For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point"]
#[doc = " in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\"."]
#[doc = " To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\"."]
#[doc = ""]
#[doc = " |["]
#[doc = " gunichar c;"]
#[doc = " sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)"]
#[doc = " g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);"]
#[doc = " ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:"]
#[doc = ""]
#[doc = " A type which can hold any UTF-16 code"]
#[doc = " point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called"]
#[doc = " <firstterm>surrogate pairs</firstterm> to encode characters beyond"]
#[doc = " the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored"]
#[doc = " in a single gunichar2 field, but all GLib functions accepting gunichar2"]
#[doc = " arrays will correctly interpret surrogate pairs.</footnote>."]
#[doc = ""]
#[doc = " To print/scan values of this type to/from text you need to convert"]
#[doc = " to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16()."]
#[doc = ""]
#[doc = " To print/scan values of this type as integer, use"]
#[doc = " %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
#[repr(u32)]
#[doc = " GUnicodeType:"]
#[doc = " @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)"]
#[doc = " @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)"]
#[doc = " @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)"]
#[doc = " @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)"]
#[doc = " @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)"]
#[doc = " @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)"]
#[doc = " @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)"]
#[doc = " @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)"]
#[doc = " @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)"]
#[doc = " @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)"]
#[doc = " @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)"]
#[doc = " @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)"]
#[doc = " @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)"]
#[doc = " @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)"]
#[doc = " @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)"]
#[doc = " @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)"]
#[doc = " @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)"]
#[doc = " @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)"]
#[doc = " @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)"]
#[doc = " @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)"]
#[doc = " @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)"]
#[doc = " @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)"]
#[doc = " @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)"]
#[doc = " @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)"]
#[doc = " @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)"]
#[doc = " @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)"]
#[doc = " @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)"]
#[doc = " @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)"]
#[doc = " @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)"]
#[doc = " @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)"]
#[doc = ""]
#[doc = " These are the possible character classifications from the"]
#[doc = " Unicode specification."]
#[doc = " See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GUnicodeType {
    G_UNICODE_CONTROL = 0,
    G_UNICODE_FORMAT = 1,
    G_UNICODE_UNASSIGNED = 2,
    G_UNICODE_PRIVATE_USE = 3,
    G_UNICODE_SURROGATE = 4,
    G_UNICODE_LOWERCASE_LETTER = 5,
    G_UNICODE_MODIFIER_LETTER = 6,
    G_UNICODE_OTHER_LETTER = 7,
    G_UNICODE_TITLECASE_LETTER = 8,
    G_UNICODE_UPPERCASE_LETTER = 9,
    G_UNICODE_SPACING_MARK = 10,
    G_UNICODE_ENCLOSING_MARK = 11,
    G_UNICODE_NON_SPACING_MARK = 12,
    G_UNICODE_DECIMAL_NUMBER = 13,
    G_UNICODE_LETTER_NUMBER = 14,
    G_UNICODE_OTHER_NUMBER = 15,
    G_UNICODE_CONNECT_PUNCTUATION = 16,
    G_UNICODE_DASH_PUNCTUATION = 17,
    G_UNICODE_CLOSE_PUNCTUATION = 18,
    G_UNICODE_FINAL_PUNCTUATION = 19,
    G_UNICODE_INITIAL_PUNCTUATION = 20,
    G_UNICODE_OTHER_PUNCTUATION = 21,
    G_UNICODE_OPEN_PUNCTUATION = 22,
    G_UNICODE_CURRENCY_SYMBOL = 23,
    G_UNICODE_MODIFIER_SYMBOL = 24,
    G_UNICODE_MATH_SYMBOL = 25,
    G_UNICODE_OTHER_SYMBOL = 26,
    G_UNICODE_LINE_SEPARATOR = 27,
    G_UNICODE_PARAGRAPH_SEPARATOR = 28,
    G_UNICODE_SPACE_SEPARATOR = 29,
}
#[repr(u32)]
#[doc = " GUnicodeBreakType:"]
#[doc = " @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)"]
#[doc = " @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)"]
#[doc = " @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)"]
#[doc = " @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)"]
#[doc = " @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)"]
#[doc = " @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)"]
#[doc = " @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)"]
#[doc = " @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)"]
#[doc = " @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)"]
#[doc = " @G_UNICODE_BREAK_SPACE: Space (SP)"]
#[doc = " @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)"]
#[doc = " @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)"]
#[doc = " @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)"]
#[doc = " @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)"]
#[doc = " @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)"]
#[doc = " @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)"]
#[doc = " @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)"]
#[doc = " @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)"]
#[doc = " @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)"]
#[doc = " @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)"]
#[doc = " @G_UNICODE_BREAK_NUMERIC: Numeric (NU)"]
#[doc = " @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)"]
#[doc = " @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)"]
#[doc = " @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)"]
#[doc = " @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)"]
#[doc = " @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)"]
#[doc = " @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)"]
#[doc = " @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)"]
#[doc = " @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)"]
#[doc = " @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)"]
#[doc = " @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)"]
#[doc = " @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28"]
#[doc = " @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32"]
#[doc = " @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32"]
#[doc = " @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36"]
#[doc = " @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50"]
#[doc = " @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50"]
#[doc = " @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50"]
#[doc = ""]
#[doc = " These are the possible line break classifications."]
#[doc = ""]
#[doc = " Since new unicode versions may add new types here, applications should be ready"]
#[doc = " to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN."]
#[doc = ""]
#[doc = " See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/)."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GUnicodeBreakType {
    G_UNICODE_BREAK_MANDATORY = 0,
    G_UNICODE_BREAK_CARRIAGE_RETURN = 1,
    G_UNICODE_BREAK_LINE_FEED = 2,
    G_UNICODE_BREAK_COMBINING_MARK = 3,
    G_UNICODE_BREAK_SURROGATE = 4,
    G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5,
    G_UNICODE_BREAK_INSEPARABLE = 6,
    G_UNICODE_BREAK_NON_BREAKING_GLUE = 7,
    G_UNICODE_BREAK_CONTINGENT = 8,
    G_UNICODE_BREAK_SPACE = 9,
    G_UNICODE_BREAK_AFTER = 10,
    G_UNICODE_BREAK_BEFORE = 11,
    G_UNICODE_BREAK_BEFORE_AND_AFTER = 12,
    G_UNICODE_BREAK_HYPHEN = 13,
    G_UNICODE_BREAK_NON_STARTER = 14,
    G_UNICODE_BREAK_OPEN_PUNCTUATION = 15,
    G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16,
    G_UNICODE_BREAK_QUOTATION = 17,
    G_UNICODE_BREAK_EXCLAMATION = 18,
    G_UNICODE_BREAK_IDEOGRAPHIC = 19,
    G_UNICODE_BREAK_NUMERIC = 20,
    G_UNICODE_BREAK_INFIX_SEPARATOR = 21,
    G_UNICODE_BREAK_SYMBOL = 22,
    G_UNICODE_BREAK_ALPHABETIC = 23,
    G_UNICODE_BREAK_PREFIX = 24,
    G_UNICODE_BREAK_POSTFIX = 25,
    G_UNICODE_BREAK_COMPLEX_CONTEXT = 26,
    G_UNICODE_BREAK_AMBIGUOUS = 27,
    G_UNICODE_BREAK_UNKNOWN = 28,
    G_UNICODE_BREAK_NEXT_LINE = 29,
    G_UNICODE_BREAK_WORD_JOINER = 30,
    G_UNICODE_BREAK_HANGUL_L_JAMO = 31,
    G_UNICODE_BREAK_HANGUL_V_JAMO = 32,
    G_UNICODE_BREAK_HANGUL_T_JAMO = 33,
    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34,
    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35,
    G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36,
    G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37,
    G_UNICODE_BREAK_HEBREW_LETTER = 38,
    G_UNICODE_BREAK_REGIONAL_INDICATOR = 39,
    G_UNICODE_BREAK_EMOJI_BASE = 40,
    G_UNICODE_BREAK_EMOJI_MODIFIER = 41,
    G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42,
}
#[repr(i32)]
#[doc = " GUnicodeScript:"]
#[doc = " @G_UNICODE_SCRIPT_INVALID_CODE:"]
#[doc = "                               a value never returned from g_unichar_get_script()"]
#[doc = " @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts"]
#[doc = " @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the"]
#[doc = "                               base glyph to which it is attached"]
#[doc = " @G_UNICODE_SCRIPT_ARABIC:     Arabic"]
#[doc = " @G_UNICODE_SCRIPT_ARMENIAN:   Armenian"]
#[doc = " @G_UNICODE_SCRIPT_BENGALI:    Bengali"]
#[doc = " @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo"]
#[doc = " @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee"]
#[doc = " @G_UNICODE_SCRIPT_COPTIC:     Coptic"]
#[doc = " @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic"]
#[doc = " @G_UNICODE_SCRIPT_DESERET:    Deseret"]
#[doc = " @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari"]
#[doc = " @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic"]
#[doc = " @G_UNICODE_SCRIPT_GEORGIAN:   Georgian"]
#[doc = " @G_UNICODE_SCRIPT_GOTHIC:     Gothic"]
#[doc = " @G_UNICODE_SCRIPT_GREEK:      Greek"]
#[doc = " @G_UNICODE_SCRIPT_GUJARATI:   Gujarati"]
#[doc = " @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi"]
#[doc = " @G_UNICODE_SCRIPT_HAN:        Han"]
#[doc = " @G_UNICODE_SCRIPT_HANGUL:     Hangul"]
#[doc = " @G_UNICODE_SCRIPT_HEBREW:     Hebrew"]
#[doc = " @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana"]
#[doc = " @G_UNICODE_SCRIPT_KANNADA:    Kannada"]
#[doc = " @G_UNICODE_SCRIPT_KATAKANA:   Katakana"]
#[doc = " @G_UNICODE_SCRIPT_KHMER:      Khmer"]
#[doc = " @G_UNICODE_SCRIPT_LAO:        Lao"]
#[doc = " @G_UNICODE_SCRIPT_LATIN:      Latin"]
#[doc = " @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam"]
#[doc = " @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian"]
#[doc = " @G_UNICODE_SCRIPT_MYANMAR:    Myanmar"]
#[doc = " @G_UNICODE_SCRIPT_OGHAM:      Ogham"]
#[doc = " @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic"]
#[doc = " @G_UNICODE_SCRIPT_ORIYA:      Oriya"]
#[doc = " @G_UNICODE_SCRIPT_RUNIC:      Runic"]
#[doc = " @G_UNICODE_SCRIPT_SINHALA:    Sinhala"]
#[doc = " @G_UNICODE_SCRIPT_SYRIAC:     Syriac"]
#[doc = " @G_UNICODE_SCRIPT_TAMIL:      Tamil"]
#[doc = " @G_UNICODE_SCRIPT_TELUGU:     Telugu"]
#[doc = " @G_UNICODE_SCRIPT_THAANA:     Thaana"]
#[doc = " @G_UNICODE_SCRIPT_THAI:       Thai"]
#[doc = " @G_UNICODE_SCRIPT_TIBETAN:    Tibetan"]
#[doc = " @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:"]
#[doc = "                               Canadian Aboriginal"]
#[doc = " @G_UNICODE_SCRIPT_YI:         Yi"]
#[doc = " @G_UNICODE_SCRIPT_TAGALOG:    Tagalog"]
#[doc = " @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo"]
#[doc = " @G_UNICODE_SCRIPT_BUHID:      Buhid"]
#[doc = " @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa"]
#[doc = " @G_UNICODE_SCRIPT_BRAILLE:    Braille"]
#[doc = " @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot"]
#[doc = " @G_UNICODE_SCRIPT_LIMBU:      Limbu"]
#[doc = " @G_UNICODE_SCRIPT_OSMANYA:    Osmanya"]
#[doc = " @G_UNICODE_SCRIPT_SHAVIAN:    Shavian"]
#[doc = " @G_UNICODE_SCRIPT_LINEAR_B:   Linear B"]
#[doc = " @G_UNICODE_SCRIPT_TAI_LE:     Tai Le"]
#[doc = " @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic"]
#[doc = " @G_UNICODE_SCRIPT_NEW_TAI_LUE:"]
#[doc = "                               New Tai Lue"]
#[doc = " @G_UNICODE_SCRIPT_BUGINESE:   Buginese"]
#[doc = " @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic"]
#[doc = " @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh"]
#[doc = " @G_UNICODE_SCRIPT_SYLOTI_NAGRI:"]
#[doc = "                               Syloti Nagri"]
#[doc = " @G_UNICODE_SCRIPT_OLD_PERSIAN:"]
#[doc = "                               Old Persian"]
#[doc = " @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi"]
#[doc = " @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point"]
#[doc = " @G_UNICODE_SCRIPT_BALINESE:   Balinese"]
#[doc = " @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform"]
#[doc = " @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician"]
#[doc = " @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa"]
#[doc = " @G_UNICODE_SCRIPT_NKO:        N'Ko"]
#[doc = " @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:"]
#[doc = "                               Egyptian Hieroglpyhs. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:"]
#[doc = "                               Imperial Aramaic. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:"]
#[doc = "                               Inscriptional Pahlavi. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:"]
#[doc = "                               Inscriptional Parthian. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_MEETEI_MAYEK:"]
#[doc = "                               Meetei Mayek. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:"]
#[doc = "                               Old South Arabian. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58"]
#[doc = ""]
#[doc = " The #GUnicodeScript enumeration identifies different writing"]
#[doc = " systems. The values correspond to the names as defined in the"]
#[doc = " Unicode standard. The enumeration has been added in GLib 2.14,"]
#[doc = " and is interchangeable with #PangoScript."]
#[doc = ""]
#[doc = " Note that new types may be added in the future. Applications"]
#[doc = " should be ready to handle unknown values."]
#[doc = " See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GUnicodeScript {
    G_UNICODE_SCRIPT_INVALID_CODE = -1,
    G_UNICODE_SCRIPT_COMMON = 0,
    G_UNICODE_SCRIPT_INHERITED = 1,
    G_UNICODE_SCRIPT_ARABIC = 2,
    G_UNICODE_SCRIPT_ARMENIAN = 3,
    G_UNICODE_SCRIPT_BENGALI = 4,
    G_UNICODE_SCRIPT_BOPOMOFO = 5,
    G_UNICODE_SCRIPT_CHEROKEE = 6,
    G_UNICODE_SCRIPT_COPTIC = 7,
    G_UNICODE_SCRIPT_CYRILLIC = 8,
    G_UNICODE_SCRIPT_DESERET = 9,
    G_UNICODE_SCRIPT_DEVANAGARI = 10,
    G_UNICODE_SCRIPT_ETHIOPIC = 11,
    G_UNICODE_SCRIPT_GEORGIAN = 12,
    G_UNICODE_SCRIPT_GOTHIC = 13,
    G_UNICODE_SCRIPT_GREEK = 14,
    G_UNICODE_SCRIPT_GUJARATI = 15,
    G_UNICODE_SCRIPT_GURMUKHI = 16,
    G_UNICODE_SCRIPT_HAN = 17,
    G_UNICODE_SCRIPT_HANGUL = 18,
    G_UNICODE_SCRIPT_HEBREW = 19,
    G_UNICODE_SCRIPT_HIRAGANA = 20,
    G_UNICODE_SCRIPT_KANNADA = 21,
    G_UNICODE_SCRIPT_KATAKANA = 22,
    G_UNICODE_SCRIPT_KHMER = 23,
    G_UNICODE_SCRIPT_LAO = 24,
    G_UNICODE_SCRIPT_LATIN = 25,
    G_UNICODE_SCRIPT_MALAYALAM = 26,
    G_UNICODE_SCRIPT_MONGOLIAN = 27,
    G_UNICODE_SCRIPT_MYANMAR = 28,
    G_UNICODE_SCRIPT_OGHAM = 29,
    G_UNICODE_SCRIPT_OLD_ITALIC = 30,
    G_UNICODE_SCRIPT_ORIYA = 31,
    G_UNICODE_SCRIPT_RUNIC = 32,
    G_UNICODE_SCRIPT_SINHALA = 33,
    G_UNICODE_SCRIPT_SYRIAC = 34,
    G_UNICODE_SCRIPT_TAMIL = 35,
    G_UNICODE_SCRIPT_TELUGU = 36,
    G_UNICODE_SCRIPT_THAANA = 37,
    G_UNICODE_SCRIPT_THAI = 38,
    G_UNICODE_SCRIPT_TIBETAN = 39,
    G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40,
    G_UNICODE_SCRIPT_YI = 41,
    G_UNICODE_SCRIPT_TAGALOG = 42,
    G_UNICODE_SCRIPT_HANUNOO = 43,
    G_UNICODE_SCRIPT_BUHID = 44,
    G_UNICODE_SCRIPT_TAGBANWA = 45,
    G_UNICODE_SCRIPT_BRAILLE = 46,
    G_UNICODE_SCRIPT_CYPRIOT = 47,
    G_UNICODE_SCRIPT_LIMBU = 48,
    G_UNICODE_SCRIPT_OSMANYA = 49,
    G_UNICODE_SCRIPT_SHAVIAN = 50,
    G_UNICODE_SCRIPT_LINEAR_B = 51,
    G_UNICODE_SCRIPT_TAI_LE = 52,
    G_UNICODE_SCRIPT_UGARITIC = 53,
    G_UNICODE_SCRIPT_NEW_TAI_LUE = 54,
    G_UNICODE_SCRIPT_BUGINESE = 55,
    G_UNICODE_SCRIPT_GLAGOLITIC = 56,
    G_UNICODE_SCRIPT_TIFINAGH = 57,
    G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58,
    G_UNICODE_SCRIPT_OLD_PERSIAN = 59,
    G_UNICODE_SCRIPT_KHAROSHTHI = 60,
    G_UNICODE_SCRIPT_UNKNOWN = 61,
    G_UNICODE_SCRIPT_BALINESE = 62,
    G_UNICODE_SCRIPT_CUNEIFORM = 63,
    G_UNICODE_SCRIPT_PHOENICIAN = 64,
    G_UNICODE_SCRIPT_PHAGS_PA = 65,
    G_UNICODE_SCRIPT_NKO = 66,
    G_UNICODE_SCRIPT_KAYAH_LI = 67,
    G_UNICODE_SCRIPT_LEPCHA = 68,
    G_UNICODE_SCRIPT_REJANG = 69,
    G_UNICODE_SCRIPT_SUNDANESE = 70,
    G_UNICODE_SCRIPT_SAURASHTRA = 71,
    G_UNICODE_SCRIPT_CHAM = 72,
    G_UNICODE_SCRIPT_OL_CHIKI = 73,
    G_UNICODE_SCRIPT_VAI = 74,
    G_UNICODE_SCRIPT_CARIAN = 75,
    G_UNICODE_SCRIPT_LYCIAN = 76,
    G_UNICODE_SCRIPT_LYDIAN = 77,
    G_UNICODE_SCRIPT_AVESTAN = 78,
    G_UNICODE_SCRIPT_BAMUM = 79,
    G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80,
    G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83,
    G_UNICODE_SCRIPT_JAVANESE = 84,
    G_UNICODE_SCRIPT_KAITHI = 85,
    G_UNICODE_SCRIPT_LISU = 86,
    G_UNICODE_SCRIPT_MEETEI_MAYEK = 87,
    G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88,
    G_UNICODE_SCRIPT_OLD_TURKIC = 89,
    G_UNICODE_SCRIPT_SAMARITAN = 90,
    G_UNICODE_SCRIPT_TAI_THAM = 91,
    G_UNICODE_SCRIPT_TAI_VIET = 92,
    G_UNICODE_SCRIPT_BATAK = 93,
    G_UNICODE_SCRIPT_BRAHMI = 94,
    G_UNICODE_SCRIPT_MANDAIC = 95,
    G_UNICODE_SCRIPT_CHAKMA = 96,
    G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97,
    G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98,
    G_UNICODE_SCRIPT_MIAO = 99,
    G_UNICODE_SCRIPT_SHARADA = 100,
    G_UNICODE_SCRIPT_SORA_SOMPENG = 101,
    G_UNICODE_SCRIPT_TAKRI = 102,
    G_UNICODE_SCRIPT_BASSA_VAH = 103,
    G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104,
    G_UNICODE_SCRIPT_DUPLOYAN = 105,
    G_UNICODE_SCRIPT_ELBASAN = 106,
    G_UNICODE_SCRIPT_GRANTHA = 107,
    G_UNICODE_SCRIPT_KHOJKI = 108,
    G_UNICODE_SCRIPT_KHUDAWADI = 109,
    G_UNICODE_SCRIPT_LINEAR_A = 110,
    G_UNICODE_SCRIPT_MAHAJANI = 111,
    G_UNICODE_SCRIPT_MANICHAEAN = 112,
    G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113,
    G_UNICODE_SCRIPT_MODI = 114,
    G_UNICODE_SCRIPT_MRO = 115,
    G_UNICODE_SCRIPT_NABATAEAN = 116,
    G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117,
    G_UNICODE_SCRIPT_OLD_PERMIC = 118,
    G_UNICODE_SCRIPT_PAHAWH_HMONG = 119,
    G_UNICODE_SCRIPT_PALMYRENE = 120,
    G_UNICODE_SCRIPT_PAU_CIN_HAU = 121,
    G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122,
    G_UNICODE_SCRIPT_SIDDHAM = 123,
    G_UNICODE_SCRIPT_TIRHUTA = 124,
    G_UNICODE_SCRIPT_WARANG_CITI = 125,
    G_UNICODE_SCRIPT_AHOM = 126,
    G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127,
    G_UNICODE_SCRIPT_HATRAN = 128,
    G_UNICODE_SCRIPT_MULTANI = 129,
    G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130,
    G_UNICODE_SCRIPT_SIGNWRITING = 131,
    G_UNICODE_SCRIPT_ADLAM = 132,
    G_UNICODE_SCRIPT_BHAIKSUKI = 133,
    G_UNICODE_SCRIPT_MARCHEN = 134,
    G_UNICODE_SCRIPT_NEWA = 135,
    G_UNICODE_SCRIPT_OSAGE = 136,
    G_UNICODE_SCRIPT_TANGUT = 137,
    G_UNICODE_SCRIPT_MASARAM_GONDI = 138,
    G_UNICODE_SCRIPT_NUSHU = 139,
    G_UNICODE_SCRIPT_SOYOMBO = 140,
    G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141,
    G_UNICODE_SCRIPT_DOGRA = 142,
    G_UNICODE_SCRIPT_GUNJALA_GONDI = 143,
    G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144,
    G_UNICODE_SCRIPT_MAKASAR = 145,
    G_UNICODE_SCRIPT_MEDEFAIDRIN = 146,
    G_UNICODE_SCRIPT_OLD_SOGDIAN = 147,
    G_UNICODE_SCRIPT_SOGDIAN = 148,
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_script_to_iso15924"]
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_script_from_iso15924"]
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isalnum"]
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isalpha"]
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_iscntrl"]
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isdigit"]
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isgraph"]
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_islower"]
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isprint"]
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_ispunct"]
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isspace"]
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isupper"]
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isxdigit"]
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_istitle"]
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isdefined"]
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_iswide"]
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_iswide_cjk"]
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_iszerowidth"]
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_ismark"]
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_toupper"]
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_tolower"]
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_totitle"]
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_digit_value"]
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_xdigit_value"]
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_type"]
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_break_type"]
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_combining_class"]
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_get_mirror_char"]
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_get_script"]
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_validate"]
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_compose"]
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_decompose"]
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_fully_decompose"]
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_canonical_ordering"]
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_canonical_decomposition"]
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_skip"]
    pub static g_utf8_skip: *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_get_char"]
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_get_char_validated"]
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_offset_to_pointer"]
    pub fn g_utf8_offset_to_pointer(str: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_pointer_to_offset"]
    pub fn g_utf8_pointer_to_offset(str: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_prev_char"]
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_find_next_char"]
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_find_prev_char"]
    pub fn g_utf8_find_prev_char(str: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strlen"]
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_substring"]
    pub fn g_utf8_substring(str: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strncpy"]
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strchr"]
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strrchr"]
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strreverse"]
    pub fn g_utf8_strreverse(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_to_utf16"]
    pub fn g_utf8_to_utf16(
        str: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_to_ucs4"]
    pub fn g_utf8_to_ucs4(
        str: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_to_ucs4_fast"]
    pub fn g_utf8_to_ucs4_fast(
        str: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf16_to_ucs4"]
    pub fn g_utf16_to_ucs4(
        str: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf16_to_utf8"]
    pub fn g_utf16_to_utf8(
        str: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ucs4_to_utf16"]
    pub fn g_ucs4_to_utf16(
        str: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    #[link_name = "\u{1}_g_ucs4_to_utf8"]
    pub fn g_ucs4_to_utf8(
        str: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_to_utf8"]
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_validate"]
    pub fn g_utf8_validate(str: *const gchar, max_len: gssize, end: *mut *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_validate_len"]
    pub fn g_utf8_validate_len(
        str: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strup"]
    pub fn g_utf8_strup(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strdown"]
    pub fn g_utf8_strdown(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_casefold"]
    pub fn g_utf8_casefold(str: *const gchar, len: gssize) -> *mut gchar;
}
impl GNormalizeMode {
    pub const G_NORMALIZE_NFD: GNormalizeMode = GNormalizeMode::G_NORMALIZE_DEFAULT;
}
impl GNormalizeMode {
    pub const G_NORMALIZE_NFC: GNormalizeMode = GNormalizeMode::G_NORMALIZE_DEFAULT_COMPOSE;
}
impl GNormalizeMode {
    pub const G_NORMALIZE_NFKD: GNormalizeMode = GNormalizeMode::G_NORMALIZE_ALL;
}
impl GNormalizeMode {
    pub const G_NORMALIZE_NFKC: GNormalizeMode = GNormalizeMode::G_NORMALIZE_ALL_COMPOSE;
}
#[repr(u32)]
#[doc = " GNormalizeMode:"]
#[doc = " @G_NORMALIZE_DEFAULT: standardize differences that do not affect the"]
#[doc = "     text content, such as the above-mentioned accent representation"]
#[doc = " @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT"]
#[doc = " @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with"]
#[doc = "     composed forms rather than a maximally decomposed form"]
#[doc = " @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE"]
#[doc = " @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the"]
#[doc = "     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE"]
#[doc = "     to the standard forms (in this case DIGIT THREE). Formatting"]
#[doc = "     information may be lost but for most text operations such"]
#[doc = "     characters should be considered the same"]
#[doc = " @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL"]
#[doc = " @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed"]
#[doc = "     forms rather than a maximally decomposed form"]
#[doc = " @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE"]
#[doc = ""]
#[doc = " Defines how a Unicode string is transformed in a canonical"]
#[doc = " form, standardizing such issues as whether a character with"]
#[doc = " an accent is represented as a base character and combining"]
#[doc = " accent or as a single precomposed character. Unicode strings"]
#[doc = " should generally be normalized before comparing them."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GNormalizeMode {
    G_NORMALIZE_DEFAULT = 0,
    G_NORMALIZE_DEFAULT_COMPOSE = 1,
    G_NORMALIZE_ALL = 2,
    G_NORMALIZE_ALL_COMPOSE = 3,
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_normalize"]
    pub fn g_utf8_normalize(str: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_collate"]
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_collate_key"]
    pub fn g_utf8_collate_key(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_collate_key_for_filename"]
    pub fn g_utf8_collate_key_for_filename(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_make_valid"]
    pub fn g_utf8_make_valid(str: *const gchar, len: gssize) -> *mut gchar;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    assert_eq!(
        ::std::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).allocated_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(allocated_len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_string_new"]
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_new_len"]
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_sized_new"]
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_free"]
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_string_free_to_bytes"]
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_string_equal"]
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_string_hash"]
    pub fn g_string_hash(str: *const GString) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_string_assign"]
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_truncate"]
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_set_size"]
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_insert_len"]
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_append"]
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_len"]
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_c"]
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_unichar"]
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_prepend"]
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_prepend_c"]
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_prepend_unichar"]
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_prepend_len"]
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_insert"]
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_insert_c"]
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_insert_unichar"]
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_overwrite"]
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_overwrite_len"]
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_erase"]
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_ascii_down"]
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_ascii_up"]
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_vprintf"]
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
extern "C" {
    #[link_name = "\u{1}_g_string_printf"]
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_vprintf"]
    pub fn g_string_append_vprintf(
        string: *mut GString,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_printf"]
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_uri_escaped"]
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_down"]
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_up"]
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GIOError {
    G_IO_ERROR_NONE = 0,
    G_IO_ERROR_AGAIN = 1,
    G_IO_ERROR_INVAL = 2,
    G_IO_ERROR_UNKNOWN = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GIOChannelError {
    G_IO_CHANNEL_ERROR_FBIG = 0,
    G_IO_CHANNEL_ERROR_INVAL = 1,
    G_IO_CHANNEL_ERROR_IO = 2,
    G_IO_CHANNEL_ERROR_ISDIR = 3,
    G_IO_CHANNEL_ERROR_NOSPC = 4,
    G_IO_CHANNEL_ERROR_NXIO = 5,
    G_IO_CHANNEL_ERROR_OVERFLOW = 6,
    G_IO_CHANNEL_ERROR_PIPE = 7,
    G_IO_CHANNEL_ERROR_FAILED = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GIOStatus {
    G_IO_STATUS_ERROR = 0,
    G_IO_STATUS_NORMAL = 1,
    G_IO_STATUS_EOF = 2,
    G_IO_STATUS_AGAIN = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GSeekType {
    G_SEEK_CUR = 0,
    G_SEEK_SET = 1,
    G_SEEK_END = 2,
}
impl GIOFlags {
    pub const G_IO_FLAG_IS_WRITEABLE: GIOFlags = GIOFlags::G_IO_FLAG_IS_WRITABLE;
}
impl GIOFlags {
    pub const G_IO_FLAG_GET_MASK: GIOFlags = GIOFlags::G_IO_FLAG_MASK;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GIOFlags {
    G_IO_FLAG_APPEND = 1,
    G_IO_FLAG_NONBLOCK = 2,
    G_IO_FLAG_IS_READABLE = 4,
    G_IO_FLAG_IS_WRITABLE = 8,
    G_IO_FLAG_IS_SEEKABLE = 16,
    G_IO_FLAG_MASK = 31,
    G_IO_FLAG_SET_MASK = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    assert_eq!(
        ::std::mem::size_of::<_GIOChannel>(),
        112usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).funcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).encoding as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).read_cd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).write_cd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).line_term as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).line_term_len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).buf_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).read_buf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).encoded_read_buf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoded_read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).write_buf as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).partial_write_buf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(partial_write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).reserved1 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).reserved2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_create_watch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_create_watch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_set_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_set_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_get_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_get_flags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_init"]
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_ref"]
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_unref"]
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read"]
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_write"]
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_seek"]
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_close"]
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_shutdown"]
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_add_watch_full"]
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_create_watch"]
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_io_add_watch"]
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_buffer_size"]
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_buffer_size"]
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_buffer_condition"]
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_flags"]
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_flags"]
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_line_term"]
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_line_term"]
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_buffered"]
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_buffered"]
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_encoding"]
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_encoding"]
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_close_on_unref"]
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_close_on_unref"]
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_flush"]
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_line"]
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_line_string"]
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_to_end"]
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_chars"]
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_unichar"]
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_write_chars"]
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_write_unichar"]
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_seek_position"]
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_new_file"]
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_error_quark"]
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_error_from_errno"]
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_unix_new"]
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_unix_get_fd"]
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_watch_funcs"]
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GKeyFileError {
    G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0,
    G_KEY_FILE_ERROR_PARSE = 1,
    G_KEY_FILE_ERROR_NOT_FOUND = 2,
    G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3,
    G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4,
    G_KEY_FILE_ERROR_INVALID_VALUE = 5,
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_error_quark"]
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GKeyFileFlags {
    G_KEY_FILE_NONE = 0,
    G_KEY_FILE_KEEP_COMMENTS = 1,
    G_KEY_FILE_KEEP_TRANSLATIONS = 2,
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_new"]
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_ref"]
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_unref"]
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_free"]
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_list_separator"]
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_file"]
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_data"]
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_bytes"]
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_dirs"]
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_data_dirs"]
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_to_data"]
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_save_to_file"]
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_start_group"]
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_groups"]
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_keys"]
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_has_group"]
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_has_key"]
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_value"]
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_value"]
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_string"]
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_string"]
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_locale_string"]
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_locale_for_key"]
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_locale_string"]
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_boolean"]
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_boolean"]
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_integer"]
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_integer"]
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_int64"]
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_int64"]
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_uint64"]
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_uint64"]
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_double"]
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_double"]
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_string_list"]
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_string_list"]
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_locale_string_list"]
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_locale_string_list"]
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_boolean_list"]
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_boolean_list"]
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_integer_list"]
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_double_list"]
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_double_list"]
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_integer_list"]
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_comment"]
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_comment"]
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_remove_comment"]
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_remove_key"]
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_remove_group"]
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_new"]
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_new_from_fd"]
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_get_length"]
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_get_contents"]
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_get_bytes"]
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_ref"]
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_unref"]
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_free"]
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
#[repr(u32)]
#[doc = " GMarkupError:"]
#[doc = " @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8"]
#[doc = " @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace"]
#[doc = " @G_MARKUP_ERROR_PARSE: document was ill-formed"]
#[doc = " @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser"]
#[doc = "     functions; element wasn't known"]
#[doc = " @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser"]
#[doc = "     functions; attribute wasn't known"]
#[doc = " @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser"]
#[doc = "     functions; content was invalid"]
#[doc = " @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser"]
#[doc = "     functions; a required attribute was missing"]
#[doc = ""]
#[doc = " Error codes returned by markup parsing."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GMarkupError {
    G_MARKUP_ERROR_BAD_UTF8 = 0,
    G_MARKUP_ERROR_EMPTY = 1,
    G_MARKUP_ERROR_PARSE = 2,
    G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3,
    G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4,
    G_MARKUP_ERROR_INVALID_CONTENT = 5,
    G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6,
}
extern "C" {
    #[link_name = "\u{1}_g_markup_error_quark"]
    pub fn g_markup_error_quark() -> GQuark;
}
#[repr(u32)]
#[doc = " GMarkupParseFlags:"]
#[doc = " @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use"]
#[doc = " @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked"]
#[doc = "     sections are not passed literally to the @passthrough function of"]
#[doc = "     the parser. Instead, the content of the section (without the"]
#[doc = "     `<![CDATA[` and `]]>`) is"]
#[doc = "     passed to the @text function. This flag was added in GLib 2.12"]
#[doc = " @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup"]
#[doc = "     itself have line/column information prefixed to them to let the"]
#[doc = "     caller know the location of the error. When this flag is set the"]
#[doc = "     location information is also prefixed to errors generated by the"]
#[doc = "     #GMarkupParser implementation functions"]
#[doc = " @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified"]
#[doc = "     attributes and tags, along with their contents.  A qualified"]
#[doc = "     attribute or tag is one that contains ':' in its name (ie: is in"]
#[doc = "     another namespace).  Since: 2.40."]
#[doc = ""]
#[doc = " Flags that affect the behaviour of the parser."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GMarkupParseFlags {
    G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
    G_MARKUP_TREAT_CDATA_AS_TEXT = 2,
    G_MARKUP_PREFIX_ERROR_POSITION = 4,
    G_MARKUP_IGNORE_QUALIFIED = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:"]
#[doc = ""]
#[doc = " A parse context is used to parse a stream of bytes that"]
#[doc = " you expect to contain marked-up text."]
#[doc = ""]
#[doc = " See g_markup_parse_context_new(), #GMarkupParser, and so"]
#[doc = " on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:"]
#[doc = " @start_element: Callback to invoke when the opening tag of an element"]
#[doc = "     is seen. The callback's @attribute_names and @attribute_values parameters"]
#[doc = "     are %NULL-terminated."]
#[doc = " @end_element: Callback to invoke when the closing tag of an element"]
#[doc = "     is seen. Note that this is also called for empty tags like"]
#[doc = "     `<empty/>`."]
#[doc = " @text: Callback to invoke when some text is seen (text is always"]
#[doc = "     inside an element). Note that the text of an element may be spread"]
#[doc = "     over multiple calls of this function. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also"]
#[doc = "     called for the content of CDATA marked sections."]
#[doc = " @passthrough: Callback to invoke for comments, processing instructions"]
#[doc = "     and doctype declarations; if you're re-writing the parsed document,"]
#[doc = "     write the passthrough text back out in the same position. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also"]
#[doc = "     called for CDATA marked sections."]
#[doc = " @error: Callback to invoke when an error occurs."]
#[doc = ""]
#[doc = " Any of the fields in #GMarkupParser can be %NULL, in which case they"]
#[doc = " will be ignored. Except for the @error function, any of these callbacks"]
#[doc = " can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,"]
#[doc = " %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT"]
#[doc = " errors are intended to be set from these callbacks. If you set an error"]
#[doc = " from a callback, g_markup_parse_context_parse() will report that error"]
#[doc = " back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    assert_eq!(
        ::std::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).start_element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(start_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).end_element as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(end_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).text as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).passthrough as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(passthrough)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).error as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_new"]
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_ref"]
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_unref"]
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_free"]
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_parse"]
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_push"]
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_pop"]
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_end_parse"]
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_element"]
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_element_stack"]
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_position"]
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_user_data"]
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_escape_text"]
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_printf_escaped"]
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_vprintf_escaped"]
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut gchar;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GMarkupCollectType {
    G_MARKUP_COLLECT_INVALID = 0,
    G_MARKUP_COLLECT_STRING = 1,
    G_MARKUP_COLLECT_STRDUP = 2,
    G_MARKUP_COLLECT_BOOLEAN = 3,
    G_MARKUP_COLLECT_TRISTATE = 4,
    G_MARKUP_COLLECT_OPTIONAL = 65536,
}
extern "C" {
    #[link_name = "\u{1}_g_markup_collect_attributes"]
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:"]
#[doc = ""]
#[doc = " A type in the GVariant type system."]
#[doc = ""]
#[doc = " Two types may not be compared by value; use g_variant_type_equal() or"]
#[doc = " g_variant_type_is_subtype_of().  May be copied using"]
#[doc = " g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
extern "C" {
    #[link_name = "\u{1}_g_variant_type_string_is_valid"]
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_string_scan"]
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_free"]
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_copy"]
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new"]
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_get_string_length"]
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_peek_string"]
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_dup_string"]
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_definite"]
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_container"]
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_basic"]
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_maybe"]
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_array"]
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_tuple"]
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_dict_entry"]
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_variant"]
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_hash"]
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_equal"]
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_subtype_of"]
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_element"]
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_first"]
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_next"]
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_n_items"]
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_key"]
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_value"]
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new_array"]
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new_maybe"]
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new_tuple"]
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new_dict_entry"]
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_checked_"]
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_string_get_depth_"]
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GVariantClass {
    G_VARIANT_CLASS_BOOLEAN = 98,
    G_VARIANT_CLASS_BYTE = 121,
    G_VARIANT_CLASS_INT16 = 110,
    G_VARIANT_CLASS_UINT16 = 113,
    G_VARIANT_CLASS_INT32 = 105,
    G_VARIANT_CLASS_UINT32 = 117,
    G_VARIANT_CLASS_INT64 = 120,
    G_VARIANT_CLASS_UINT64 = 116,
    G_VARIANT_CLASS_HANDLE = 104,
    G_VARIANT_CLASS_DOUBLE = 100,
    G_VARIANT_CLASS_STRING = 115,
    G_VARIANT_CLASS_OBJECT_PATH = 111,
    G_VARIANT_CLASS_SIGNATURE = 103,
    G_VARIANT_CLASS_VARIANT = 118,
    G_VARIANT_CLASS_MAYBE = 109,
    G_VARIANT_CLASS_ARRAY = 97,
    G_VARIANT_CLASS_TUPLE = 40,
    G_VARIANT_CLASS_DICT_ENTRY = 123,
}
extern "C" {
    #[link_name = "\u{1}_g_variant_unref"]
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_ref"]
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_ref_sink"]
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_floating"]
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_take_ref"]
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_type"]
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_type_string"]
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_of_type"]
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_container"]
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_classify"]
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_boolean"]
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_byte"]
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_int16"]
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_uint16"]
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_int32"]
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_uint32"]
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_int64"]
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_uint64"]
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_handle"]
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_double"]
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_string"]
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_take_string"]
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_printf"]
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_object_path"]
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_object_path"]
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_signature"]
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_signature"]
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_variant"]
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_strv"]
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_objv"]
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_bytestring"]
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_bytestring_array"]
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_fixed_array"]
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_boolean"]
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_byte"]
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_int16"]
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_uint16"]
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_int32"]
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_uint32"]
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_int64"]
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_uint64"]
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_handle"]
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_double"]
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_variant"]
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_string"]
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_string"]
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_strv"]
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_strv"]
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_objv"]
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_objv"]
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_bytestring"]
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_bytestring"]
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_bytestring_array"]
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_bytestring_array"]
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_maybe"]
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_array"]
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_tuple"]
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_dict_entry"]
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_maybe"]
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_n_children"]
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_child"]
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_child_value"]
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_lookup"]
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_lookup_value"]
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_fixed_array"]
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_size"]
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_data"]
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_data_as_bytes"]
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_store"]
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_print"]
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_print_string"]
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_hash"]
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_equal"]
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_normal_form"]
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_normal_form"]
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_byteswap"]
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_from_bytes"]
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_from_data"]
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantIter>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantIter),
            "::",
            stringify!(x)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_new"]
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_init"]
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_copy"]
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_n_children"]
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_free"]
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_next_value"]
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_next"]
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_loop"]
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).partial_magic
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).type_
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).y as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1>())).s as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantBuilder>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder),
            "::",
            stringify!(u)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GVariantParseError {
    G_VARIANT_PARSE_ERROR_FAILED = 0,
    G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1,
    G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2,
    G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3,
    G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4,
    G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5,
    G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6,
    G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7,
    G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8,
    G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9,
    G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10,
    G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11,
    G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12,
    G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13,
    G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14,
    G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15,
    G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16,
    G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17,
}
extern "C" {
    #[link_name = "\u{1}_g_variant_parser_get_error_quark"]
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_parse_error_quark"]
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_new"]
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_unref"]
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_ref"]
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_init"]
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_end"]
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_clear"]
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_open"]
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_close"]
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_add_value"]
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_add"]
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_add_parsed"]
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new"]
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get"]
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_va"]
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_va"]
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_check_format_string"]
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_parse"]
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_parsed"]
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_parsed_va"]
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_parse_error_print_context"]
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_compare"]
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).asv as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(asv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).partial_magic
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).y as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantDict>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_new"]
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_init"]
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_lookup"]
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_lookup_value"]
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_contains"]
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_insert"]
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_insert_value"]
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_remove"]
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_clear"]
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_end"]
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_ref"]
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_unref"]
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    #[link_name = "\u{1}_g_printf_string_upper_bound"]
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GLogLevelFlags {
    G_LOG_FLAG_RECURSION = 1,
    G_LOG_FLAG_FATAL = 2,
    G_LOG_LEVEL_ERROR = 4,
    G_LOG_LEVEL_CRITICAL = 8,
    G_LOG_LEVEL_WARNING = 16,
    G_LOG_LEVEL_MESSAGE = 32,
    G_LOG_LEVEL_INFO = 64,
    G_LOG_LEVEL_DEBUG = 128,
    G_LOG_LEVEL_MASK = -4,
}
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    #[link_name = "\u{1}_g_log_set_handler"]
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_handler_full"]
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_log_remove_handler"]
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_log_default_handler"]
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_default_handler"]
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    #[link_name = "\u{1}_g_log"]
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_logv"]
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_fatal_mask"]
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_always_fatal"]
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
#[repr(u32)]
#[doc = " GLogWriterOutput:"]
#[doc = " @G_LOG_WRITER_HANDLED: Log writer has handled the log entry."]
#[doc = " @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry."]
#[doc = ""]
#[doc = " Return values from #GLogWriterFuncs to indicate whether the given log entry"]
#[doc = " was successfully handled by the writer, or whether there was an error in"]
#[doc = " handling it (and hence a fallback writer should be used)."]
#[doc = ""]
#[doc = " If a #GLogWriterFunc ignores a log entry, it should return"]
#[doc = " %G_LOG_WRITER_HANDLED."]
#[doc = ""]
#[doc = " Since: 2.50"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GLogWriterOutput {
    G_LOG_WRITER_HANDLED = 1,
    G_LOG_WRITER_UNHANDLED = 0,
}
#[doc = " GLogField:"]
#[doc = " @key: field name (UTF-8 string)"]
#[doc = " @value: field value (arbitrary bytes)"]
#[doc = " @length: length of @value, in bytes, or -1 if it is nul-terminated"]
#[doc = ""]
#[doc = " Structure representing a single field in a structured log entry. See"]
#[doc = " g_log_structured() for details."]
#[doc = ""]
#[doc = " Log fields may contain arbitrary values, including binary with embedded nul"]
#[doc = " bytes. If the field contains a string, the string must be UTF-8 encoded and"]
#[doc = " have a trailing nul byte. Otherwise, @length must be set to a non-negative"]
#[doc = " value."]
#[doc = ""]
#[doc = " Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[test]
fn bindgen_test_layout__GLogField() {
    assert_eq!(
        ::std::mem::size_of::<_GLogField>(),
        24usize,
        concat!("Size of: ", stringify!(_GLogField))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLogField>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLogField))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLogField>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLogField>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLogField>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " GLogWriterFunc:"]
#[doc = " @log_level: log level of the message"]
#[doc = " @fields: (array length=n_fields): fields forming the message"]
#[doc = " @n_fields: number of @fields"]
#[doc = " @user_data: user data passed to g_log_set_writer_func()"]
#[doc = ""]
#[doc = " Writer function for log entries. A log entry is a collection of one or more"]
#[doc = " #GLogFields, using the standard [field names from journal"]
#[doc = " specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html)."]
#[doc = " See g_log_structured() for more information."]
#[doc = ""]
#[doc = " Writer functions must ignore fields which they do not recognise, unless they"]
#[doc = " can write arbitrary binary output, as field values may be arbitrary binary."]
#[doc = ""]
#[doc = " @log_level is guaranteed to be included in @fields as the `PRIORITY` field,"]
#[doc = " but is provided separately for convenience of deciding whether or where to"]
#[doc = " output the log entry."]
#[doc = ""]
#[doc = " Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log"]
#[doc = " message successfully or if they deliberately ignored it. If there was an"]
#[doc = " error handling the message (for example, if the writer function is meant to"]
#[doc = " send messages to a remote logging server and there is a network error), it"]
#[doc = " should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be"]
#[doc = " chained and fall back to simpler handlers in case of failure."]
#[doc = ""]
#[doc = " Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;"]
#[doc = "    %G_LOG_WRITER_UNHANDLED otherwise"]
#[doc = " Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
extern "C" {
    #[link_name = "\u{1}_g_log_structured"]
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_log_structured_array"]
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_variant"]
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_writer_func"]
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_supports_color"]
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_is_journald"]
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_format_fields"]
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_journald"]
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_standard_streams"]
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_default"]
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    #[link_name = "\u{1}__g_log_fallback_handler"]
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_return_if_fail_warning"]
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_warn_message"]
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assert_warning"]
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_structured_standard"]
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:"]
#[doc = " @string: the message to output"]
#[doc = ""]
#[doc = " Specifies the type of the print handler functions."]
#[doc = " These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    #[link_name = "\u{1}_g_print"]
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_set_print_handler"]
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    #[link_name = "\u{1}_g_printerr"]
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_set_printerr_handler"]
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:"]
#[doc = ""]
#[doc = " A `GOptionContext` struct defines which options"]
#[doc = " are accepted by the commandline option parser. The struct has only private"]
#[doc = " fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:"]
#[doc = ""]
#[doc = " A `GOptionGroup` struct defines the options in a single"]
#[doc = " group. The struct has only private fields and should not be directly accessed."]
#[doc = ""]
#[doc = " All options in a group share the same translation function. Libraries which"]
#[doc = " need to parse commandline options are expected to provide a function for"]
#[doc = " getting a `GOptionGroup` holding their options, which"]
#[doc = " the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
pub type GOptionEntry = _GOptionEntry;
#[repr(u32)]
#[doc = " GOptionFlags:"]
#[doc = " @G_OPTION_FLAG_NONE: No flags. Since: 2.42."]
#[doc = " @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output."]
#[doc = " @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the"]
#[doc = "     `--help` output, even if it is defined in a group."]
#[doc = " @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this"]
#[doc = "     flag indicates that the sense of the option is reversed."]
#[doc = " @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,"]
#[doc = "     this flag indicates that the callback does not take any argument"]
#[doc = "     (like a %G_OPTION_ARG_NONE option). Since 2.8"]
#[doc = " @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK"]
#[doc = "     kind, this flag indicates that the argument should be passed to the"]
#[doc = "     callback in the GLib filename encoding rather than UTF-8. Since 2.8"]
#[doc = " @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK"]
#[doc = "     kind, this flag indicates that the argument supply is optional."]
#[doc = "     If no argument is given then data of %GOptionParseFunc will be"]
#[doc = "     set to NULL. Since 2.8"]
#[doc = " @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict"]
#[doc = "     resolution which prefixes long option names with `groupname-` if"]
#[doc = "     there is a conflict. This option should only be used in situations"]
#[doc = "     where aliasing is necessary to model some legacy commandline interface."]
#[doc = "     It is not safe to use this option, unless all option groups are under"]
#[doc = "     your direct control. Since 2.8."]
#[doc = ""]
#[doc = " Flags which modify individual options."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GOptionFlags {
    G_OPTION_FLAG_NONE = 0,
    G_OPTION_FLAG_HIDDEN = 1,
    G_OPTION_FLAG_IN_MAIN = 2,
    G_OPTION_FLAG_REVERSE = 4,
    G_OPTION_FLAG_NO_ARG = 8,
    G_OPTION_FLAG_FILENAME = 16,
    G_OPTION_FLAG_OPTIONAL_ARG = 32,
    G_OPTION_FLAG_NOALIAS = 64,
}
#[repr(u32)]
#[doc = " GOptionArg:"]
#[doc = " @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags."]
#[doc = " @G_OPTION_ARG_STRING: The option takes a string argument."]
#[doc = " @G_OPTION_ARG_INT: The option takes an integer argument."]
#[doc = " @G_OPTION_ARG_CALLBACK: The option provides a callback (of type"]
#[doc = "     #GOptionArgFunc) to parse the extra argument."]
#[doc = " @G_OPTION_ARG_FILENAME: The option takes a filename as argument."]
#[doc = " @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple"]
#[doc = "     uses of the option are collected into an array of strings."]
#[doc = " @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,"]
#[doc = "     multiple uses of the option are collected into an array of strings."]
#[doc = " @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument"]
#[doc = "     can be formatted either for the user's locale or for the \"C\" locale."]
#[doc = "     Since 2.12"]
#[doc = " @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like"]
#[doc = "     %G_OPTION_ARG_INT but for larger numbers. The number can be in"]
#[doc = "     decimal base, or in hexadecimal (when prefixed with `0x`, for"]
#[doc = "     example, `0xffffffff`). Since 2.12"]
#[doc = ""]
#[doc = " The #GOptionArg enum values determine which type of extra argument the"]
#[doc = " options expect to find. If an option expects an extra argument, it can"]
#[doc = " be specified in several ways; with a short option: `-x arg`, with a long"]
#[doc = " option: `--name arg` or combined in a single argument: `--name=arg`."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GOptionArg {
    G_OPTION_ARG_NONE = 0,
    G_OPTION_ARG_STRING = 1,
    G_OPTION_ARG_INT = 2,
    G_OPTION_ARG_CALLBACK = 3,
    G_OPTION_ARG_FILENAME = 4,
    G_OPTION_ARG_STRING_ARRAY = 5,
    G_OPTION_ARG_FILENAME_ARRAY = 6,
    G_OPTION_ARG_DOUBLE = 7,
    G_OPTION_ARG_INT64 = 8,
}
#[doc = " GOptionArgFunc:"]
#[doc = " @option_name: The name of the option being parsed. This will be either a"]
#[doc = "  single dash followed by a single letter (for a short name) or two dashes"]
#[doc = "  followed by a long option name."]
#[doc = " @value: The value to be parsed."]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED"]
#[doc = "  is intended to be used for errors in #GOptionArgFunc callbacks."]
#[doc = ""]
#[doc = " The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK"]
#[doc = " options."]
#[doc = ""]
#[doc = " Returns: %TRUE if the option was successfully parsed, %FALSE if an error"]
#[doc = "  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:"]
#[doc = " @context: The active #GOptionContext"]
#[doc = " @group: The group to which the function belongs"]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: A return location for error details"]
#[doc = ""]
#[doc = " The type of function that can be called before and after parsing."]
#[doc = ""]
#[doc = " Returns: %TRUE if the function completed successfully, %FALSE if an error"]
#[doc = "  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:"]
#[doc = " @context: The active #GOptionContext"]
#[doc = " @group: The group to which the function belongs"]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: The #GError containing details about the parse error"]
#[doc = ""]
#[doc = " The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
#[repr(u32)]
#[doc = " GOptionError:"]
#[doc = " @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser."]
#[doc = "  This error will only be reported, if the parser hasn't been instructed"]
#[doc = "  to ignore unknown options, see g_option_context_set_ignore_unknown_options()."]
#[doc = " @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed."]
#[doc = " @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed."]
#[doc = ""]
#[doc = " Error codes returned by option parsing."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GOptionError {
    G_OPTION_ERROR_UNKNOWN_OPTION = 0,
    G_OPTION_ERROR_BAD_VALUE = 1,
    G_OPTION_ERROR_FAILED = 2,
}
extern "C" {
    #[link_name = "\u{1}_g_option_error_quark"]
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:"]
#[doc = " @long_name: The long name of an option can be used to specify it"]
#[doc = "     in a commandline as `--long_name`. Every option must have a"]
#[doc = "     long name. To resolve conflicts if multiple option groups contain"]
#[doc = "     the same long name, it is also possible to specify the option as"]
#[doc = "     `--groupname-long_name`."]
#[doc = " @short_name: If an option has a short name, it can be specified"]
#[doc = "     `-short_name` in a commandline. @short_name must be  a printable"]
#[doc = "     ASCII character different from '-', or zero if the option has no"]
#[doc = "     short name."]
#[doc = " @flags: Flags from #GOptionFlags"]
#[doc = " @arg: The type of the option, as a #GOptionArg"]
#[doc = " @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data"]
#[doc = "     must point to a #GOptionArgFunc callback function, which will be"]
#[doc = "     called to handle the extra argument. Otherwise, @arg_data is a"]
#[doc = "     pointer to a location to store the value, the required type of"]
#[doc = "     the location depends on the @arg type:"]
#[doc = "     - %G_OPTION_ARG_NONE: %gboolean"]
#[doc = "     - %G_OPTION_ARG_STRING: %gchar*"]
#[doc = "     - %G_OPTION_ARG_INT: %gint"]
#[doc = "     - %G_OPTION_ARG_FILENAME: %gchar*"]
#[doc = "     - %G_OPTION_ARG_STRING_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_DOUBLE: %gdouble"]
#[doc = "     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,"]
#[doc = "     the location will contain a newly allocated string if the option"]
#[doc = "     was given. That string needs to be freed by the callee using g_free()."]
#[doc = "     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or"]
#[doc = "     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev()."]
#[doc = " @description: the description for the option in `--help`"]
#[doc = "     output. The @description is translated using the @translate_func"]
#[doc = "     of the group, see g_option_group_set_translation_domain()."]
#[doc = " @arg_description: The placeholder to use for the extra argument parsed"]
#[doc = "     by the option in `--help` output. The @arg_description is translated"]
#[doc = "     using the @translate_func of the group, see"]
#[doc = "     g_option_group_set_translation_domain()."]
#[doc = ""]
#[doc = " A GOptionEntry struct defines a single option. To have an effect, they"]
#[doc = " must be added to a #GOptionGroup with g_option_context_add_main_entries()"]
#[doc = " or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    assert_eq!(
        ::std::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).long_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).short_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg_description as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_description)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_new"]
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_summary"]
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_summary"]
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_description"]
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_description"]
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_free"]
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_help_enabled"]
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_help_enabled"]
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_ignore_unknown_options"]
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_ignore_unknown_options"]
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_strict_posix"]
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_strict_posix"]
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_add_main_entries"]
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_parse"]
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_parse_strv"]
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_translate_func"]
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_translation_domain"]
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_add_group"]
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_main_group"]
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_main_group"]
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_help"]
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_new"]
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_set_parse_hooks"]
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_set_error_hook"]
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_free"]
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_ref"]
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_unref"]
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_add_entries"]
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_set_translate_func"]
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_set_translation_domain"]
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    #[link_name = "\u{1}_g_pattern_spec_new"]
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_spec_free"]
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_spec_equal"]
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_match"]
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_match_string"]
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_match_simple"]
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spaced_primes_closest"]
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_qsort_with_data"]
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
pub type GQueue = _GQueue;
#[doc = " GQueue:"]
#[doc = " @head: a pointer to the first element of the queue"]
#[doc = " @tail: a pointer to the last element of the queue"]
#[doc = " @length: the number of elements in the queue"]
#[doc = ""]
#[doc = " Contains the public fields of a"]
#[doc = " [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    assert_eq!(
        ::std::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_queue_new"]
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_free"]
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_free_full"]
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_init"]
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_clear"]
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_is_empty"]
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_clear_full"]
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_get_length"]
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_reverse"]
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_copy"]
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_foreach"]
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_find"]
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_find_custom"]
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_sort"]
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_head"]
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_tail"]
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_nth"]
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_head"]
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_tail"]
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_nth"]
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_head"]
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_tail"]
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_nth"]
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_index"]
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_remove"]
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_remove_all"]
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_insert_before"]
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_insert_after"]
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_insert_sorted"]
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_head_link"]
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_tail_link"]
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_nth_link"]
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_head_link"]
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_tail_link"]
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_nth_link"]
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_head_link"]
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_tail_link"]
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_nth_link"]
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_link_index"]
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_unlink"]
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_delete_link"]
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    #[link_name = "\u{1}_g_rand_new_with_seed"]
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_new_with_seed_array"]
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_new"]
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_free"]
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    #[link_name = "\u{1}_g_rand_copy"]
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_set_seed"]
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_rand_set_seed_array"]
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_rand_int"]
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_int_range"]
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_double"]
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_double_range"]
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_random_set_seed"]
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_random_int"]
    pub fn g_random_int() -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_random_int_range"]
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_random_double"]
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_random_double_range"]
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_rc_box_alloc"]
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_rc_box_alloc0"]
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_rc_box_dup"]
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_rc_box_acquire"]
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_rc_box_release"]
    pub fn g_rc_box_release(mem_block: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_rc_box_release_full"]
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_rc_box_get_size"]
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_rc_box_alloc"]
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_rc_box_alloc0"]
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_rc_box_dup"]
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_rc_box_acquire"]
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_rc_box_release"]
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_rc_box_release_full"]
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_rc_box_get_size"]
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_ref_count_init"]
    pub fn g_ref_count_init(rc: *mut grefcount);
}
extern "C" {
    #[link_name = "\u{1}_g_ref_count_inc"]
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
extern "C" {
    #[link_name = "\u{1}_g_ref_count_dec"]
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ref_count_compare"]
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_ref_count_init"]
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_ref_count_inc"]
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_ref_count_dec"]
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_ref_count_compare"]
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ref_string_new"]
    pub fn g_ref_string_new(str: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_ref_string_new_len"]
    pub fn g_ref_string_new_len(
        str: *const ::std::os::raw::c_char,
        len: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_ref_string_new_intern"]
    pub fn g_ref_string_new_intern(
        str: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_ref_string_acquire"]
    pub fn g_ref_string_acquire(str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_ref_string_release"]
    pub fn g_ref_string_release(str: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_ref_string_length"]
    pub fn g_ref_string_length(str: *mut ::std::os::raw::c_char) -> gsize;
}
#[doc = " GRefString:"]
#[doc = ""]
#[doc = " A typedef for a reference-counted string. A pointer to a #GRefString can be"]
#[doc = " treated like a standard `char*` array by all code, but can additionally have"]
#[doc = " `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be"]
#[doc = " called on `char*` arrays not allocated using g_ref_string_new()."]
#[doc = ""]
#[doc = " If using #GRefString with autocleanups, g_autoptr() must be used rather than"]
#[doc = " g_autofree(), so that the reference counting metadata is also freed."]
#[doc = ""]
#[doc = " Since: 2.58"]
pub type GRefString = ::std::os::raw::c_char;
#[repr(u32)]
#[doc = " GRegexError:"]
#[doc = " @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed."]
#[doc = " @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed."]
#[doc = " @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement"]
#[doc = "     string."]
#[doc = " @G_REGEX_ERROR_MATCH: The match process failed."]
#[doc = " @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\""]
#[doc = "     quantifier. Since 2.16"]
#[doc = " @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for"]
#[doc = "     character class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence"]
#[doc = "     in character class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\","]
#[doc = "     \"(?<\" or \"(?P\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are"]
#[doc = "     supported only within a class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\""]
#[doc = "     without opening \"(\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent"]
#[doc = "     subpattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16"]
#[doc = " @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not"]
#[doc = "     fixed length. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains"]
#[doc = "     more than two branches. Since 2.16"]
#[doc = " @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating"]
#[doc = "     elements are not supported. Since 2.16"]
#[doc = " @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence"]
#[doc = "     is too large. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in"]
#[doc = "     lookbehind assertion. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator"]
#[doc = "     in subpattern name. Since 2.16"]
#[doc = " @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have"]
#[doc = "     the same name. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or"]
#[doc = "     \"\\\\p\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long"]
#[doc = "     (maximum 32 characters). Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum"]
#[doc = "     10,000). Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more"]
#[doc = "     than one branch. Since 2.16"]
#[doc = " @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed."]
#[doc = "     This error is never raised. Since: 2.16 Deprecated: 2.34"]
#[doc = " @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,"]
#[doc = "      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing"]
#[doc = "     control verb used does not allow an argument. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing"]
#[doc = "     control verb. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34"]
#[doc = " @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,"]
#[doc = "     \"[\" is an invalid data character. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the"]
#[doc = "     same number are not allowed. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control"]
#[doc = "     verb requires an argument. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII"]
#[doc = "     character. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or"]
#[doc = "     quoted name. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\","]
#[doc = "     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34"]
#[doc = " @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is"]
#[doc = "     too large. Since: 2.34"]
#[doc = ""]
#[doc = " Error codes returned by regular expressions functions."]
#[doc = ""]
#[doc = " Since: 2.14"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GRegexError {
    G_REGEX_ERROR_COMPILE = 0,
    G_REGEX_ERROR_OPTIMIZE = 1,
    G_REGEX_ERROR_REPLACE = 2,
    G_REGEX_ERROR_MATCH = 3,
    G_REGEX_ERROR_INTERNAL = 4,
    G_REGEX_ERROR_STRAY_BACKSLASH = 101,
    G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
    G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
    G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
    G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
    G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
    G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
    G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
    G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
    G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
    G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
    G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
    G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
    G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
    G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
    G_REGEX_ERROR_MEMORY_ERROR = 121,
    G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
    G_REGEX_ERROR_MALFORMED_CONDITION = 126,
    G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
    G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
    G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
    G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
    G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
    G_REGEX_ERROR_INVALID_CONDITION = 135,
    G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
    G_REGEX_ERROR_INFINITE_LOOP = 140,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
    G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
    G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
    G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
    G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
    G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
    G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
    G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
    G_REGEX_ERROR_DEFINE_REPETION = 155,
    G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
    G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
    G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
    G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
    G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
    G_REGEX_ERROR_MISSING_DIGIT = 163,
    G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
    G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
    G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
    G_REGEX_ERROR_MISSING_NAME = 169,
    G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
    G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
    G_REGEX_ERROR_NAME_TOO_LONG = 175,
    G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176,
}
extern "C" {
    #[link_name = "\u{1}_g_regex_error_quark"]
    pub fn g_regex_error_quark() -> GQuark;
}
#[repr(u32)]
#[doc = " GRegexCompileFlags:"]
#[doc = " @G_REGEX_CASELESS: Letters in the pattern match both upper- and"]
#[doc = "     lowercase letters. This option can be changed within a pattern"]
#[doc = "     by a \"(?i)\" option setting."]
#[doc = " @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting"]
#[doc = "     of a single line of characters (even if it actually contains"]
#[doc = "     newlines). The \"start of line\" metacharacter (\"^\") matches only"]
#[doc = "     at the start of the string, while the \"end of line\" metacharacter"]
#[doc = "     (\"$\") matches only at the end of the string, or before a terminating"]
#[doc = "     newline (unless #G_REGEX_DOLLAR_ENDONLY is set). When"]
#[doc = "     #G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\""]
#[doc = "     constructs match immediately following or immediately before any"]
#[doc = "     newline in the string, respectively, as well as at the very start"]
#[doc = "     and end. This can be changed within a pattern by a \"(?m)\" option"]
#[doc = "     setting."]
#[doc = " @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all"]
#[doc = "     characters, including newlines. Without it, newlines are excluded."]
#[doc = "     This option can be changed within a pattern by a (\"?s\") option setting."]
#[doc = " @G_REGEX_EXTENDED: Whitespace data characters in the pattern are"]
#[doc = "     totally ignored except when escaped or inside a character class."]
#[doc = "     Whitespace does not include the VT character (code 11). In addition,"]
#[doc = "     characters between an unescaped \"#\" outside a character class and"]
#[doc = "     the next newline character, inclusive, are also ignored. This can"]
#[doc = "     be changed within a pattern by a \"(?x)\" option setting."]
#[doc = " @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,"]
#[doc = "     it is constrained to match only at the first matching point in the"]
#[doc = "     string that is being searched. This effect can also be achieved by"]
#[doc = "     appropriate constructs in the pattern itself such as the \"^\""]
#[doc = "     metacharacter."]
#[doc = " @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern"]
#[doc = "     matches only at the end of the string. Without this option, a"]
#[doc = "     dollar also matches immediately before the final character if"]
#[doc = "     it is a newline (but not before any other newlines). This option"]
#[doc = "     is ignored if #G_REGEX_MULTILINE is set."]
#[doc = " @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that"]
#[doc = "     they are not greedy by default, but become greedy if followed by \"?\"."]
#[doc = "     It can also be set by a \"(?U)\" option setting within the pattern."]
#[doc = " @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this"]
#[doc = "     flag they are considered as a raw sequence of bytes."]
#[doc = " @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing"]
#[doc = "     parentheses in the pattern. Any opening parenthesis that is not"]
#[doc = "     followed by \"?\" behaves as if it were followed by \"?:\" but named"]
#[doc = "     parentheses can still be used for capturing (and they acquire numbers"]
#[doc = "     in the usual way)."]
#[doc = " @G_REGEX_OPTIMIZE: Optimize the regular expression. If the pattern will"]
#[doc = "     be used many times, then it may be worth the effort to optimize it"]
#[doc = "     to improve the speed of matches."]
#[doc = " @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the"]
#[doc = "     first newline. Since: 2.34"]
#[doc = " @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not"]
#[doc = "     be unique. This can be helpful for certain types of pattern when it"]
#[doc = "     is known that only one instance of the named subpattern can ever be"]
#[doc = "     matched."]
#[doc = " @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     is '\\r'."]
#[doc = " @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     is '\\n'."]
#[doc = " @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     sequence is '\\r\\n'."]
#[doc = " @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence"]
#[doc = "     is recognized. If this option is set, the only recognized newline character"]
#[doc = "     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34"]
#[doc = " @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence"]
#[doc = "     is recognised. If this option is set, then \"\\R\" only recognizes the newline"]
#[doc = "    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34"]
#[doc = " @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with"]
#[doc = "     JavaScript rather than PCRE. Since: 2.34"]
#[doc = ""]
#[doc = " Flags specifying compile-time options."]
#[doc = ""]
#[doc = " Since: 2.14"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GRegexCompileFlags {
    G_REGEX_CASELESS = 1,
    G_REGEX_MULTILINE = 2,
    G_REGEX_DOTALL = 4,
    G_REGEX_EXTENDED = 8,
    G_REGEX_ANCHORED = 16,
    G_REGEX_DOLLAR_ENDONLY = 32,
    G_REGEX_UNGREEDY = 512,
    G_REGEX_RAW = 2048,
    G_REGEX_NO_AUTO_CAPTURE = 4096,
    G_REGEX_OPTIMIZE = 8192,
    G_REGEX_FIRSTLINE = 262144,
    G_REGEX_DUPNAMES = 524288,
    G_REGEX_NEWLINE_CR = 1048576,
    G_REGEX_NEWLINE_LF = 2097152,
    G_REGEX_NEWLINE_CRLF = 3145728,
    G_REGEX_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_BSR_ANYCRLF = 8388608,
    G_REGEX_JAVASCRIPT_COMPAT = 33554432,
}
impl GRegexMatchFlags {
    pub const G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags =
        GRegexMatchFlags::G_REGEX_MATCH_PARTIAL;
}
#[repr(u32)]
#[doc = " GRegexMatchFlags:"]
#[doc = " @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,"]
#[doc = "     it is constrained to match only at the first matching point in the"]
#[doc = "     string that is being searched. This effect can also be achieved by"]
#[doc = "     appropriate constructs in the pattern itself such as the \"^\""]
#[doc = "     metacharacter."]
#[doc = " @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is"]
#[doc = "     not the beginning of a line, so the circumflex metacharacter should"]
#[doc = "     not match before it. Setting this without #G_REGEX_MULTILINE (at"]
#[doc = "     compile time) causes circumflex never to match. This option affects"]
#[doc = "     only the behaviour of the circumflex metacharacter, it does not"]
#[doc = "     affect \"\\A\"."]
#[doc = " @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is"]
#[doc = "     not the end of a line, so the dollar metacharacter should not match"]
#[doc = "     it nor (except in multiline mode) a newline immediately before it."]
#[doc = "     Setting this without #G_REGEX_MULTILINE (at compile time) causes"]
#[doc = "     dollar never to match. This option affects only the behaviour of"]
#[doc = "     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\"."]
#[doc = " @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid"]
#[doc = "     match if this option is set. If there are alternatives in the pattern,"]
#[doc = "     they are tried. If all the alternatives match the empty string, the"]
#[doc = "     entire match fails. For example, if the pattern \"a?b?\" is applied to"]
#[doc = "     a string not beginning with \"a\" or \"b\", it matches the empty string"]
#[doc = "     at the start of the string. With this flag set, this match is not"]
#[doc = "     valid, so GRegex searches further into the string for occurrences"]
#[doc = "     of \"a\" or \"b\"."]
#[doc = " @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more"]
#[doc = "     documentation on partial matching see g_match_info_is_partial_match()."]
#[doc = " @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\r' character as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\n' character as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, any Unicode newline sequence"]
#[doc = "     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the"]
#[doc = "     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),"]
#[doc = "     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and"]
#[doc = "     U+2029 PARAGRAPH SEPARATOR."]
#[doc = " @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence"]
#[doc = "     is recognized as a newline. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when"]
#[doc = "     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences"]
#[doc = "     are recognized as a newline by \"\\R\". Since: 2.34"]
#[doc = " @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when"]
#[doc = "     creating a new #GRegex; any Unicode newline character or character sequence"]
#[doc = "     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the"]
#[doc = "     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),"]
#[doc = "     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and"]
#[doc = "     U+2029 PARAGRAPH SEPARATOR. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_PARTIAL_SOFT: An alias for #G_REGEX_MATCH_PARTIAL. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to"]
#[doc = "     to #G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match"]
#[doc = "     is found, without continuing to search for a possible complete match. See"]
#[doc = "     g_match_info_is_partial_match() for more information. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like #G_REGEX_MATCH_NOTEMPTY, but only applied to"]
#[doc = "     the start of the matched string. For anchored"]
#[doc = "     patterns this can only happen for pattern containing \"\\K\". Since: 2.34"]
#[doc = ""]
#[doc = " Flags specifying match-time options."]
#[doc = ""]
#[doc = " Since: 2.14"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GRegexMatchFlags {
    G_REGEX_MATCH_ANCHORED = 16,
    G_REGEX_MATCH_NOTBOL = 128,
    G_REGEX_MATCH_NOTEOL = 256,
    G_REGEX_MATCH_NOTEMPTY = 1024,
    G_REGEX_MATCH_PARTIAL = 32768,
    G_REGEX_MATCH_NEWLINE_CR = 1048576,
    G_REGEX_MATCH_NEWLINE_LF = 2097152,
    G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
    G_REGEX_MATCH_NEWLINE_ANY = 4194304,
    G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_MATCH_BSR_ANYCRLF = 8388608,
    G_REGEX_MATCH_BSR_ANY = 16777216,
    G_REGEX_MATCH_PARTIAL_HARD = 134217728,
    G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:"]
#[doc = ""]
#[doc = " A GRegex is the \"compiled\" form of a regular expression pattern."]
#[doc = " This structure is opaque and its fields cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:"]
#[doc = ""]
#[doc = " A GMatchInfo is an opaque struct used to return information about"]
#[doc = " matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:"]
#[doc = " @match_info: the #GMatchInfo generated by the match."]
#[doc = "     Use g_match_info_get_regex() and g_match_info_get_string() if you"]
#[doc = "     need the #GRegex or the matched string."]
#[doc = " @result: a #GString containing the new string"]
#[doc = " @user_data: user data passed to g_regex_replace_eval()"]
#[doc = ""]
#[doc = " Specifies the type of the function passed to g_regex_replace_eval()."]
#[doc = " It is called for each occurrence of the pattern in the string passed"]
#[doc = " to g_regex_replace_eval(), and it should append the replacement to"]
#[doc = " @result."]
#[doc = ""]
#[doc = " Returns: %FALSE to continue the replacement process, %TRUE to stop it"]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    #[link_name = "\u{1}_g_regex_new"]
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_ref"]
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_unref"]
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_pattern"]
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_max_backref"]
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_capture_count"]
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_has_cr_or_lf"]
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_max_lookbehind"]
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_string_number"]
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_escape_string"]
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_escape_nul"]
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_compile_flags"]
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_match_flags"]
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match_simple"]
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match"]
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match_full"]
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match_all"]
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match_all_full"]
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_split_simple"]
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_split"]
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_split_full"]
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_replace"]
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_replace_literal"]
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_replace_eval"]
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_check_replacement"]
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_get_regex"]
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_get_string"]
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_ref"]
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_unref"]
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_free"]
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_next"]
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_matches"]
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_get_match_count"]
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_is_partial_match"]
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_expand_references"]
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch"]
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch_pos"]
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch_named"]
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch_named_pos"]
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch_all"]
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GErrorType {
    G_ERR_UNKNOWN = 0,
    G_ERR_UNEXP_EOF = 1,
    G_ERR_UNEXP_EOF_IN_STRING = 2,
    G_ERR_UNEXP_EOF_IN_COMMENT = 3,
    G_ERR_NON_DIGIT_IN_CONST = 4,
    G_ERR_DIGIT_RADIX = 5,
    G_ERR_FLOAT_RADIX = 6,
    G_ERR_FLOAT_MALFORMED = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTokenType {
    G_TOKEN_EOF = 0,
    G_TOKEN_LEFT_PAREN = 40,
    G_TOKEN_RIGHT_PAREN = 41,
    G_TOKEN_LEFT_CURLY = 123,
    G_TOKEN_RIGHT_CURLY = 125,
    G_TOKEN_LEFT_BRACE = 91,
    G_TOKEN_RIGHT_BRACE = 93,
    G_TOKEN_EQUAL_SIGN = 61,
    G_TOKEN_COMMA = 44,
    G_TOKEN_NONE = 256,
    G_TOKEN_ERROR = 257,
    G_TOKEN_CHAR = 258,
    G_TOKEN_BINARY = 259,
    G_TOKEN_OCTAL = 260,
    G_TOKEN_INT = 261,
    G_TOKEN_HEX = 262,
    G_TOKEN_FLOAT = 263,
    G_TOKEN_STRING = 264,
    G_TOKEN_SYMBOL = 265,
    G_TOKEN_IDENTIFIER = 266,
    G_TOKEN_IDENTIFIER_NULL = 267,
    G_TOKEN_COMMENT_SINGLE = 268,
    G_TOKEN_COMMENT_MULTI = 269,
    G_TOKEN_LAST = 270,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    assert_eq!(
        ::std::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_symbol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_identifier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_binary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_binary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_octal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_octal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_hex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_hex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_comment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_char as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    assert_eq!(
        ::std::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GScannerConfig>())).cset_skip_characters as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_skip_characters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GScannerConfig>())).cset_identifier_first as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GScannerConfig>())).cset_identifier_nth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_nth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GScannerConfig>())).cpair_comment_single as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cpair_comment_single)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScannerConfig>())).padding_dummy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(padding_dummy)
        )
    );
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    assert_eq!(
        ::std::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).user_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).max_parse_errors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(max_parse_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).parse_errors as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).input_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).qdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).config as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).token as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).value as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).line as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).position as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_token as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_line as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_position as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).symbol_table as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(symbol_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).input_fd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).text as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).text_end as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).buffer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).scope_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).msg_handler as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(msg_handler)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_new"]
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_destroy"]
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_input_file"]
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_sync_file_offset"]
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_input_text"]
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_get_next_token"]
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_peek_next_token"]
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_cur_token"]
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_cur_value"]
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_cur_line"]
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_cur_position"]
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_eof"]
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_set_scope"]
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_scope_add_symbol"]
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_scope_remove_symbol"]
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_scope_lookup_symbol"]
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_scope_foreach_symbol"]
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_lookup_symbol"]
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_unexp_token"]
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_error"]
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_warn"]
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
extern "C" {
    #[link_name = "\u{1}_g_sequence_new"]
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_free"]
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get_length"]
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_foreach"]
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_foreach_range"]
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_sort"]
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_sort_iter"]
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_is_empty"]
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get_begin_iter"]
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get_end_iter"]
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get_iter_at_pos"]
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_append"]
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_prepend"]
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_insert_before"]
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_move"]
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_swap"]
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_insert_sorted"]
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_insert_sorted_iter"]
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_sort_changed"]
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_sort_changed_iter"]
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_remove"]
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_remove_range"]
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_move_range"]
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_search"]
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_search_iter"]
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_lookup"]
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_lookup_iter"]
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get"]
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_set"]
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_is_begin"]
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_is_end"]
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_next"]
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_prev"]
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_get_position"]
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_move"]
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_get_sequence"]
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_compare"]
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_range_get_midpoint"]
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GShellError {
    G_SHELL_ERROR_BAD_QUOTING = 0,
    G_SHELL_ERROR_EMPTY_STRING = 1,
    G_SHELL_ERROR_FAILED = 2,
}
extern "C" {
    #[link_name = "\u{1}_g_shell_error_quark"]
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_shell_quote"]
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_shell_unquote"]
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_shell_parse_argv"]
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_alloc"]
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_alloc0"]
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_copy"]
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_free1"]
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_slice_free_chain_with_offset"]
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GSliceConfig {
    G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
    G_SLICE_CONFIG_BYPASS_MAGAZINES = 2,
    G_SLICE_CONFIG_WORKING_SET_MSECS = 3,
    G_SLICE_CONFIG_COLOR_INCREMENT = 4,
    G_SLICE_CONFIG_CHUNK_SIZES = 5,
    G_SLICE_CONFIG_CONTENTION_COUNTER = 6,
}
extern "C" {
    #[link_name = "\u{1}_g_slice_set_config"]
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    #[link_name = "\u{1}_g_slice_get_config"]
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_get_config_state"]
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
impl GSpawnError {
    pub const G_SPAWN_ERROR_2BIG: GSpawnError = GSpawnError::G_SPAWN_ERROR_TOO_BIG;
}
#[repr(u32)]
#[doc = " GSpawnError:"]
#[doc = " @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory."]
#[doc = " @G_SPAWN_ERROR_READ: Read or select on pipes failed."]
#[doc = " @G_SPAWN_ERROR_CHDIR: Changing to working directory failed."]
#[doc = " @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`"]
#[doc = " @G_SPAWN_ERROR_PERM: execv() returned `EPERM`"]
#[doc = " @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`"]
#[doc = " @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG"]
#[doc = " @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`"]
#[doc = " @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`"]
#[doc = " @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`"]
#[doc = " @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`"]
#[doc = " @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`"]
#[doc = " @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`"]
#[doc = " @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`"]
#[doc = " @G_SPAWN_ERROR_IO: execv() returned `EIO`"]
#[doc = " @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`"]
#[doc = " @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`"]
#[doc = " @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`"]
#[doc = " @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`"]
#[doc = " @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`"]
#[doc = " @G_SPAWN_ERROR_FAILED: Some other fatal failure,"]
#[doc = "   `error->message` should explain."]
#[doc = ""]
#[doc = " Error codes returned by spawning processes."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GSpawnError {
    G_SPAWN_ERROR_FORK = 0,
    G_SPAWN_ERROR_READ = 1,
    G_SPAWN_ERROR_CHDIR = 2,
    G_SPAWN_ERROR_ACCES = 3,
    G_SPAWN_ERROR_PERM = 4,
    G_SPAWN_ERROR_TOO_BIG = 5,
    G_SPAWN_ERROR_NOEXEC = 6,
    G_SPAWN_ERROR_NAMETOOLONG = 7,
    G_SPAWN_ERROR_NOENT = 8,
    G_SPAWN_ERROR_NOMEM = 9,
    G_SPAWN_ERROR_NOTDIR = 10,
    G_SPAWN_ERROR_LOOP = 11,
    G_SPAWN_ERROR_TXTBUSY = 12,
    G_SPAWN_ERROR_IO = 13,
    G_SPAWN_ERROR_NFILE = 14,
    G_SPAWN_ERROR_MFILE = 15,
    G_SPAWN_ERROR_INVAL = 16,
    G_SPAWN_ERROR_ISDIR = 17,
    G_SPAWN_ERROR_LIBBAD = 18,
    G_SPAWN_ERROR_FAILED = 19,
}
#[doc = " GSpawnChildSetupFunc:"]
#[doc = " @user_data: (closure): user data to pass to the function."]
#[doc = ""]
#[doc = " Specifies the type of the setup function passed to g_spawn_async(),"]
#[doc = " g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very"]
#[doc = " limited ways, be used to affect the child's execution."]
#[doc = ""]
#[doc = " On POSIX platforms, the function is called in the child after GLib"]
#[doc = " has performed all the setup it plans to perform, but before calling"]
#[doc = " exec(). Actions taken in this function will only affect the child,"]
#[doc = " not the parent."]
#[doc = ""]
#[doc = " On Windows, the function is called in the parent. Its usefulness on"]
#[doc = " Windows is thus questionable. In many cases executing the child setup"]
#[doc = " function in the parent can have ill effects, and you should be very"]
#[doc = " careful when porting software to Windows that uses child setup"]
#[doc = " functions."]
#[doc = ""]
#[doc = " However, even on POSIX, you are extremely limited in what you can"]
#[doc = " safely do from a #GSpawnChildSetupFunc, because any mutexes that were"]
#[doc = " held by other threads in the parent process at the time of the fork()"]
#[doc = " will still be locked in the child process, and they will never be"]
#[doc = " unlocked (since the threads that held them don't exist in the child)."]
#[doc = " POSIX allows only async-signal-safe functions (see signal(7)) to be"]
#[doc = " called in the child between fork() and exec(), which drastically limits"]
#[doc = " the usefulness of child setup functions."]
#[doc = ""]
#[doc = " In particular, it is not safe to call any function which may"]
#[doc = " call malloc(), which includes POSIX functions such as setenv()."]
#[doc = " If you need to set up the child environment differently from"]
#[doc = " the parent, you should use g_get_environ(), g_environ_setenv(),"]
#[doc = " and g_environ_unsetenv(), and then pass the complete environment"]
#[doc = " list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
#[repr(u32)]
#[doc = " GSpawnFlags:"]
#[doc = " @G_SPAWN_DEFAULT: no flags, default behaviour"]
#[doc = " @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will"]
#[doc = "     be inherited by the child; otherwise all descriptors except stdin,"]
#[doc = "     stdout and stderr will be closed before calling exec() in the child."]
#[doc = " @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;"]
#[doc = "     you must use g_child_watch_add() yourself (or call waitpid() or handle"]
#[doc = "     `SIGCHLD` yourself), or the child will become a zombie."]
#[doc = " @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be"]
#[doc = "     looked for in the user's `PATH`."]
#[doc = " @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,"]
#[doc = "     instead of going to the same location as the parent's standard output."]
#[doc = " @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded."]
#[doc = " @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard"]
#[doc = "     input (by default, the child's standard input is attached to `/dev/null`)."]
#[doc = " @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to"]
#[doc = "     execute, while the remaining elements are the actual argument vector"]
#[doc = "     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`"]
#[doc = "     as the file to execute, and passes all of `argv` to the child."]
#[doc = " @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an abolute path,"]
#[doc = "     it will be looked for in the `PATH` from the passed child environment."]
#[doc = "     Since: 2.34"]
#[doc = " @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set."]
#[doc = "     Since: 2.40"]
#[doc = ""]
#[doc = " Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GSpawnFlags {
    G_SPAWN_DEFAULT = 0,
    G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
    G_SPAWN_DO_NOT_REAP_CHILD = 2,
    G_SPAWN_SEARCH_PATH = 4,
    G_SPAWN_STDOUT_TO_DEV_NULL = 8,
    G_SPAWN_STDERR_TO_DEV_NULL = 16,
    G_SPAWN_CHILD_INHERITS_STDIN = 32,
    G_SPAWN_FILE_AND_ARGV_ZERO = 64,
    G_SPAWN_SEARCH_PATH_FROM_ENVP = 128,
    G_SPAWN_CLOEXEC_PIPES = 256,
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_error_quark"]
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_exit_error_quark"]
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_async"]
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_async_with_pipes"]
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_async_with_fds"]
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_sync"]
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_command_line_sync"]
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_command_line_async"]
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_check_exit_status"]
    pub fn g_spawn_check_exit_status(exit_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_close_pid"]
    pub fn g_spawn_close_pid(pid: GPid);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GAsciiType {
    G_ASCII_ALNUM = 1,
    G_ASCII_ALPHA = 2,
    G_ASCII_CNTRL = 4,
    G_ASCII_DIGIT = 8,
    G_ASCII_GRAPH = 16,
    G_ASCII_LOWER = 32,
    G_ASCII_PRINT = 64,
    G_ASCII_PUNCT = 128,
    G_ASCII_SPACE = 256,
    G_ASCII_UPPER = 512,
    G_ASCII_XDIGIT = 1024,
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_table"]
    pub static g_ascii_table: *const guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_tolower"]
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_toupper"]
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_digit_value"]
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_xdigit_value"]
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_strdelimit"]
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strcanon"]
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strerror"]
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strsignal"]
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strreverse"]
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strlcpy"]
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_strlcat"]
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_strstr_len"]
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strrstr"]
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strrstr_len"]
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_has_suffix"]
    pub fn g_str_has_suffix(str: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_str_has_prefix"]
    pub fn g_str_has_prefix(str: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_strtod"]
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strtod"]
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strtoull"]
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strtoll"]
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_dtostr"]
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_formatd"]
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strchug"]
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strchomp"]
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strcasecmp"]
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strncasecmp"]
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strdown"]
    pub fn g_ascii_strdown(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strup"]
    pub fn g_ascii_strup(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_is_ascii"]
    pub fn g_str_is_ascii(str: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_strcasecmp"]
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_strncasecmp"]
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_strdown"]
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strup"]
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strdup"]
    pub fn g_strdup(str: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strdup_printf"]
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strdup_vprintf"]
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strndup"]
    pub fn g_strndup(str: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strnfill"]
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strconcat"]
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strjoin"]
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strcompress"]
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strescape"]
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_memdup"]
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    #[link_name = "\u{1}_g_strsplit"]
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strsplit_set"]
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strjoinv"]
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strfreev"]
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_strdupv"]
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strv_length"]
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_stpcpy"]
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_to_ascii"]
    pub fn g_str_to_ascii(str: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_tokenize_and_fold"]
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_match_string"]
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_strv_contains"]
    pub fn g_strv_contains(strv: *const *const gchar, str: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_strv_equal"]
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
#[repr(u32)]
#[doc = " GNumberParserError:"]
#[doc = " @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number."]
#[doc = " @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds."]
#[doc = ""]
#[doc = " Error codes returned by functions converting a string to a number."]
#[doc = ""]
#[doc = " Since: 2.54"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GNumberParserError {
    G_NUMBER_PARSER_ERROR_INVALID = 0,
    G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1,
}
extern "C" {
    #[link_name = "\u{1}_g_number_parser_error_quark"]
    pub fn g_number_parser_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_string_to_signed"]
    pub fn g_ascii_string_to_signed(
        str: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_string_to_unsigned"]
    pub fn g_ascii_string_to_unsigned(
        str: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_new"]
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_free"]
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_clear"]
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_insert"]
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_insert_len"]
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_insert_const"]
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_memchr"]
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memcmp"]
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_memcpy"]
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memmove"]
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memset"]
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_strcat"]
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strchr"]
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strcmp"]
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strcoll"]
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strcpy"]
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strcspn"]
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strerror"]
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strlen"]
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strncat"]
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strncmp"]
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strncpy"]
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strpbrk"]
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strrchr"]
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strspn"]
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strstr"]
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strtok"]
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strxfrm"]
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strtok_r"]
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strdup"]
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_memccpy"]
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_stpcpy"]
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_stpncpy"]
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strndup"]
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strnlen"]
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_strsignal"]
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_memset_s"]
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    #[link_name = "\u{1}_memmem"]
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memset_pattern4"]
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_memset_pattern8"]
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_memset_pattern16"]
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_strcasestr"]
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strnstr"]
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strlcat"]
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strlcpy"]
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strmode"]
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_strsep"]
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_swab"]
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    #[link_name = "\u{1}_timingsafe_bcmp"]
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bcmp"]
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bcopy"]
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_bzero"]
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}_index"]
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_rindex"]
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ffs"]
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strcasecmp"]
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strncasecmp"]
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ffsl"]
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ffsll"]
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fls"]
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_flsl"]
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_flsll"]
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    #[link_name = "\u{1}_g_strcmp0"]
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_test_minimized_result"]
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_maximized_result"]
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_init"]
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_subprocess"]
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_test_run"]
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_test_add_func"]
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_test_add_data_func"]
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_add_data_func_full"]
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_fail"]
    pub fn g_test_fail();
}
extern "C" {
    #[link_name = "\u{1}_g_test_incomplete"]
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_test_skip"]
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_test_failed"]
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_test_set_nonfatal_assertions"]
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    #[link_name = "\u{1}_g_test_message"]
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_test_bug_base"]
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_test_bug"]
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_test_timer_start"]
    pub fn g_test_timer_start();
}
extern "C" {
    #[link_name = "\u{1}_g_test_timer_elapsed"]
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_g_test_timer_last"]
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_g_test_queue_free"]
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_test_queue_destroy"]
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTestTrapFlags {
    G_TEST_TRAP_SILENCE_STDOUT = 128,
    G_TEST_TRAP_SILENCE_STDERR = 256,
    G_TEST_TRAP_INHERIT_STDIN = 512,
}
extern "C" {
    #[link_name = "\u{1}_g_test_trap_fork"]
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTestSubprocessFlags {
    G_TEST_SUBPROCESS_INHERIT_STDIN = 1,
    G_TEST_SUBPROCESS_INHERIT_STDOUT = 2,
    G_TEST_SUBPROCESS_INHERIT_STDERR = 4,
}
extern "C" {
    #[link_name = "\u{1}_g_test_trap_subprocess"]
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_trap_has_passed"]
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_test_trap_reached_timeout"]
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_test_rand_int"]
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_test_rand_int_range"]
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_test_rand_double"]
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_g_test_rand_double_range"]
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_g_test_create_case"]
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    #[link_name = "\u{1}_g_test_create_suite"]
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
extern "C" {
    #[link_name = "\u{1}_g_test_get_root"]
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    #[link_name = "\u{1}_g_test_suite_add"]
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    #[link_name = "\u{1}_g_test_suite_add_suite"]
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    #[link_name = "\u{1}_g_test_run_suite"]
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_test_trap_assertions"]
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message"]
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message_expr"]
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message_cmpstr"]
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message_cmpnum"]
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: u128,
        cmp: *const ::std::os::raw::c_char,
        arg2: u128,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message_error"]
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_add_vtable"]
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    assert_eq!(
        ::std::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_quick as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_perf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_perf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_verbose as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_quiet as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quiet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_undefined as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_undefined)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_config_vars"]
    pub static g_test_config_vars: *const GTestConfig;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTestResult {
    G_TEST_RUN_SUCCESS = 0,
    G_TEST_RUN_SKIPPED = 1,
    G_TEST_RUN_FAILURE = 2,
    G_TEST_RUN_INCOMPLETE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTestLogType {
    G_TEST_LOG_NONE = 0,
    G_TEST_LOG_ERROR = 1,
    G_TEST_LOG_START_BINARY = 2,
    G_TEST_LOG_LIST_CASE = 3,
    G_TEST_LOG_SKIP_CASE = 4,
    G_TEST_LOG_START_CASE = 5,
    G_TEST_LOG_STOP_CASE = 6,
    G_TEST_LOG_MIN_RESULT = 7,
    G_TEST_LOG_MAX_RESULT = 8,
    G_TEST_LOG_MESSAGE = 9,
    G_TEST_LOG_START_SUITE = 10,
    G_TEST_LOG_STOP_SUITE = 11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut u128,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    assert_eq!(
        ::std::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).log_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).n_strings as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).strings as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).n_nums as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_nums)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).nums as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(nums)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    assert_eq!(
        ::std::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogBuffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogBuffer>())).msgs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(msgs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_type_name"]
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_buffer_new"]
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_buffer_free"]
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_buffer_push"]
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_buffer_pop"]
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_msg_free"]
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:"]
#[doc = " @log_domain: the log domain of the message"]
#[doc = " @log_level: the log level of the message (including the fatal and recursion flags)"]
#[doc = " @message: the message to process"]
#[doc = " @user_data: user data, set in g_test_log_set_fatal_handler()"]
#[doc = ""]
#[doc = " Specifies the prototype of fatal log handler functions."]
#[doc = ""]
#[doc = " Returns: %TRUE if the program should abort, %FALSE otherwise"]
#[doc = ""]
#[doc = " Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    #[link_name = "\u{1}_g_test_log_set_fatal_handler"]
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_test_expect_message"]
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_assert_expected_messages_internal"]
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTestFileType {
    G_TEST_DIST = 0,
    G_TEST_BUILT = 1,
}
extern "C" {
    #[link_name = "\u{1}_g_test_build_filename"]
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_test_get_dir"]
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_test_get_filename"]
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).user_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).exclusive as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(exclusive)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_new"]
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_free"]
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_push"]
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_unprocessed"]
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_set_sort_function"]
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_move_to_front"]
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_set_max_threads"]
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_max_threads"]
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_num_threads"]
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_set_max_unused_threads"]
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_max_unused_threads"]
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_num_unused_threads"]
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_stop_unused_threads"]
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_set_max_idle_time"]
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_max_idle_time"]
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    #[link_name = "\u{1}_g_timer_new"]
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    #[link_name = "\u{1}_g_timer_destroy"]
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_start"]
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_stop"]
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_reset"]
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_continue"]
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_elapsed"]
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_usleep"]
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_time_val_add"]
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    #[link_name = "\u{1}_g_time_val_from_iso8601"]
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_time_val_to_iso8601"]
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    assert_eq!(
        ::std::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTrashStack>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTrashStack),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_trash_stack_push"]
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_trash_stack_pop"]
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_trash_stack_peek"]
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_trash_stack_height"]
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
extern "C" {
    #[link_name = "\u{1}_g_tree_new"]
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_new_with_data"]
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_new_full"]
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_ref"]
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_unref"]
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_destroy"]
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_insert"]
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_replace"]
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_remove"]
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_steal"]
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_lookup"]
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_lookup_extended"]
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_foreach"]
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_traverse"]
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tree_search"]
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_height"]
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_nnodes"]
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_unescape_string"]
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_unescape_segment"]
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_parse_scheme"]
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_escape_string"]
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_uuid_string_is_valid"]
    pub fn g_uuid_string_is_valid(str: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_uuid_string_random"]
    pub fn g_uuid_string_random() -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_glib_major_version"]
    pub static glib_major_version: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_minor_version"]
    pub static glib_minor_version: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_micro_version"]
    pub static glib_micro_version: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_interface_age"]
    pub static glib_interface_age: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_binary_age"]
    pub static glib_binary_age: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_check_version"]
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_new"]
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_destroy"]
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_alloc"]
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_alloc0"]
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_free"]
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_clean"]
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_reset"]
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_print"]
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_info"]
    pub fn g_mem_chunk_info();
}
extern "C" {
    #[link_name = "\u{1}_g_blow_chunks"]
    pub fn g_blow_chunks();
}
extern "C" {
    #[link_name = "\u{1}_g_allocator_new"]
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    #[link_name = "\u{1}_g_allocator_free"]
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    #[link_name = "\u{1}_g_list_push_allocator"]
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    #[link_name = "\u{1}_g_list_pop_allocator"]
    pub fn g_list_pop_allocator();
}
extern "C" {
    #[link_name = "\u{1}_g_slist_push_allocator"]
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_pop_allocator"]
    pub fn g_slist_pop_allocator();
}
extern "C" {
    #[link_name = "\u{1}_g_node_push_allocator"]
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    #[link_name = "\u{1}_g_node_pop_allocator"]
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    #[link_name = "\u{1}_g_cache_new"]
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    #[link_name = "\u{1}_g_cache_destroy"]
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    #[link_name = "\u{1}_g_cache_insert"]
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_cache_remove"]
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_cache_key_foreach"]
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_cache_value_foreach"]
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    assert_eq!(
        ::std::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).prefix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).cache as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).strncmp_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(strncmp_func)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_completion_new"]
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    #[link_name = "\u{1}_g_completion_add_items"]
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_completion_remove_items"]
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_completion_clear_items"]
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    #[link_name = "\u{1}_g_completion_complete"]
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_completion_complete_utf8"]
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_completion_set_compare"]
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_completion_free"]
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    assert_eq!(
        ::std::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTuples>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTuples),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_relation_new"]
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_destroy"]
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    #[link_name = "\u{1}_g_relation_index"]
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_relation_insert"]
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_relation_delete"]
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_select"]
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_count"]
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_exists"]
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_print"]
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    #[link_name = "\u{1}_g_tuples_destroy"]
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    #[link_name = "\u{1}_g_tuples_index"]
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GThreadPriority {
    G_THREAD_PRIORITY_LOW = 0,
    G_THREAD_PRIORITY_NORMAL = 1,
    G_THREAD_PRIORITY_HIGH = 2,
    G_THREAD_PRIORITY_URGENT = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    assert_eq!(
        ::std::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).joinable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(joinable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(priority)
        )
    );
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_new as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_trylock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_trylock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_unlock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_new as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_signal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadFunctions>())).cond_broadcast as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_broadcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_wait as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_wait)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadFunctions>())).cond_timed_wait as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_timed_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_free as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_new as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_get as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_set as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_create as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_yield as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_yield)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_join as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_exit as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadFunctions>())).thread_set_priority as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_set_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_self as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_equal as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_equal)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_thread_functions_for_glib_use"]
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_use_default_impl"]
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_gettime"]
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_create"]
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_create_full"]
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_set_priority"]
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_foreach"]
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).__opaque as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__opaque)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_sched_yield"]
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sched_get_priority_min"]
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sched_get_priority_max"]
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_1 = _bindgen_ty_1::QOS_CLASS_USER_INTERACTIVE;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_1 = _bindgen_ty_1::QOS_CLASS_USER_INITIATED;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_1 = _bindgen_ty_1::QOS_CLASS_DEFAULT;
pub const QOS_CLASS_UTILITY: _bindgen_ty_1 = _bindgen_ty_1::QOS_CLASS_UTILITY;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_1 = _bindgen_ty_1::QOS_CLASS_BACKGROUND;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_1 = _bindgen_ty_1::QOS_CLASS_UNSPECIFIED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    QOS_CLASS_USER_INTERACTIVE = 33,
    QOS_CLASS_USER_INITIATED = 25,
    QOS_CLASS_DEFAULT = 21,
    QOS_CLASS_UTILITY = 17,
    QOS_CLASS_BACKGROUND = 9,
    QOS_CLASS_UNSPECIFIED = 0,
}
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_qos_class_self"]
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    #[link_name = "\u{1}_qos_class_main"]
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_set_qos_class_np"]
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_get_qos_class_np"]
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_set_qos_class_self_np"]
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_qos_class_np"]
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    #[link_name = "\u{1}_pthread_override_qos_class_start_np"]
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_override_qos_class_end_np"]
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    #[link_name = "\u{1}_pthread_atfork"]
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_destroy"]
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getdetachstate"]
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getguardsize"]
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getinheritsched"]
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getschedparam"]
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getschedpolicy"]
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getscope"]
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstack"]
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstackaddr"]
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstacksize"]
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_init"]
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setdetachstate"]
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setguardsize"]
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setinheritsched"]
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setschedparam"]
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setschedpolicy"]
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setscope"]
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstack"]
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstackaddr"]
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstacksize"]
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cancel"]
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_broadcast"]
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_destroy"]
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_init"]
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_signal"]
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_timedwait"]
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_wait"]
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_destroy"]
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_init"]
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_getpshared"]
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_setpshared"]
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_create"]
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_detach"]
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_equal"]
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_exit"]
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_pthread_getconcurrency"]
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getschedparam"]
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getspecific"]
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_pthread_join"]
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_key_create"]
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_key_delete"]
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_destroy"]
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_getprioceiling"]
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_init"]
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_lock"]
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_setprioceiling"]
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_trylock"]
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_unlock"]
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_destroy"]
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getprioceiling"]
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getprotocol"]
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getpshared"]
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_gettype"]
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getpolicy_np"]
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_init"]
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setprioceiling"]
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setprotocol"]
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setpshared"]
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_settype"]
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setpolicy_np"]
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_once"]
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_destroy"]
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_init"]
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_rdlock"]
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_tryrdlock"]
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_trywrlock"]
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_wrlock"]
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_unlock"]
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_destroy"]
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_getpshared"]
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_init"]
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_setpshared"]
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_self"]
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setcancelstate"]
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setcanceltype"]
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setconcurrency"]
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setschedparam"]
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setspecific"]
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_testcancel"]
    pub fn pthread_testcancel();
}
extern "C" {
    #[link_name = "\u{1}_pthread_is_threaded_np"]
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_threadid_np"]
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getname_np"]
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setname_np"]
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_main_np"]
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mach_thread_np"]
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_stacksize_np"]
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_stackaddr_np"]
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_signal_thread_np"]
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_timedwait_relative_np"]
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_create_suspended_np"]
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_from_mach_thread_np"]
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_yield_np"]
    pub fn pthread_yield_np();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    assert_eq!(
        ::std::mem::size_of::<GStaticMutex>(),
        72usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GStaticMutex>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GStaticMutex>())).unused as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_mutex_init"]
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_mutex_free"]
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_mutex_get_mutex_impl"]
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GStaticRecMutex__bindgen_ty_1>())).owner as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GStaticRecMutex__bindgen_ty_1>())).dummy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex>(),
        88usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).depth as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).unused as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_init"]
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_lock"]
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_trylock"]
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_unlock"]
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_lock_full"]
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_unlock_full"]
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_free"]
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRWLock>(),
        104usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).read_cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).write_cond as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).read_counter as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).have_writer as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(have_writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).want_to_read as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).want_to_write as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_write)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_init"]
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_reader_lock"]
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_reader_trylock"]
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_reader_unlock"]
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_writer_lock"]
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_writer_trylock"]
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_writer_unlock"]
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_free"]
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_private_new"]
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticPrivate>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticPrivate),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_private_init"]
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    #[link_name = "\u{1}_g_static_private_get"]
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_static_private_set"]
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_private_free"]
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    #[link_name = "\u{1}_g_once_init_enter_impl"]
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_init"]
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_init_with_errorcheck_mutexes"]
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_get_initialized"]
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_threads_got_initialized"]
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_new"]
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_free"]
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_new"]
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    #[link_name = "\u{1}_g_cond_free"]
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_timed_wait"]
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
extern "C" {
    #[link_name = "\u{1}_renameat"]
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_renamex_np"]
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_renameatx_np"]
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "\u{1}___stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_clearerr"]
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_fclose"]
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_feof"]
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ferror"]
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fflush"]
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgetc"]
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgetpos"]
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgets"]
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fopen"]
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fprintf"]
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fputc"]
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fputs"]
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fread"]
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_freopen"]
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fscanf"]
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fseek"]
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fsetpos"]
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ftell"]
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_fwrite"]
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_getc"]
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getchar"]
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gets"]
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_perror"]
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_printf"]
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putc"]
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putchar"]
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_puts"]
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_remove"]
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rename"]
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rewind"]
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_scanf"]
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setbuf"]
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_setvbuf"]
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sprintf"]
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sscanf"]
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_tmpfile"]
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_tmpnam"]
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ungetc"]
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vfprintf"]
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vprintf"]
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsprintf"]
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ctermid"]
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fdopen"]
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fileno"]
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pclose"]
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_popen"]
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___srget"]
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___svfscanf"]
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___swbuf"]
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_flockfile"]
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_ftrylockfile"]
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_funlockfile"]
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_getc_unlocked"]
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getchar_unlocked"]
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putc_unlocked"]
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putchar_unlocked"]
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getw"]
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putw"]
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_tempnam"]
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fseeko"]
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ftello"]
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    #[link_name = "\u{1}_snprintf"]
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vfscanf"]
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vscanf"]
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsnprintf"]
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsscanf"]
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_dprintf"]
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vdprintf"]
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdelim"]
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_getline"]
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_fmemopen"]
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_open_memstream"]
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_asprintf"]
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ctermid_r"]
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fgetln"]
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fmtcheck"]
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fpurge"]
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setbuffer"]
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_setlinebuf"]
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vasprintf"]
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_zopen"]
    pub fn zopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_funopen"]
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___sprintf_chk"]
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___snprintf_chk"]
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___vsprintf_chk"]
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___vsnprintf_chk"]
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_printf"]
    pub fn g_printf(format: *const gchar, ...) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_fprintf"]
    pub fn g_fprintf(file: *mut FILE, format: *const gchar, ...) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_sprintf"]
    pub fn g_sprintf(string: *mut gchar, format: *const gchar, ...) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_vprintf"]
    pub fn g_vprintf(format: *const gchar, args: *mut __va_list_tag) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_vfprintf"]
    pub fn g_vfprintf(file: *mut FILE, format: *const gchar, args: *mut __va_list_tag) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_vsprintf"]
    pub fn g_vsprintf(string: *mut gchar, format: *const gchar, args: *mut __va_list_tag) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_vasprintf"]
    pub fn g_vasprintf(
        string: *mut *mut gchar,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ostat {
    pub st_dev: __uint16_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: __uint16_t,
    pub st_gid: __uint16_t,
    pub st_rdev: __uint16_t,
    pub st_size: __int32_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_blksize: __int32_t,
    pub st_blocks: __int32_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
}
#[test]
fn bindgen_test_layout_ostat() {
    assert_eq!(
        ::std::mem::size_of::<ostat>(),
        96usize,
        concat!("Size of: ", stringify!(ostat))
    );
    assert_eq!(
        ::std::mem::align_of::<ostat>(),
        8usize,
        concat!("Alignment of ", stringify!(ostat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_nlink as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_gid as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_rdev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_atimespec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_mtimespec as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_ctimespec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_blksize as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_blocks as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_gen as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_gen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atimespec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtimespec as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctimespec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_birthtimespec as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_birthtimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_flags as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gen as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_lspare as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_lspare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_qspare as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_qspare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_stat64() {
    assert_eq!(
        ::std::mem::size_of::<stat64>(),
        144usize,
        concat!("Size of: ", stringify!(stat64))
    );
    assert_eq!(
        ::std::mem::align_of::<stat64>(),
        8usize,
        concat!("Alignment of ", stringify!(stat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_nlink as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_rdev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_atimespec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_mtimespec as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_ctimespec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_birthtimespec as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_birthtimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_blocks as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_blksize as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_flags as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_gen as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_lspare as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_lspare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_qspare as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_qspare)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_chmod"]
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fchmod"]
    pub fn fchmod(arg1: ::std::os::raw::c_int, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstat$INODE64"]
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lstat$INODE64"]
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkdir"]
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkfifo"]
    pub fn mkfifo(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_stat$INODE64"]
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mknod"]
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_umask"]
    pub fn umask(arg1: mode_t) -> mode_t;
}
extern "C" {
    #[link_name = "\u{1}_fchmodat"]
    pub fn fchmodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstatat$INODE64"]
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkdirat"]
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_futimens"]
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_utimensat"]
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
extern "C" {
    #[link_name = "\u{1}_chflags"]
    pub fn chflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_chmodx_np"]
    pub fn chmodx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fchflags"]
    pub fn fchflags(arg1: ::std::os::raw::c_int, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fchmodx_np"]
    pub fn fchmodx_np(arg1: ::std::os::raw::c_int, arg2: filesec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstatx_np$INODE64"]
    pub fn fstatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lchflags"]
    pub fn lchflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lchmod"]
    pub fn lchmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lstatx_np$INODE64"]
    pub fn lstatx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkdirx_np"]
    pub fn mkdirx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkfifox_np"]
    pub fn mkfifox_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_statx_np$INODE64"]
    pub fn statx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_umaskx_np"]
    pub fn umaskx_np(arg1: filesec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstatx64_np"]
    pub fn fstatx64_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat64,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lstatx64_np"]
    pub fn lstatx64_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat64,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_statx64_np"]
    pub fn statx64_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat64,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fstat64"]
    pub fn fstat64(arg1: ::std::os::raw::c_int, arg2: *mut stat64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lstat64"]
    pub fn lstat64(arg1: *const ::std::os::raw::c_char, arg2: *mut stat64)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_stat64"]
    pub fn stat64(arg1: *const ::std::os::raw::c_char, arg2: *mut stat64) -> ::std::os::raw::c_int;
}
pub type GStatBuf = stat;
extern "C" {
    #[link_name = "\u{1}_g_access"]
    pub fn g_access(filename: *const gchar, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_chdir"]
    pub fn g_chdir(path: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_unlink"]
    pub fn g_unlink(filename: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_rmdir"]
    pub fn g_rmdir(filename: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_close"]
    pub fn g_close(fd: gint, error: *mut *mut GError) -> gboolean;
}
#[repr(u32)]
#[doc = " GModuleFlags:"]
#[doc = " @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when"]
#[doc = "     needed. The default action is to bind all symbols when the module"]
#[doc = "     is loaded."]
#[doc = " @G_MODULE_BIND_LOCAL: specifies that symbols in the module should"]
#[doc = "     not be added to the global name space. The default action on most"]
#[doc = "     platforms is to place symbols in the module in the global name space,"]
#[doc = "     which may cause conflicts with existing symbols."]
#[doc = " @G_MODULE_BIND_MASK: mask for all flags."]
#[doc = ""]
#[doc = " Flags passed to g_module_open()."]
#[doc = " Note that these flags are not supported on all platforms."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GModuleFlags {
    G_MODULE_BIND_LAZY = 1,
    G_MODULE_BIND_LOCAL = 2,
    G_MODULE_BIND_MASK = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
extern "C" {
    #[link_name = "\u{1}_g_module_supported"]
    pub fn g_module_supported() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_module_open"]
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
extern "C" {
    #[link_name = "\u{1}_g_module_close"]
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_module_make_resident"]
    pub fn g_module_make_resident(module: *mut GModule);
}
extern "C" {
    #[link_name = "\u{1}_g_module_error"]
    pub fn g_module_error() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_module_symbol"]
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_module_name"]
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_module_build_path"]
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
pub type GType = gsize;
pub type GValue = _GValue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GTypeCValue {
    _unused: [u8; 0],
}
pub type GTypeCValue = _GTypeCValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePlugin {
    _unused: [u8; 0],
}
pub type GTypePlugin = _GTypePlugin;
pub type GTypeClass = _GTypeClass;
pub type GTypeInterface = _GTypeInterface;
pub type GTypeInstance = _GTypeInstance;
pub type GTypeInfo = _GTypeInfo;
pub type GTypeFundamentalInfo = _GTypeFundamentalInfo;
pub type GInterfaceInfo = _GInterfaceInfo;
pub type GTypeValueTable = _GTypeValueTable;
pub type GTypeQuery = _GTypeQuery;
#[doc = " GTypeClass:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeClass>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
#[doc = " GTypeInstance:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInstance>())).g_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
#[doc = " GTypeInterface:"]
#[doc = ""]
#[doc = " An opaque structure used as the base of all interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInterface>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInterface>())).g_instance_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_instance_type)
        )
    );
}
#[doc = " GTypeQuery:"]
#[doc = " @type: the #GType value of the type"]
#[doc = " @type_name: the name of the type"]
#[doc = " @class_size: the size of the class structure"]
#[doc = " @instance_size: the size of the instance structure"]
#[doc = ""]
#[doc = " A structure holding information for a specific type."]
#[doc = " It is filled in by the g_type_query() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeQuery {
    pub type_: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
#[test]
fn bindgen_test_layout__GTypeQuery() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeQuery>(),
        24usize,
        concat!("Size of: ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).type_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).class_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).instance_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(instance_size)
        )
    );
}
#[repr(u32)]
#[doc = " GTypeDebugFlags:"]
#[doc = " @G_TYPE_DEBUG_NONE: Print no messages"]
#[doc = " @G_TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping"]
#[doc = " @G_TYPE_DEBUG_SIGNALS: Print messages about signal emissions"]
#[doc = " @G_TYPE_DEBUG_MASK: Mask covering all debug flags"]
#[doc = " @G_TYPE_DEBUG_INSTANCE_COUNT: Keep a count of instances of each type"]
#[doc = ""]
#[doc = " These flags used to be passed to g_type_init_with_debug_flags() which"]
#[doc = " is now deprecated."]
#[doc = ""]
#[doc = " If you need to enable debugging features, use the GOBJECT_DEBUG"]
#[doc = " environment variable."]
#[doc = ""]
#[doc = " Deprecated: 2.36: g_type_init() is now done automatically"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTypeDebugFlags {
    G_TYPE_DEBUG_NONE = 0,
    G_TYPE_DEBUG_OBJECTS = 1,
    G_TYPE_DEBUG_SIGNALS = 2,
    G_TYPE_DEBUG_INSTANCE_COUNT = 4,
    G_TYPE_DEBUG_MASK = 7,
}
extern "C" {
    #[link_name = "\u{1}_g_type_init"]
    pub fn g_type_init();
}
extern "C" {
    #[link_name = "\u{1}_g_type_init_with_debug_flags"]
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
}
extern "C" {
    #[link_name = "\u{1}_g_type_name"]
    pub fn g_type_name(type_: GType) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_type_qname"]
    pub fn g_type_qname(type_: GType) -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_type_from_name"]
    pub fn g_type_from_name(name: *const gchar) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_parent"]
    pub fn g_type_parent(type_: GType) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_depth"]
    pub fn g_type_depth(type_: GType) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_type_next_base"]
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_is_a"]
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_ref"]
    pub fn g_type_class_ref(type_: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_peek"]
    pub fn g_type_class_peek(type_: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_peek_static"]
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_unref"]
    pub fn g_type_class_unref(g_class: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_peek_parent"]
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_peek"]
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_peek_parent"]
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_default_interface_ref"]
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_default_interface_peek"]
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_default_interface_unref"]
    pub fn g_type_default_interface_unref(g_iface: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_type_children"]
    pub fn g_type_children(type_: GType, n_children: *mut guint) -> *mut GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_interfaces"]
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut guint) -> *mut GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_set_qdata"]
    pub fn g_type_set_qdata(type_: GType, quark: GQuark, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_type_get_qdata"]
    pub fn g_type_get_qdata(type_: GType, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_query"]
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
}
extern "C" {
    #[link_name = "\u{1}_g_type_get_instance_count"]
    pub fn g_type_get_instance_count(type_: GType) -> ::std::os::raw::c_int;
}
#[doc = " GBaseInitFunc:"]
#[doc = " @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize"]
#[doc = ""]
#[doc = " A callback function used by the type system to do base initialization"]
#[doc = " of the class structures of derived types. It is called as part of the"]
#[doc = " initialization process of all derived classes and should reallocate"]
#[doc = " or reset all dynamic class members copied over from the parent class."]
#[doc = " For example, class members (such as strings) that are not sufficiently"]
#[doc = " handled by a plain memory copy of the parent class into the derived class"]
#[doc = " have to be altered. See GClassInitFunc() for a discussion of the class"]
#[doc = " initialization process."]
pub type GBaseInitFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GBaseFinalizeFunc:"]
#[doc = " @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize"]
#[doc = ""]
#[doc = " A callback function used by the type system to finalize those portions"]
#[doc = " of a derived types class structure that were setup from the corresponding"]
#[doc = " GBaseInitFunc() function. Class finalization basically works the inverse"]
#[doc = " way in which class initialization is performed."]
#[doc = " See GClassInitFunc() for a discussion of the class initialization process."]
pub type GBaseFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GClassInitFunc:"]
#[doc = " @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize."]
#[doc = " @class_data: The @class_data member supplied via the #GTypeInfo structure."]
#[doc = ""]
#[doc = " A callback function used by the type system to initialize the class"]
#[doc = " of a specific type. This function should initialize all static class"]
#[doc = " members."]
#[doc = ""]
#[doc = " The initialization process of a class involves:"]
#[doc = ""]
#[doc = " - Copying common members from the parent class over to the"]
#[doc = "   derived class structure."]
#[doc = " - Zero initialization of the remaining members not copied"]
#[doc = "   over from the parent class."]
#[doc = " - Invocation of the GBaseInitFunc() initializers of all parent"]
#[doc = "   types and the class' type."]
#[doc = " - Invocation of the class' GClassInitFunc() initializer."]
#[doc = ""]
#[doc = " Since derived classes are partially initialized through a memory copy"]
#[doc = " of the parent class, the general rule is that GBaseInitFunc() and"]
#[doc = " GBaseFinalizeFunc() should take care of necessary reinitialization"]
#[doc = " and release of those class members that were introduced by the type"]
#[doc = " that specified these GBaseInitFunc()/GBaseFinalizeFunc()."]
#[doc = " GClassInitFunc() should only care about initializing static"]
#[doc = " class members, while dynamic class members (such as allocated strings"]
#[doc = " or reference counted resources) are better handled by a GBaseInitFunc()"]
#[doc = " for this type, so proper initialization of the dynamic class members"]
#[doc = " is performed for class initialization of derived types as well."]
#[doc = ""]
#[doc = " An example may help to correspond the intend of the different class"]
#[doc = " initializers:"]
#[doc = ""]
#[doc = " |[<!-- language=\"C\" -->"]
#[doc = " typedef struct {"]
#[doc = "   GObjectClass parent_class;"]
#[doc = "   gint         static_integer;"]
#[doc = "   gchar       *dynamic_string;"]
#[doc = " } TypeAClass;"]
#[doc = " static void"]
#[doc = " type_a_base_class_init (TypeAClass *class)"]
#[doc = " {"]
#[doc = "   class->dynamic_string = g_strdup (\"some string\");"]
#[doc = " }"]
#[doc = " static void"]
#[doc = " type_a_base_class_finalize (TypeAClass *class)"]
#[doc = " {"]
#[doc = "   g_free (class->dynamic_string);"]
#[doc = " }"]
#[doc = " static void"]
#[doc = " type_a_class_init (TypeAClass *class)"]
#[doc = " {"]
#[doc = "   class->static_integer = 42;"]
#[doc = " }"]
#[doc = ""]
#[doc = " typedef struct {"]
#[doc = "   TypeAClass   parent_class;"]
#[doc = "   gfloat       static_float;"]
#[doc = "   GString     *dynamic_gstring;"]
#[doc = " } TypeBClass;"]
#[doc = " static void"]
#[doc = " type_b_base_class_init (TypeBClass *class)"]
#[doc = " {"]
#[doc = "   class->dynamic_gstring = g_string_new (\"some other string\");"]
#[doc = " }"]
#[doc = " static void"]
#[doc = " type_b_base_class_finalize (TypeBClass *class)"]
#[doc = " {"]
#[doc = "   g_string_free (class->dynamic_gstring);"]
#[doc = " }"]
#[doc = " static void"]
#[doc = " type_b_class_init (TypeBClass *class)"]
#[doc = " {"]
#[doc = "   class->static_float = 3.14159265358979323846;"]
#[doc = " }"]
#[doc = " ]|"]
#[doc = " Initialization of TypeBClass will first cause initialization of"]
#[doc = " TypeAClass (derived classes reference their parent classes, see"]
#[doc = " g_type_class_ref() on this)."]
#[doc = ""]
#[doc = " Initialization of TypeAClass roughly involves zero-initializing its fields,"]
#[doc = " then calling its GBaseInitFunc() type_a_base_class_init() to allocate"]
#[doc = " its dynamic members (dynamic_string), and finally calling its GClassInitFunc()"]
#[doc = " type_a_class_init() to initialize its static members (static_integer)."]
#[doc = " The first step in the initialization process of TypeBClass is then"]
#[doc = " a plain memory copy of the contents of TypeAClass into TypeBClass and"]
#[doc = " zero-initialization of the remaining fields in TypeBClass."]
#[doc = " The dynamic members of TypeAClass within TypeBClass now need"]
#[doc = " reinitialization which is performed by calling type_a_base_class_init()"]
#[doc = " with an argument of TypeBClass."]
#[doc = ""]
#[doc = " After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()"]
#[doc = " is called to allocate the dynamic members of TypeBClass (dynamic_gstring),"]
#[doc = " and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),"]
#[doc = " is called to complete the initialization process with the static members"]
#[doc = " (static_float)."]
#[doc = ""]
#[doc = " Corresponding finalization counter parts to the GBaseInitFunc() functions"]
#[doc = " have to be provided to release allocated resources at class finalization"]
#[doc = " time."]
pub type GClassInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GClassFinalizeFunc:"]
#[doc = " @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize"]
#[doc = " @class_data: The @class_data member supplied via the #GTypeInfo structure"]
#[doc = ""]
#[doc = " A callback function used by the type system to finalize a class."]
#[doc = " This function is rarely needed, as dynamically allocated class resources"]
#[doc = " should be handled by GBaseInitFunc() and GBaseFinalizeFunc()."]
#[doc = " Also, specification of a GClassFinalizeFunc() in the #GTypeInfo"]
#[doc = " structure of a static type is invalid, because classes of static types"]
#[doc = " will never be finalized (they are artificially kept alive when their"]
#[doc = " reference count drops to zero)."]
pub type GClassFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GInstanceInitFunc:"]
#[doc = " @instance: The instance to initialize"]
#[doc = " @g_class: (type GObject.TypeClass): The class of the type the instance is"]
#[doc = "    created for"]
#[doc = ""]
#[doc = " A callback function used by the type system to initialize a new"]
#[doc = " instance of a type. This function initializes all instance members and"]
#[doc = " allocates any resources required by it."]
#[doc = ""]
#[doc = " Initialization of a derived instance involves calling all its parent"]
#[doc = " types instance initializers, so the class member of the instance"]
#[doc = " is altered during its initialization to always point to the class that"]
#[doc = " belongs to the type the current initializer was introduced for."]
#[doc = ""]
#[doc = " The extended members of @instance are guaranteed to have been filled with"]
#[doc = " zeros before this function is called."]
pub type GInstanceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(instance: *mut GTypeInstance, g_class: gpointer)>;
#[doc = " GInterfaceInitFunc:"]
#[doc = " @g_iface: (type GObject.TypeInterface): The interface structure to initialize"]
#[doc = " @iface_data: The @interface_data supplied via the #GInterfaceInfo structure"]
#[doc = ""]
#[doc = " A callback function used by the type system to initialize a new"]
#[doc = " interface.  This function should initialize all internal data and"]
#[doc = " allocate any resources required by the interface."]
#[doc = ""]
#[doc = " The members of @iface_data are guaranteed to have been filled with"]
#[doc = " zeros before this function is called."]
pub type GInterfaceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GInterfaceFinalizeFunc:"]
#[doc = " @g_iface: (type GObject.TypeInterface): The interface structure to finalize"]
#[doc = " @iface_data: The @interface_data supplied via the #GInterfaceInfo structure"]
#[doc = ""]
#[doc = " A callback function used by the type system to finalize an interface."]
#[doc = " This function should destroy any internal data and release any resources"]
#[doc = " allocated by the corresponding GInterfaceInitFunc() function."]
pub type GInterfaceFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GTypeClassCacheFunc:"]
#[doc = " @cache_data: data that was given to the g_type_add_class_cache_func() call"]
#[doc = " @g_class: (type GObject.TypeClass): The #GTypeClass structure which is"]
#[doc = "    unreferenced"]
#[doc = ""]
#[doc = " A callback function which is called when the reference count of a class"]
#[doc = " drops to zero. It may use g_type_class_ref() to prevent the class from"]
#[doc = " being freed. You should not call g_type_class_unref() from a"]
#[doc = " #GTypeClassCacheFunc function to prevent infinite recursion, use"]
#[doc = " g_type_class_unref_uncached() instead."]
#[doc = ""]
#[doc = " The functions have to check the class id passed in to figure"]
#[doc = " whether they actually want to cache the class of this type, since all"]
#[doc = " classes are routed through the same #GTypeClassCacheFunc chain."]
#[doc = ""]
#[doc = " Returns: %TRUE to stop further #GTypeClassCacheFuncs from being"]
#[doc = "  called, %FALSE to continue"]
pub type GTypeClassCacheFunc = ::std::option::Option<
    unsafe extern "C" fn(cache_data: gpointer, g_class: *mut GTypeClass) -> gboolean,
>;
#[doc = " GTypeInterfaceCheckFunc:"]
#[doc = " @check_data: data passed to g_type_add_interface_check()"]
#[doc = " @g_iface: (type GObject.TypeInterface): the interface that has been"]
#[doc = "    initialized"]
#[doc = ""]
#[doc = " A callback called after an interface vtable is initialized."]
#[doc = " See g_type_add_interface_check()."]
#[doc = ""]
#[doc = " Since: 2.4"]
pub type GTypeInterfaceCheckFunc =
    ::std::option::Option<unsafe extern "C" fn(check_data: gpointer, g_iface: gpointer)>;
#[repr(u32)]
#[doc = " GTypeFundamentalFlags:"]
#[doc = " @G_TYPE_FLAG_CLASSED: Indicates a classed type"]
#[doc = " @G_TYPE_FLAG_INSTANTIATABLE: Indicates an instantiable type (implies classed)"]
#[doc = " @G_TYPE_FLAG_DERIVABLE: Indicates a flat derivable type"]
#[doc = " @G_TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable)"]
#[doc = ""]
#[doc = " Bit masks used to check or determine specific characteristics of a"]
#[doc = " fundamental type."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTypeFundamentalFlags {
    G_TYPE_FLAG_CLASSED = 1,
    G_TYPE_FLAG_INSTANTIATABLE = 2,
    G_TYPE_FLAG_DERIVABLE = 4,
    G_TYPE_FLAG_DEEP_DERIVABLE = 8,
}
#[repr(u32)]
#[doc = " GTypeFlags:"]
#[doc = " @G_TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be"]
#[doc = "  created for an abstract type"]
#[doc = " @G_TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type"]
#[doc = "  that introduces a value table, but can't be used for"]
#[doc = "  g_value_init()"]
#[doc = ""]
#[doc = " Bit masks used to check or determine characteristics of a type."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GTypeFlags {
    G_TYPE_FLAG_ABSTRACT = 16,
    G_TYPE_FLAG_VALUE_ABSTRACT = 32,
}
#[doc = " GTypeInfo:"]
#[doc = " @class_size: Size of the class structure (required for interface, classed and instantiatable types)"]
#[doc = " @base_init: Location of the base initialization function (optional)"]
#[doc = " @base_finalize: Location of the base finalization function (optional)"]
#[doc = " @class_init: Location of the class initialization function for"]
#[doc = "  classed and instantiatable types. Location of the default vtable"]
#[doc = "  inititalization function for interface types. (optional) This function"]
#[doc = "  is used both to fill in virtual functions in the class or default vtable,"]
#[doc = "  and to do type-specific setup such as registering signals and object"]
#[doc = "  properties."]
#[doc = " @class_finalize: Location of the class finalization function for"]
#[doc = "  classed and instantiatable types. Location of the default vtable"]
#[doc = "  finalization function for interface types. (optional)"]
#[doc = " @class_data: User-supplied data passed to the class init/finalize functions"]
#[doc = " @instance_size: Size of the instance (object) structure (required for instantiatable types only)"]
#[doc = " @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now."]
#[doc = " @instance_init: Location of the instance initialization function (optional, for instantiatable types only)"]
#[doc = " @value_table: A #GTypeValueTable function table for generic handling of GValues"]
#[doc = "  of this type (usually only useful for fundamental types)"]
#[doc = ""]
#[doc = " This structure is used to provide the type system with the information"]
#[doc = " required to initialize and destruct (finalize) a type's class and"]
#[doc = " its instances."]
#[doc = ""]
#[doc = " The initialized structure is passed to the g_type_register_static() function"]
#[doc = " (or is copied into the provided #GTypeInfo structure in the"]
#[doc = " g_type_plugin_complete_type_info()). The type system will perform a deep"]
#[doc = " copy of this structure, so its memory does not need to be persistent"]
#[doc = " across invocation of g_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
#[test]
fn bindgen_test_layout__GTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).base_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).base_finalize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_finalize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).instance_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).n_preallocs as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).instance_init as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).value_table as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(value_table)
        )
    );
}
#[doc = " GTypeFundamentalInfo:"]
#[doc = " @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type"]
#[doc = ""]
#[doc = " A structure that provides information to the type system which is"]
#[doc = " used specifically for managing fundamental types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
#[test]
fn bindgen_test_layout__GTypeFundamentalInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Size of: ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTypeFundamentalInfo>())).type_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeFundamentalInfo),
            "::",
            stringify!(type_flags)
        )
    );
}
#[doc = " GInterfaceInfo:"]
#[doc = " @interface_init: location of the interface initialization function"]
#[doc = " @interface_finalize: location of the interface finalization function"]
#[doc = " @interface_data: user-supplied data passed to the interface init/finalize functions"]
#[doc = ""]
#[doc = " A structure that provides information to the type system which is"]
#[doc = " used specifically for managing interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
#[test]
fn bindgen_test_layout__GInterfaceInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GInterfaceInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_finalize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_data)
        )
    );
}
#[doc = " GTypeValueTable:"]
#[doc = " @value_init: Default initialize @values contents by poking values"]
#[doc = "  directly into the value->data array. The data array of"]
#[doc = "  the #GValue passed into this function was zero-filled"]
#[doc = "  with `memset()`, so no care has to be taken to free any"]
#[doc = "  old contents. E.g. for the implementation of a string"]
#[doc = "  value that may never be %NULL, the implementation might"]
#[doc = "  look like:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  value->data[0].v_pointer = g_strdup (\"\");"]
#[doc = "  ]|"]
#[doc = " @value_free: Free any old contents that might be left in the"]
#[doc = "  data array of the passed in @value. No resources may"]
#[doc = "  remain allocated through the #GValue contents after"]
#[doc = "  this function returns. E.g. for our above string type:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  // only free strings without a specific flag for static storage"]
#[doc = "  if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))"]
#[doc = "    g_free (value->data[0].v_pointer);"]
#[doc = "  ]|"]
#[doc = " @value_copy: @dest_value is a #GValue with zero-filled data section"]
#[doc = "  and @src_value is a properly setup #GValue of same or"]
#[doc = "  derived type."]
#[doc = "  The purpose of this function is to copy the contents of"]
#[doc = "  @src_value into @dest_value in a way, that even after"]
#[doc = "  @src_value has been freed, the contents of @dest_value"]
#[doc = "  remain valid. String type example:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);"]
#[doc = "  ]|"]
#[doc = " @value_peek_pointer: If the value contents fit into a pointer, such as objects"]
#[doc = "  or strings, return this pointer, so the caller can peek at"]
#[doc = "  the current contents. To extend on our above string example:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  return value->data[0].v_pointer;"]
#[doc = "  ]|"]
#[doc = " @collect_format: A string format describing how to collect the contents of"]
#[doc = "  this value bit-by-bit. Each character in the format represents"]
#[doc = "  an argument to be collected, and the characters themselves indicate"]
#[doc = "  the type of the argument. Currently supported arguments are:"]
#[doc = "  - 'i' - Integers. passed as collect_values[].v_int."]
#[doc = "  - 'l' - Longs. passed as collect_values[].v_long."]
#[doc = "  - 'd' - Doubles. passed as collect_values[].v_double."]
#[doc = "  - 'p' - Pointers. passed as collect_values[].v_pointer."]
#[doc = "  It should be noted that for variable argument list construction,"]
#[doc = "  ANSI C promotes every type smaller than an integer to an int, and"]
#[doc = "  floats to doubles. So for collection of short int or char, 'i'"]
#[doc = "  needs to be used, and for collection of floats 'd'."]
#[doc = " @collect_value: The collect_value() function is responsible for converting the"]
#[doc = "  values collected from a variable argument list into contents"]
#[doc = "  suitable for storage in a GValue. This function should setup"]
#[doc = "  @value similar to value_init(); e.g. for a string value that"]
#[doc = "  does not allow %NULL pointers, it needs to either spew an error,"]
#[doc = "  or do an implicit conversion by storing an empty string."]
#[doc = "  The @value passed in to this function has a zero-filled data"]
#[doc = "  array, so just like for value_init() it is guaranteed to not"]
#[doc = "  contain any old contents that might need freeing."]
#[doc = "  @n_collect_values is exactly the string length of @collect_format,"]
#[doc = "  and @collect_values is an array of unions #GTypeCValue with"]
#[doc = "  length @n_collect_values, containing the collected values"]
#[doc = "  according to @collect_format."]
#[doc = "  @collect_flags is an argument provided as a hint by the caller."]
#[doc = "  It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,"]
#[doc = "  that the collected value contents may be considered \"static\""]
#[doc = "  for the duration of the @value lifetime."]
#[doc = "  Thus an extra copy of the contents stored in @collect_values is"]
#[doc = "  not required for assignment to @value."]
#[doc = "  For our above string example, we continue with:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  if (!collect_values[0].v_pointer)"]
#[doc = "    value->data[0].v_pointer = g_strdup (\"\");"]
#[doc = "  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)"]
#[doc = "  {"]
#[doc = "    value->data[0].v_pointer = collect_values[0].v_pointer;"]
#[doc = "    // keep a flag for the value_free() implementation to not free this string"]
#[doc = "    value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;"]
#[doc = "  }"]
#[doc = "  else"]
#[doc = "    value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);"]
#[doc = "  return NULL;"]
#[doc = "  ]|"]
#[doc = "  It should be noted, that it is generally a bad idea to follow the"]
#[doc = "  #G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to"]
#[doc = "  reentrancy requirements and reference count assertions performed"]
#[doc = "  by the signal emission code, reference counts should always be"]
#[doc = "  incremented for reference counted contents stored in the value->data"]
#[doc = "  array.  To deviate from our string example for a moment, and taking"]
#[doc = "  a look at an exemplary implementation for collect_value() of"]
#[doc = "  #GObject:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  if (collect_values[0].v_pointer)"]
#[doc = "  {"]
#[doc = "    GObject *object = G_OBJECT (collect_values[0].v_pointer);"]
#[doc = "    // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types"]
#[doc = "    value->data[0].v_pointer = g_object_ref (object);"]
#[doc = "    return NULL;"]
#[doc = "  }"]
#[doc = "  else"]
#[doc = "    return g_strdup_printf (\"Object passed as invalid NULL pointer\");"]
#[doc = "  }"]
#[doc = "  ]|"]
#[doc = "  The reference count for valid objects is always incremented,"]
#[doc = "  regardless of @collect_flags. For invalid objects, the example"]
#[doc = "  returns a newly allocated string without altering @value."]
#[doc = "  Upon success, collect_value() needs to return %NULL. If, however,"]
#[doc = "  an error condition occurred, collect_value() may spew an"]
#[doc = "  error by returning a newly allocated non-%NULL string, giving"]
#[doc = "  a suitable description of the error condition."]
#[doc = "  The calling code makes no assumptions about the @value"]
#[doc = "  contents being valid upon error returns, @value"]
#[doc = "  is simply thrown away without further freeing. As such, it is"]
#[doc = "  a good idea to not allocate #GValue contents, prior to returning"]
#[doc = "  an error, however, collect_values() is not obliged to return"]
#[doc = "  a correctly setup @value for error returns, simply because"]
#[doc = "  any non-%NULL return is considered a fatal condition so further"]
#[doc = "  program behaviour is undefined."]
#[doc = " @lcopy_format: Format description of the arguments to collect for @lcopy_value,"]
#[doc = "  analogous to @collect_format. Usually, @lcopy_format string consists"]
#[doc = "  only of 'p's to provide lcopy_value() with pointers to storage locations."]
#[doc = " @lcopy_value: This function is responsible for storing the @value contents into"]
#[doc = "  arguments passed through a variable argument list which got"]
#[doc = "  collected into @collect_values according to @lcopy_format."]
#[doc = "  @n_collect_values equals the string length of @lcopy_format,"]
#[doc = "  and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS."]
#[doc = "  In contrast to collect_value(), lcopy_value() is obliged to"]
#[doc = "  always properly support %G_VALUE_NOCOPY_CONTENTS."]
#[doc = "  Similar to collect_value() the function may prematurely abort"]
#[doc = "  by returning a newly allocated string describing an error condition."]
#[doc = "  To complete the string example:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  gchar **string_p = collect_values[0].v_pointer;"]
#[doc = "  if (!string_p)"]
#[doc = "    return g_strdup_printf (\"string location passed as NULL\");"]
#[doc = "  if (collect_flags & G_VALUE_NOCOPY_CONTENTS)"]
#[doc = "    *string_p = value->data[0].v_pointer;"]
#[doc = "  else"]
#[doc = "    *string_p = g_strdup (value->data[0].v_pointer);"]
#[doc = "  ]|"]
#[doc = "  And an illustrative version of lcopy_value() for"]
#[doc = "  reference-counted types:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  GObject **object_p = collect_values[0].v_pointer;"]
#[doc = "  if (!object_p)"]
#[doc = "    return g_strdup_printf (\"object location passed as NULL\");"]
#[doc = "  if (!value->data[0].v_pointer)"]
#[doc = "    *object_p = NULL;"]
#[doc = "  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour"]
#[doc = "    *object_p = value->data[0].v_pointer;"]
#[doc = "  else"]
#[doc = "    *object_p = g_object_ref (value->data[0].v_pointer);"]
#[doc = "  return NULL;"]
#[doc = "  ]|"]
#[doc = ""]
#[doc = " The #GTypeValueTable provides the functions required by the #GValue"]
#[doc = " implementation, to serve as a container for values of a type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeValueTable {
    pub value_init: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_free: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_copy: ::std::option::Option<
        unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue),
    >,
    pub value_peek_pointer:
        ::std::option::Option<unsafe extern "C" fn(value: *const GValue) -> gpointer>,
    pub collect_format: *const gchar,
    pub collect_value: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut GValue,
            n_collect_values: guint,
            collect_values: *mut GTypeCValue,
            collect_flags: guint,
        ) -> *mut gchar,
    >,
    pub lcopy_format: *const gchar,
    pub lcopy_value: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const GValue,
            n_collect_values: guint,
            collect_values: *mut GTypeCValue,
            collect_flags: guint,
        ) -> *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GTypeValueTable() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeValueTable>(),
        64usize,
        concat!("Size of: ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeValueTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_copy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTypeValueTable>())).value_peek_pointer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_peek_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).collect_format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).collect_value as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).lcopy_format as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).lcopy_value as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_register_static"]
    pub fn g_type_register_static(
        parent_type: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_register_static_simple"]
    pub fn g_type_register_static_simple(
        parent_type: GType,
        type_name: *const gchar,
        class_size: guint,
        class_init: GClassInitFunc,
        instance_size: guint,
        instance_init: GInstanceInitFunc,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_register_dynamic"]
    pub fn g_type_register_dynamic(
        parent_type: GType,
        type_name: *const gchar,
        plugin: *mut GTypePlugin,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_register_fundamental"]
    pub fn g_type_register_fundamental(
        type_id: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        finfo: *const GTypeFundamentalInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_interface_static"]
    pub fn g_type_add_interface_static(
        instance_type: GType,
        interface_type: GType,
        info: *const GInterfaceInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_interface_dynamic"]
    pub fn g_type_add_interface_dynamic(
        instance_type: GType,
        interface_type: GType,
        plugin: *mut GTypePlugin,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_add_prerequisite"]
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_prerequisites"]
    pub fn g_type_interface_prerequisites(
        interface_type: GType,
        n_prerequisites: *mut guint,
    ) -> *mut GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_add_private"]
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_instance_private"]
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_type_instance_get_private"]
    pub fn g_type_instance_get_private(
        instance: *mut GTypeInstance,
        private_type: GType,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_adjust_private_offset"]
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: *mut gint);
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_class_private"]
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_get_private"]
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_get_instance_private_offset"]
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_type_ensure"]
    pub fn g_type_ensure(type_: GType);
}
extern "C" {
    #[link_name = "\u{1}_g_type_get_type_registration_serial"]
    pub fn g_type_get_type_registration_serial() -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_type_get_plugin"]
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_get_plugin"]
    pub fn g_type_interface_get_plugin(
        instance_type: GType,
        interface_type: GType,
    ) -> *mut GTypePlugin;
}
extern "C" {
    #[link_name = "\u{1}_g_type_fundamental_next"]
    pub fn g_type_fundamental_next() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_fundamental"]
    pub fn g_type_fundamental(type_id: GType) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_create_instance"]
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
}
extern "C" {
    #[link_name = "\u{1}_g_type_free_instance"]
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_class_cache_func"]
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_type_remove_class_cache_func"]
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_unref_uncached"]
    pub fn g_type_class_unref_uncached(g_class: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_interface_check"]
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_type_remove_interface_check"]
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_type_value_table_peek"]
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_instance"]
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_instance_cast"]
    pub fn g_type_check_instance_cast(
        instance: *mut GTypeInstance,
        iface_type: GType,
    ) -> *mut GTypeInstance;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_instance_is_a"]
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_instance_is_fundamentally_a"]
    pub fn g_type_check_instance_is_fundamentally_a(
        instance: *mut GTypeInstance,
        fundamental_type: GType,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_class_cast"]
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_class_is_a"]
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_is_value_type"]
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_value"]
    pub fn g_type_check_value(value: *const GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_value_holds"]
    pub fn g_type_check_value_holds(value: *const GValue, type_: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_test_flags"]
    pub fn g_type_test_flags(type_: GType, flags: guint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_name_from_instance"]
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_type_name_from_class"]
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
}
#[doc = " GValueTransform:"]
#[doc = " @src_value: Source value."]
#[doc = " @dest_value: Target value."]
#[doc = ""]
#[doc = " The type of value transformation functions which can be registered with"]
#[doc = " g_value_register_transform_func()."]
#[doc = ""]
#[doc = " @dest_value will be initialized to the correct destination type."]
pub type GValueTransform =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
#[doc = " GValue:"]
#[doc = ""]
#[doc = " An opaque structure used to hold different types of values."]
#[doc = " The data within the structure has protected scope: it is accessible only"]
#[doc = " to functions within a #GTypeValueTable structure, or implementations of"]
#[doc = " the g_value_*() API. That is, code portions which implement new fundamental"]
#[doc = " types."]
#[doc = " #GValue users cannot make any assumptions about how data is stored"]
#[doc = " within the 2 element @data union, and the @g_type member should"]
#[doc = " only be accessed through the G_VALUE_TYPE() macro."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GValue__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_uint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_long as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_ulong as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_ulong)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_uint64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__GValue() {
    assert_eq!(
        ::std::mem::size_of::<_GValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_value_init"]
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
}
extern "C" {
    #[link_name = "\u{1}_g_value_copy"]
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
}
extern "C" {
    #[link_name = "\u{1}_g_value_reset"]
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
}
extern "C" {
    #[link_name = "\u{1}_g_value_unset"]
    pub fn g_value_unset(value: *mut GValue);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_instance"]
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_init_from_instance"]
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_fits_pointer"]
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_peek_pointer"]
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_value_type_compatible"]
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_type_transformable"]
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_transform"]
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_register_transform_func"]
    pub fn g_value_register_transform_func(
        src_type: GType,
        dest_type: GType,
        transform_func: GValueTransform,
    );
}
impl GParamFlags {
    pub const G_PARAM_PRIVATE: GParamFlags = GParamFlags::G_PARAM_STATIC_NAME;
}
#[repr(i32)]
#[doc = " GParamFlags:"]
#[doc = " @G_PARAM_READABLE: the parameter is readable"]
#[doc = " @G_PARAM_WRITABLE: the parameter is writable"]
#[doc = " @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE"]
#[doc = " @G_PARAM_CONSTRUCT: the parameter will be set upon object construction"]
#[doc = " @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction"]
#[doc = " @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())"]
#[doc = "  strict validation is not required"]
#[doc = " @G_PARAM_STATIC_NAME: the string used as name when constructing the"]
#[doc = "  parameter is guaranteed to remain valid and"]
#[doc = "  unmodified for the lifetime of the parameter."]
#[doc = "  Since 2.8"]
#[doc = " @G_PARAM_STATIC_NICK: the string used as nick when constructing the"]
#[doc = "  parameter is guaranteed to remain valid and"]
#[doc = "  unmmodified for the lifetime of the parameter."]
#[doc = "  Since 2.8"]
#[doc = " @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the"]
#[doc = "  parameter is guaranteed to remain valid and"]
#[doc = "  unmodified for the lifetime of the parameter."]
#[doc = "  Since 2.8"]
#[doc = " @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this"]
#[doc = "   property will not automatically result in a \"notify\" signal being"]
#[doc = "   emitted: the implementation must call g_object_notify() themselves"]
#[doc = "   in case the property actually changes.  Since: 2.42."]
#[doc = " @G_PARAM_PRIVATE: internal"]
#[doc = " @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed"]
#[doc = "  in a future version. A warning will be generated if it is used"]
#[doc = "  while running with G_ENABLE_DIAGNOSTIC=1."]
#[doc = "  Since 2.26"]
#[doc = ""]
#[doc = " Through the #GParamFlags flag values, certain aspects of parameters"]
#[doc = " can be configured. See also #G_PARAM_STATIC_STRINGS."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GParamFlags {
    G_PARAM_READABLE = 1,
    G_PARAM_WRITABLE = 2,
    G_PARAM_READWRITE = 3,
    G_PARAM_CONSTRUCT = 4,
    G_PARAM_CONSTRUCT_ONLY = 8,
    G_PARAM_LAX_VALIDATION = 16,
    G_PARAM_STATIC_NAME = 32,
    G_PARAM_STATIC_NICK = 64,
    G_PARAM_STATIC_BLURB = 128,
    G_PARAM_EXPLICIT_NOTIFY = 1073741824,
    G_PARAM_DEPRECATED = -2147483648,
}
pub type GParamSpec = _GParamSpec;
pub type GParamSpecClass = _GParamSpecClass;
pub type GParameter = _GParameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPool {
    _unused: [u8; 0],
}
pub type GParamSpecPool = _GParamSpecPool;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_uref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)"]
#[doc = " @g_type_instance: private #GTypeInstance portion"]
#[doc = " @name: name of this parameter: always an interned string"]
#[doc = " @flags: #GParamFlags flags for this parameter"]
#[doc = " @value_type: the #GValue type for this parameter"]
#[doc = " @owner_type: #GType type that uses (introduces) this parameter"]
#[doc = ""]
#[doc = " All other fields of the GParamSpec struct are private and"]
#[doc = " should not be used directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[test]
fn bindgen_test_layout__GParamSpec() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpec>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).value_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).owner_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(owner_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>()))._nick as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_nick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>()))._blurb as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_blurb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).qdata as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).ref_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).param_id as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(param_id)
        )
    );
}
#[doc = " GParamSpecClass:"]
#[doc = " @g_type_class: the parent class"]
#[doc = " @value_type: the #GValue type for this parameter"]
#[doc = " @finalize: The instance finalization function (optional), should chain"]
#[doc = "  up to the finalize method of the parent class."]
#[doc = " @value_set_default: Resets a @value to the default value for this type"]
#[doc = "  (recommended, the default is g_value_reset()), see"]
#[doc = "  g_param_value_set_default()."]
#[doc = " @value_validate: Ensures that the contents of @value comply with the"]
#[doc = "  specifications set out by this type (optional), see"]
#[doc = "  g_param_value_validate()."]
#[doc = " @values_cmp: Compares @value1 with @value2 according to this type"]
#[doc = "  (recommended, the default is memcmp()), see g_param_values_cmp()."]
#[doc = ""]
#[doc = " The class structure for the GParamSpec type."]
#[doc = " Normally, GParamSpec classes are filled by"]
#[doc = " g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
    pub dummy: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GParamSpecClass() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecClass>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).value_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).finalize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecClass>())).value_set_default as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).value_validate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).values_cmp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(values_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).dummy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(dummy)
        )
    );
}
#[doc = " GParameter:"]
#[doc = " @name: the parameter name"]
#[doc = " @value: the parameter value"]
#[doc = ""]
#[doc = " The GParameter struct is an auxiliary structure used"]
#[doc = " to hand parameter name/value pairs to g_object_newv()."]
#[doc = ""]
#[doc = " Deprecated: 2.54: This type is not introspectable."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
#[test]
fn bindgen_test_layout__GParameter() {
    assert_eq!(
        ::std::mem::size_of::<_GParameter>(),
        32usize,
        concat!("Size of: ", stringify!(_GParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParameter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParameter>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParameter>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_ref"]
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_unref"]
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_sink"]
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_ref_sink"]
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_qdata"]
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_set_qdata"]
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_set_qdata_full"]
    pub fn g_param_spec_set_qdata_full(
        pspec: *mut GParamSpec,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_steal_qdata"]
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_redirect_target"]
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_value_set_default"]
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
}
extern "C" {
    #[link_name = "\u{1}_g_param_value_defaults"]
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_param_value_validate"]
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_param_value_convert"]
    pub fn g_param_value_convert(
        pspec: *mut GParamSpec,
        src_value: *const GValue,
        dest_value: *mut GValue,
        strict_validation: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_param_values_cmp"]
    pub fn g_param_values_cmp(
        pspec: *mut GParamSpec,
        value1: *const GValue,
        value2: *const GValue,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_name"]
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_nick"]
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_blurb"]
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_param"]
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_param"]
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_param"]
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_param"]
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_param_take_ownership"]
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_default_value"]
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_name_quark"]
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> GQuark;
}
pub type GParamSpecTypeInfo = _GParamSpecTypeInfo;
#[doc = " GParamSpecTypeInfo:"]
#[doc = " @instance_size: Size of the instance (object) structure."]
#[doc = " @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now."]
#[doc = " @instance_init: Location of the instance initialization function (optional)."]
#[doc = " @value_type: The #GType of values conforming to this #GParamSpec"]
#[doc = " @finalize: The instance finalization function (optional)."]
#[doc = " @value_set_default: Resets a @value to the default value for @pspec"]
#[doc = "  (recommended, the default is g_value_reset()), see"]
#[doc = "  g_param_value_set_default()."]
#[doc = " @value_validate: Ensures that the contents of @value comply with the"]
#[doc = "  specifications set out by @pspec (optional), see"]
#[doc = "  g_param_value_validate()."]
#[doc = " @values_cmp: Compares @value1 with @value2 according to @pspec"]
#[doc = "  (recommended, the default is memcmp()), see g_param_values_cmp()."]
#[doc = ""]
#[doc = " This structure is used to provide the type system with the information"]
#[doc = " required to initialize and destruct (finalize) a parameter's class and"]
#[doc = " instances thereof."]
#[doc = " The initialized structure is passed to the g_param_type_register_static()"]
#[doc = " The type system will perform a deep copy of this structure, so its memory"]
#[doc = " does not need to be persistent across invocation of"]
#[doc = " g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
}
#[test]
fn bindgen_test_layout__GParamSpecTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecTypeInfo>(),
        56usize,
        concat!("Size of: ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).instance_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).n_preallocs as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).instance_init as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).finalize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_set_default as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_validate as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).values_cmp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(values_cmp)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_type_register_static"]
    pub fn g_param_type_register_static(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}__g_param_type_register_static_constant"]
    pub fn _g_param_type_register_static_constant(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
        opt_type: GType,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_internal"]
    pub fn g_param_spec_internal(
        param_type: GType,
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_new"]
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_insert"]
    pub fn g_param_spec_pool_insert(
        pool: *mut GParamSpecPool,
        pspec: *mut GParamSpec,
        owner_type: GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_remove"]
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_lookup"]
    pub fn g_param_spec_pool_lookup(
        pool: *mut GParamSpecPool,
        param_name: *const gchar,
        owner_type: GType,
        walk_ancestors: gboolean,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_list_owned"]
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType)
        -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_list"]
    pub fn g_param_spec_pool_list(
        pool: *mut GParamSpecPool,
        owner_type: GType,
        n_pspecs_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
pub type GClosure = _GClosure;
pub type GClosureNotifyData = _GClosureNotifyData;
#[doc = " GCallback:"]
#[doc = ""]
#[doc = " The type used for callback functions in structure definitions and function"]
#[doc = " signatures. This doesn't mean that all callback functions must take no"]
#[doc = " parameters and return void. The required signature of a callback function"]
#[doc = " is determined by the context in which is used (e.g. the signal to which it"]
#[doc = " is connected). Use G_CALLBACK() to cast the callback function to a #GCallback."]
pub type GCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " GClosureNotify:"]
#[doc = " @data: data specified when registering the notification callback"]
#[doc = " @closure: the #GClosure on which the notification is emitted"]
#[doc = ""]
#[doc = " The type used for the various notification callbacks which can be registered"]
#[doc = " on closures."]
pub type GClosureNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, closure: *mut GClosure)>;
#[doc = " GClosureMarshal:"]
#[doc = " @closure: the #GClosure to which the marshaller belongs"]
#[doc = " @return_value: (nullable): a #GValue to store the return"]
#[doc = "  value. May be %NULL if the callback of @closure doesn't return a"]
#[doc = "  value."]
#[doc = " @n_param_values: the length of the @param_values array"]
#[doc = " @param_values: (array length=n_param_values): an array of"]
#[doc = "  #GValues holding the arguments on which to invoke the"]
#[doc = "  callback of @closure"]
#[doc = " @invocation_hint: (nullable): the invocation hint given as the"]
#[doc = "  last argument to g_closure_invoke()"]
#[doc = " @marshal_data: (nullable): additional data specified when"]
#[doc = "  registering the marshaller, see g_closure_set_marshal() and"]
#[doc = "  g_closure_set_meta_marshal()"]
#[doc = ""]
#[doc = " The type used for marshaller functions."]
pub type GClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    ),
>;
#[doc = " GVaClosureMarshal:"]
#[doc = " @closure: the #GClosure to which the marshaller belongs"]
#[doc = " @return_value: (nullable): a #GValue to store the return"]
#[doc = "  value. May be %NULL if the callback of @closure doesn't return a"]
#[doc = "  value."]
#[doc = " @instance: (type GObject.TypeInstance): the instance on which the closure is"]
#[doc = "  invoked."]
#[doc = " @args: va_list of arguments to be passed to the closure."]
#[doc = " @marshal_data: (nullable): additional data specified when"]
#[doc = "  registering the marshaller, see g_closure_set_marshal() and"]
#[doc = "  g_closure_set_meta_marshal()"]
#[doc = " @n_params: the length of the @param_types array"]
#[doc = " @param_types: (array length=n_params): the #GType of each argument from"]
#[doc = "  @args."]
#[doc = ""]
#[doc = " This is the signature of va_list marshaller functions, an optional"]
#[doc = " marshaller that can be used in some situations to avoid"]
#[doc = " marshalling the signal argument into GValues."]
pub type GVaClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    ),
>;
#[doc = " GCClosure:"]
#[doc = " @closure: the #GClosure"]
#[doc = " @callback: the callback function"]
#[doc = ""]
#[doc = " A #GCClosure is a specialization of #GClosure for C function callbacks."]
pub type GCClosure = _GCClosure;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
#[test]
fn bindgen_test_layout__GClosureNotifyData() {
    assert_eq!(
        ::std::mem::size_of::<_GClosureNotifyData>(),
        16usize,
        concat!("Size of: ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosureNotifyData>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosureNotifyData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosureNotifyData>())).notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(notify)
        )
    );
}
#[doc = " GClosure:"]
#[doc = " @in_marshal: Indicates whether the closure is currently being invoked with"]
#[doc = "  g_closure_invoke()"]
#[doc = " @is_invalid: Indicates whether the closure has been invalidated by"]
#[doc = "  g_closure_invalidate()"]
#[doc = ""]
#[doc = " A #GClosure represents a callback supplied by the programmer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosure {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub marshal: ::std::option::Option<
        unsafe extern "C" fn(
            closure: *mut GClosure,
            return_value: *mut GValue,
            n_param_values: guint,
            param_values: *const GValue,
            invocation_hint: gpointer,
            marshal_data: gpointer,
        ),
    >,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
#[test]
fn bindgen_test_layout__GClosure() {
    assert_eq!(
        ::std::mem::size_of::<_GClosure>(),
        32usize,
        concat!("Size of: ", stringify!(_GClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).marshal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(marshal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).notifiers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(notifiers)
        )
    );
}
impl _GClosure {
    #[inline]
    pub fn ref_count(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_ref_count(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn meta_marshal_nouse(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meta_marshal_nouse(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_guards(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_n_guards(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_fnotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_n_fnotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn n_inotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_n_inotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn in_inotify(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_inotify(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn floating(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_floating(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn derivative_flag(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_derivative_flag(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_marshal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_marshal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_invalid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_invalid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ref_count: guint,
        meta_marshal_nouse: guint,
        n_guards: guint,
        n_fnotifiers: guint,
        n_inotifiers: guint,
        in_inotify: guint,
        floating: guint,
        derivative_flag: guint,
        in_marshal: guint,
        is_invalid: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let ref_count: u32 = unsafe { ::std::mem::transmute(ref_count) };
            ref_count as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let meta_marshal_nouse: u32 = unsafe { ::std::mem::transmute(meta_marshal_nouse) };
            meta_marshal_nouse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let n_guards: u32 = unsafe { ::std::mem::transmute(n_guards) };
            n_guards as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let n_fnotifiers: u32 = unsafe { ::std::mem::transmute(n_fnotifiers) };
            n_fnotifiers as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let n_inotifiers: u32 = unsafe { ::std::mem::transmute(n_inotifiers) };
            n_inotifiers as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let in_inotify: u32 = unsafe { ::std::mem::transmute(in_inotify) };
            in_inotify as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let floating: u32 = unsafe { ::std::mem::transmute(floating) };
            floating as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let derivative_flag: u32 = unsafe { ::std::mem::transmute(derivative_flag) };
            derivative_flag as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let in_marshal: u32 = unsafe { ::std::mem::transmute(in_marshal) };
            in_marshal as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_invalid: u32 = unsafe { ::std::mem::transmute(is_invalid) };
            is_invalid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
#[test]
fn bindgen_test_layout__GCClosure() {
    assert_eq!(
        ::std::mem::size_of::<_GCClosure>(),
        40usize,
        concat!("Size of: ", stringify!(_GCClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCClosure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCClosure>())).closure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(closure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCClosure>())).callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_new"]
    pub fn g_cclosure_new(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_new_swap"]
    pub fn g_cclosure_new_swap(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_type_cclosure_new"]
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_ref"]
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_sink"]
    pub fn g_closure_sink(closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_closure_unref"]
    pub fn g_closure_unref(closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_closure_new_simple"]
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_add_finalize_notifier"]
    pub fn g_closure_add_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_remove_finalize_notifier"]
    pub fn g_closure_remove_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_add_invalidate_notifier"]
    pub fn g_closure_add_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_remove_invalidate_notifier"]
    pub fn g_closure_remove_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_add_marshal_guards"]
    pub fn g_closure_add_marshal_guards(
        closure: *mut GClosure,
        pre_marshal_data: gpointer,
        pre_marshal_notify: GClosureNotify,
        post_marshal_data: gpointer,
        post_marshal_notify: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_set_marshal"]
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
}
extern "C" {
    #[link_name = "\u{1}_g_closure_set_meta_marshal"]
    pub fn g_closure_set_meta_marshal(
        closure: *mut GClosure,
        marshal_data: gpointer,
        meta_marshal: GClosureMarshal,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_invalidate"]
    pub fn g_closure_invalidate(closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_closure_invoke"]
    pub fn g_closure_invoke(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_generic"]
    pub fn g_cclosure_marshal_generic(
        closure: *mut GClosure,
        return_gvalue: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_generic_va"]
    pub fn g_cclosure_marshal_generic_va(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args_list: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__VOID"]
    pub fn g_cclosure_marshal_VOID__VOID(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__VOIDv"]
    pub fn g_cclosure_marshal_VOID__VOIDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__BOOLEAN"]
    pub fn g_cclosure_marshal_VOID__BOOLEAN(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__BOOLEANv"]
    pub fn g_cclosure_marshal_VOID__BOOLEANv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__CHAR"]
    pub fn g_cclosure_marshal_VOID__CHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__CHARv"]
    pub fn g_cclosure_marshal_VOID__CHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UCHAR"]
    pub fn g_cclosure_marshal_VOID__UCHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UCHARv"]
    pub fn g_cclosure_marshal_VOID__UCHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__INT"]
    pub fn g_cclosure_marshal_VOID__INT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__INTv"]
    pub fn g_cclosure_marshal_VOID__INTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UINT"]
    pub fn g_cclosure_marshal_VOID__UINT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UINTv"]
    pub fn g_cclosure_marshal_VOID__UINTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__LONG"]
    pub fn g_cclosure_marshal_VOID__LONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__LONGv"]
    pub fn g_cclosure_marshal_VOID__LONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__ULONG"]
    pub fn g_cclosure_marshal_VOID__ULONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__ULONGv"]
    pub fn g_cclosure_marshal_VOID__ULONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__ENUM"]
    pub fn g_cclosure_marshal_VOID__ENUM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__ENUMv"]
    pub fn g_cclosure_marshal_VOID__ENUMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__FLAGS"]
    pub fn g_cclosure_marshal_VOID__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__FLAGSv"]
    pub fn g_cclosure_marshal_VOID__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__FLOAT"]
    pub fn g_cclosure_marshal_VOID__FLOAT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__FLOATv"]
    pub fn g_cclosure_marshal_VOID__FLOATv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__DOUBLE"]
    pub fn g_cclosure_marshal_VOID__DOUBLE(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__DOUBLEv"]
    pub fn g_cclosure_marshal_VOID__DOUBLEv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__STRING"]
    pub fn g_cclosure_marshal_VOID__STRING(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__STRINGv"]
    pub fn g_cclosure_marshal_VOID__STRINGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__PARAM"]
    pub fn g_cclosure_marshal_VOID__PARAM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__PARAMv"]
    pub fn g_cclosure_marshal_VOID__PARAMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__BOXED"]
    pub fn g_cclosure_marshal_VOID__BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__BOXEDv"]
    pub fn g_cclosure_marshal_VOID__BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__POINTER"]
    pub fn g_cclosure_marshal_VOID__POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__POINTERv"]
    pub fn g_cclosure_marshal_VOID__POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__OBJECT"]
    pub fn g_cclosure_marshal_VOID__OBJECT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__OBJECTv"]
    pub fn g_cclosure_marshal_VOID__OBJECTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__VARIANT"]
    pub fn g_cclosure_marshal_VOID__VARIANT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__VARIANTv"]
    pub fn g_cclosure_marshal_VOID__VARIANTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UINT_POINTER"]
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UINT_POINTERv"]
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_BOOLEAN__FLAGS"]
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_BOOLEAN__FLAGSv"]
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_STRING__OBJECT_POINTER"]
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_STRING__OBJECT_POINTERv"]
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_BOOLEAN__BOXED_BOXED"]
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv"]
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
pub type GSignalQuery = _GSignalQuery;
pub type GSignalInvocationHint = _GSignalInvocationHint;
#[doc = " GSignalCMarshaller:"]
#[doc = ""]
#[doc = " This is the signature of marshaller functions, required to marshall"]
#[doc = " arrays of parameter values to signal emissions into C language callback"]
#[doc = " invocations. It is merely an alias to #GClosureMarshal since the #GClosure"]
#[doc = " mechanism takes over responsibility of actual function invocation for the"]
#[doc = " signal system."]
pub type GSignalCMarshaller = GClosureMarshal;
#[doc = " GSignalCVaMarshaller:"]
#[doc = ""]
#[doc = " This is the signature of va_list marshaller functions, an optional"]
#[doc = " marshaller that can be used in some situations to avoid"]
#[doc = " marshalling the signal argument into GValues."]
pub type GSignalCVaMarshaller = GVaClosureMarshal;
#[doc = " GSignalEmissionHook:"]
#[doc = " @ihint: Signal invocation hint, see #GSignalInvocationHint."]
#[doc = " @n_param_values: the number of parameters to the function, including"]
#[doc = "  the instance on which the signal was emitted."]
#[doc = " @param_values: (array length=n_param_values): the instance on which"]
#[doc = "  the signal was emitted, followed by the parameters of the emission."]
#[doc = " @data: user data associated with the hook."]
#[doc = ""]
#[doc = " A simple function pointer to get invoked when the signal is emitted. This"]
#[doc = " allows you to tie a hook to the signal type, so that it will trap all"]
#[doc = " emissions of that signal, from any object."]
#[doc = ""]
#[doc = " You may not attach these to signals created with the #G_SIGNAL_NO_HOOKS flag."]
#[doc = ""]
#[doc = " Returns: whether it wants to stay connected. If it returns %FALSE, the signal"]
#[doc = "  hook is disconnected (and destroyed)."]
pub type GSignalEmissionHook = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        n_param_values: guint,
        param_values: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSignalAccumulator:"]
#[doc = " @ihint: Signal invocation hint, see #GSignalInvocationHint."]
#[doc = " @return_accu: Accumulator to collect callback return values in, this"]
#[doc = "  is the return value of the current signal emission."]
#[doc = " @handler_return: A #GValue holding the return value of the signal handler."]
#[doc = " @data: Callback data that was specified when creating the signal."]
#[doc = ""]
#[doc = " The signal accumulator is a special callback function that can be used"]
#[doc = " to collect return values of the various callbacks that are called"]
#[doc = " during a signal emission. The signal accumulator is specified at signal"]
#[doc = " creation time, if it is left %NULL, no accumulation of callback return"]
#[doc = " values is performed. The return value of signal emissions is then the"]
#[doc = " value returned by the last callback."]
#[doc = ""]
#[doc = " Returns: The accumulator function returns whether the signal emission"]
#[doc = "  should be aborted. Returning %FALSE means to abort the"]
#[doc = "  current emission and %TRUE is returned for continuation."]
pub type GSignalAccumulator = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(u32)]
#[doc = " GSignalFlags:"]
#[doc = " @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage."]
#[doc = " @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage."]
#[doc = " @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage."]
#[doc = " @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in"]
#[doc = "  emission for this very object will not be emitted recursively,"]
#[doc = "  but instead cause the first emission to be restarted."]
#[doc = " @G_SIGNAL_DETAILED: This signal supports \"::detail\" appendices to the signal name"]
#[doc = "  upon handler connections and emissions."]
#[doc = " @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive"]
#[doc = "  objects from user code via g_signal_emit() and friends, without"]
#[doc = "  the need of being embedded into extra code that performs pre or"]
#[doc = "  post emission adjustments on the object. They can also be thought"]
#[doc = "  of as object methods which can be called generically by"]
#[doc = "  third-party code."]
#[doc = " @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal."]
#[doc = " @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the"]
#[doc = "   arguments, even if there are no signal handlers connected.  Since 2.30."]
#[doc = " @G_SIGNAL_DEPRECATED: The signal is deprecated and will be removed"]
#[doc = "   in a future version. A warning will be generated if it is connected while"]
#[doc = "   running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32."]
#[doc = ""]
#[doc = " The signal flags are used to specify a signal's behaviour, the overall"]
#[doc = " signal description outlines how especially the RUN flags control the"]
#[doc = " stages of a signal emission."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GSignalFlags {
    G_SIGNAL_RUN_FIRST = 1,
    G_SIGNAL_RUN_LAST = 2,
    G_SIGNAL_RUN_CLEANUP = 4,
    G_SIGNAL_NO_RECURSE = 8,
    G_SIGNAL_DETAILED = 16,
    G_SIGNAL_ACTION = 32,
    G_SIGNAL_NO_HOOKS = 64,
    G_SIGNAL_MUST_COLLECT = 128,
    G_SIGNAL_DEPRECATED = 256,
}
#[repr(u32)]
#[doc = " GConnectFlags:"]
#[doc = " @G_CONNECT_AFTER: whether the handler should be called before or after the"]
#[doc = "  default handler of the signal."]
#[doc = " @G_CONNECT_SWAPPED: whether the instance and data should be swapped when"]
#[doc = "  calling the handler; see g_signal_connect_swapped() for an example."]
#[doc = ""]
#[doc = " The connection flags are used to specify the behaviour of a signal's"]
#[doc = " connection."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GConnectFlags {
    G_CONNECT_AFTER = 1,
    G_CONNECT_SWAPPED = 2,
}
#[repr(u32)]
#[doc = " GSignalMatchType:"]
#[doc = " @G_SIGNAL_MATCH_ID: The signal id must be equal."]
#[doc = " @G_SIGNAL_MATCH_DETAIL: The signal detail be equal."]
#[doc = " @G_SIGNAL_MATCH_CLOSURE: The closure must be the same."]
#[doc = " @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same."]
#[doc = " @G_SIGNAL_MATCH_DATA: The closure data must be the same."]
#[doc = " @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may matched."]
#[doc = ""]
#[doc = " The match types specify what g_signal_handlers_block_matched(),"]
#[doc = " g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()"]
#[doc = " match signals by."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GSignalMatchType {
    G_SIGNAL_MATCH_ID = 1,
    G_SIGNAL_MATCH_DETAIL = 2,
    G_SIGNAL_MATCH_CLOSURE = 4,
    G_SIGNAL_MATCH_FUNC = 8,
    G_SIGNAL_MATCH_DATA = 16,
    G_SIGNAL_MATCH_UNBLOCKED = 32,
}
#[doc = " GSignalInvocationHint:"]
#[doc = " @signal_id: The signal id of the signal invoking the callback"]
#[doc = " @detail: The detail passed on for this emission"]
#[doc = " @run_type: The stage the signal emission is currently in, this"]
#[doc = "  field will contain one of %G_SIGNAL_RUN_FIRST,"]
#[doc = "  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP."]
#[doc = ""]
#[doc = " The #GSignalInvocationHint structure is used to pass on additional information"]
#[doc = " to callbacks during a signal emission."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
#[test]
fn bindgen_test_layout__GSignalInvocationHint() {
    assert_eq!(
        ::std::mem::size_of::<_GSignalInvocationHint>(),
        12usize,
        concat!("Size of: ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalInvocationHint>(),
        4usize,
        concat!("Alignment of ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSignalInvocationHint>())).signal_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalInvocationHint>())).detail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalInvocationHint>())).run_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(run_type)
        )
    );
}
#[doc = " GSignalQuery:"]
#[doc = " @signal_id: The signal id of the signal being queried, or 0 if the"]
#[doc = "  signal to be queried was unknown."]
#[doc = " @signal_name: The signal name."]
#[doc = " @itype: The interface/instance type that this signal can be emitted for."]
#[doc = " @signal_flags: The signal flags as passed in to g_signal_new()."]
#[doc = " @return_type: The return type for user callbacks."]
#[doc = " @n_params: The number of parameters that user callbacks take."]
#[doc = " @param_types: (array length=n_params): The individual parameter types for"]
#[doc = "  user callbacks, note that the effective callback signature is:"]
#[doc = "  |[<!-- language=\"C\" -->"]
#[doc = "  @return_type callback (#gpointer     data1,"]
#[doc = "  [param_types param_names,]"]
#[doc = "  gpointer     data2);"]
#[doc = "  ]|"]
#[doc = ""]
#[doc = " A structure holding in-depth information for a specific signal. It is"]
#[doc = " filled in by the g_signal_query() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
#[test]
fn bindgen_test_layout__GSignalQuery() {
    assert_eq!(
        ::std::mem::size_of::<_GSignalQuery>(),
        56usize,
        concat!("Size of: ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).itype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).return_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).n_params as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(n_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).param_types as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(param_types)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_newv"]
    pub fn g_signal_newv(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        param_types: *mut GType,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_new_valist"]
    pub fn g_signal_new_valist(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        args: *mut __va_list_tag,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_new"]
    pub fn g_signal_new(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_offset: guint,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_new_class_handler"]
    pub fn g_signal_new_class_handler(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_handler: GCallback,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_set_va_marshaller"]
    pub fn g_signal_set_va_marshaller(
        signal_id: guint,
        instance_type: GType,
        va_marshaller: GSignalCVaMarshaller,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_emitv"]
    pub fn g_signal_emitv(
        instance_and_params: *const GValue,
        signal_id: guint,
        detail: GQuark,
        return_value: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_emit_valist"]
    pub fn g_signal_emit_valist(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_emit"]
    pub fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_emit_by_name"]
    pub fn g_signal_emit_by_name(instance: gpointer, detailed_signal: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_lookup"]
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_name"]
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_query"]
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_list_ids"]
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_parse_name"]
    pub fn g_signal_parse_name(
        detailed_signal: *const gchar,
        itype: GType,
        signal_id_p: *mut guint,
        detail_p: *mut GQuark,
        force_detail_quark: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_get_invocation_hint"]
    pub fn g_signal_get_invocation_hint(instance: gpointer) -> *mut GSignalInvocationHint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_stop_emission"]
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_stop_emission_by_name"]
    pub fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_add_emission_hook"]
    pub fn g_signal_add_emission_hook(
        signal_id: guint,
        detail: GQuark,
        hook_func: GSignalEmissionHook,
        hook_data: gpointer,
        data_destroy: GDestroyNotify,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_remove_emission_hook"]
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_has_handler_pending"]
    pub fn g_signal_has_handler_pending(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        may_be_blocked: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_connect_closure_by_id"]
    pub fn g_signal_connect_closure_by_id(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_connect_closure"]
    pub fn g_signal_connect_closure(
        instance: gpointer,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_connect_data"]
    pub fn g_signal_connect_data(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        destroy_data: GClosureNotify,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_block"]
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_unblock"]
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_disconnect"]
    pub fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_is_connected"]
    pub fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_find"]
    pub fn g_signal_handler_find(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handlers_block_matched"]
    pub fn g_signal_handlers_block_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handlers_unblock_matched"]
    pub fn g_signal_handlers_unblock_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handlers_disconnect_matched"]
    pub fn g_signal_handlers_disconnect_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_override_class_closure"]
    pub fn g_signal_override_class_closure(
        signal_id: guint,
        instance_type: GType,
        class_closure: *mut GClosure,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_override_class_handler"]
    pub fn g_signal_override_class_handler(
        signal_name: *const gchar,
        instance_type: GType,
        class_handler: GCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_chain_from_overridden"]
    pub fn g_signal_chain_from_overridden(
        instance_and_params: *const GValue,
        return_value: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_chain_from_overridden_handler"]
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_accumulator_true_handled"]
    pub fn g_signal_accumulator_true_handled(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_accumulator_first_wins"]
    pub fn g_signal_accumulator_first_wins(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handlers_destroy"]
    pub fn g_signal_handlers_destroy(instance: gpointer);
}
extern "C" {
    #[link_name = "\u{1}__g_signals_destroy"]
    pub fn _g_signals_destroy(itype: GType);
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_type"]
    pub fn g_date_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_strv_get_type"]
    pub fn g_strv_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_gstring_get_type"]
    pub fn g_gstring_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_get_type"]
    pub fn g_hash_table_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_array_get_type"]
    pub fn g_array_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_get_type"]
    pub fn g_byte_array_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_get_type"]
    pub fn g_ptr_array_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_get_type"]
    pub fn g_bytes_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_get_gtype"]
    pub fn g_variant_type_get_gtype() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_type"]
    pub fn g_regex_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_get_type"]
    pub fn g_match_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_error_get_type"]
    pub fn g_error_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_type"]
    pub fn g_date_time_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_get_type"]
    pub fn g_time_zone_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_type"]
    pub fn g_io_channel_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_condition_get_type"]
    pub fn g_io_condition_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_get_type"]
    pub fn g_variant_builder_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_get_type"]
    pub fn g_variant_dict_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_type"]
    pub fn g_key_file_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_get_type"]
    pub fn g_main_loop_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_get_type"]
    pub fn g_main_context_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_type"]
    pub fn g_source_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_pollfd_get_type"]
    pub fn g_pollfd_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_get_type"]
    pub fn g_thread_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_get_type"]
    pub fn g_checksum_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_type"]
    pub fn g_markup_parse_context_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_get_type"]
    pub fn g_mapped_file_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_get_type"]
    pub fn g_option_group_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_gtype"]
    pub fn g_variant_get_gtype() -> GType;
}
#[doc = " GBoxedCopyFunc:"]
#[doc = " @boxed: (not nullable): The boxed structure to be copied."]
#[doc = ""]
#[doc = " This function is provided by the user and should produce a copy"]
#[doc = " of the passed in boxed structure."]
#[doc = ""]
#[doc = " Returns: (not nullable): The newly created copy of the boxed structure."]
pub type GBoxedCopyFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer) -> gpointer>;
#[doc = " GBoxedFreeFunc:"]
#[doc = " @boxed: (not nullable): The boxed structure to be freed."]
#[doc = ""]
#[doc = " This function is provided by the user and should free the boxed"]
#[doc = " structure passed."]
pub type GBoxedFreeFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer)>;
extern "C" {
    #[link_name = "\u{1}_g_boxed_copy"]
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_boxed_free"]
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_boxed"]
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_static_boxed"]
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_boxed"]
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_boxed_take_ownership"]
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_boxed"]
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_boxed"]
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_boxed_type_register_static"]
    pub fn g_boxed_type_register_static(
        name: *const gchar,
        boxed_copy: GBoxedCopyFunc,
        boxed_free: GBoxedFreeFunc,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_get_type"]
    pub fn g_closure_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_type"]
    pub fn g_value_get_type() -> GType;
}
pub type GObject = _GObject;
pub type GObjectClass = _GObjectClass;
pub type GInitiallyUnowned = _GObject;
pub type GInitiallyUnownedClass = _GObjectClass;
pub type GObjectConstructParam = _GObjectConstructParam;
#[doc = " GObjectGetPropertyFunc:"]
#[doc = " @object: a #GObject"]
#[doc = " @property_id: the numeric id under which the property was registered with"]
#[doc = "  g_object_class_install_property()."]
#[doc = " @value: a #GValue to return the property value in"]
#[doc = " @pspec: the #GParamSpec describing the property"]
#[doc = ""]
#[doc = " The type of the @get_property function of #GObjectClass."]
pub type GObjectGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectSetPropertyFunc:"]
#[doc = " @object: a #GObject"]
#[doc = " @property_id: the numeric id under which the property was registered with"]
#[doc = "  g_object_class_install_property()."]
#[doc = " @value: the new value for the property"]
#[doc = " @pspec: the #GParamSpec describing the property"]
#[doc = ""]
#[doc = " The type of the @set_property function of #GObjectClass."]
pub type GObjectSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectFinalizeFunc:"]
#[doc = " @object: the #GObject being finalized"]
#[doc = ""]
#[doc = " The type of the @finalize function of #GObjectClass."]
pub type GObjectFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>;
#[doc = " GWeakNotify:"]
#[doc = " @data: data that was provided when the weak reference was established"]
#[doc = " @where_the_object_was: the object being finalized"]
#[doc = ""]
#[doc = " A #GWeakNotify function can be added to an object as a callback that gets"]
#[doc = " triggered when the object is finalized. Since the object is already being"]
#[doc = " finalized when the #GWeakNotify is called, there's not much you could do"]
#[doc = " with the object, apart from e.g. using its address as hash-index or the like."]
pub type GWeakNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, where_the_object_was: *mut GObject)>;
#[doc = " GObject:"]
#[doc = ""]
#[doc = " All the fields in the GObject structure are private"]
#[doc = " to the #GObject implementation and should never be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).ref_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).qdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
#[doc = " GObjectClass:"]
#[doc = " @g_type_class: the parent class"]
#[doc = " @constructor: the @constructor function is called by g_object_new () to"]
#[doc = "  complete the object initialization after all the construction properties are"]
#[doc = "  set. The first thing a @constructor implementation must do is chain up to the"]
#[doc = "  @constructor of the parent class. Overriding @constructor should be rarely"]
#[doc = "  needed, e.g. to handle construct properties, or to implement singletons."]
#[doc = " @set_property: the generic setter for all properties of this type. Should be"]
#[doc = "  overridden for every type with properties. If implementations of"]
#[doc = "  @set_property don't emit property change notification explicitly, this will"]
#[doc = "  be done implicitly by the type system. However, if the notify signal is"]
#[doc = "  emitted explicitly, the type system will not emit it a second time."]
#[doc = " @get_property: the generic getter for all properties of this type. Should be"]
#[doc = "  overridden for every type with properties."]
#[doc = " @dispose: the @dispose function is supposed to drop all references to other"]
#[doc = "  objects, but keep the instance otherwise intact, so that client method"]
#[doc = "  invocations still work. It may be run multiple times (due to reference"]
#[doc = "  loops). Before returning, @dispose should chain up to the @dispose method"]
#[doc = "  of the parent class."]
#[doc = " @finalize: instance finalization function, should finish the finalization of"]
#[doc = "  the instance begun in @dispose and chain up to the @finalize method of the"]
#[doc = "  parent class."]
#[doc = " @dispatch_properties_changed: emits property change notification for a bunch"]
#[doc = "  of properties. Overriding @dispatch_properties_changed should be rarely"]
#[doc = "  needed."]
#[doc = " @notify: the class closure for the notify signal"]
#[doc = " @constructed: the @constructed function is called by g_object_new() as the"]
#[doc = "  final step of the object creation process.  At the point of the call, all"]
#[doc = "  construction properties have been set on the object.  The purpose of this"]
#[doc = "  call is to allow for object initialisation steps that can only be performed"]
#[doc = "  after construction properties have been set.  @constructed implementors"]
#[doc = "  should chain up to the @constructed call of their parent class to allow it"]
#[doc = "  to complete its initialisation."]
#[doc = ""]
#[doc = " The class structure for the GObject type."]
#[doc = ""]
#[doc = " |[<!-- language=\"C\" -->"]
#[doc = " // Example of implementing a singleton using a constructor."]
#[doc = " static MySingleton *the_singleton = NULL;"]
#[doc = ""]
#[doc = " static GObject*"]
#[doc = " my_singleton_constructor (GType                  type,"]
#[doc = "                           guint                  n_construct_params,"]
#[doc = "                           GObjectConstructParam *construct_params)"]
#[doc = " {"]
#[doc = "   GObject *object;"]
#[doc = ""]
#[doc = "   if (!the_singleton)"]
#[doc = "     {"]
#[doc = "       object = G_OBJECT_CLASS (parent_class)->constructor (type,"]
#[doc = "                                                            n_construct_params,"]
#[doc = "                                                            construct_params);"]
#[doc = "       the_singleton = MY_SINGLETON (object);"]
#[doc = "     }"]
#[doc = "   else"]
#[doc = "     object = g_object_ref (G_OBJECT (the_singleton));"]
#[doc = ""]
#[doc = "   return object;"]
#[doc = " }"]
#[doc = " ]|"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(
            type_: GType,
            n_construct_properties: guint,
            construct_properties: *mut GObjectConstructParam,
        ) -> *mut GObject,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *const GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub get_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *mut GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec),
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub pdummy: [gpointer; 6usize],
}
#[test]
fn bindgen_test_layout__GObjectClass() {
    assert_eq!(
        ::std::mem::size_of::<_GObjectClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GObjectClass>())).construct_properties as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(construct_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).constructor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).set_property as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).get_property as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).dispose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).finalize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GObjectClass>())).dispatch_properties_changed as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispatch_properties_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).notify as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).constructed as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).pdummy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(pdummy)
        )
    );
}
#[doc = " GObjectConstructParam:"]
#[doc = " @pspec: the #GParamSpec of the construct parameter"]
#[doc = " @value: the value to set the parameter to"]
#[doc = ""]
#[doc = " The GObjectConstructParam struct is an auxiliary"]
#[doc = " structure used to hand #GParamSpec/#GValue pairs to the @constructor of"]
#[doc = " a #GObjectClass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[test]
fn bindgen_test_layout__GObjectConstructParam() {
    assert_eq!(
        ::std::mem::size_of::<_GObjectConstructParam>(),
        16usize,
        concat!("Size of: ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectConstructParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectConstructParam>())).pspec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(pspec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectConstructParam>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " GInitiallyUnowned:"]
    #[doc = ""]
    #[doc = " All the fields in the GInitiallyUnowned structure"]
    #[doc = " are private to the #GInitiallyUnowned implementation and should never be"]
    #[doc = " accessed directly."]
    #[doc = " GInitiallyUnownedClass:"]
    #[doc = ""]
    #[doc = " The class structure for the GInitiallyUnowned type."]
    #[link_name = "\u{1}_g_initially_unowned_get_type"]
    pub fn g_initially_unowned_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_install_property"]
    pub fn g_object_class_install_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        pspec: *mut GParamSpec,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_find_property"]
    pub fn g_object_class_find_property(
        oclass: *mut GObjectClass,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_list_properties"]
    pub fn g_object_class_list_properties(
        oclass: *mut GObjectClass,
        n_properties: *mut guint,
    ) -> *mut *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_override_property"]
    pub fn g_object_class_override_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        name: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_install_properties"]
    pub fn g_object_class_install_properties(
        oclass: *mut GObjectClass,
        n_pspecs: guint,
        pspecs: *mut *mut GParamSpec,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_interface_install_property"]
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_object_interface_find_property"]
    pub fn g_object_interface_find_property(
        g_iface: gpointer,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_object_interface_list_properties"]
    pub fn g_object_interface_list_properties(
        g_iface: gpointer,
        n_properties_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_type"]
    pub fn g_object_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_object_new"]
    pub fn g_object_new(object_type: GType, first_property_name: *const gchar, ...) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_new_with_properties"]
    pub fn g_object_new_with_properties(
        object_type: GType,
        n_properties: guint,
        names: *mut *const ::std::os::raw::c_char,
        values: *const GValue,
    ) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_object_newv"]
    pub fn g_object_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_new_valist"]
    pub fn g_object_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_object_set"]
    pub fn g_object_set(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_object_get"]
    pub fn g_object_get(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_object_connect"]
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_disconnect"]
    pub fn g_object_disconnect(object: gpointer, signal_spec: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_object_setv"]
    pub fn g_object_setv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *const GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_valist"]
    pub fn g_object_set_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_getv"]
    pub fn g_object_getv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_valist"]
    pub fn g_object_get_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_property"]
    pub fn g_object_set_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *const GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_property"]
    pub fn g_object_get_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_freeze_notify"]
    pub fn g_object_freeze_notify(object: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_g_object_notify"]
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_object_notify_by_pspec"]
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_object_thaw_notify"]
    pub fn g_object_thaw_notify(object: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_g_object_is_floating"]
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_object_ref_sink"]
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_ref"]
    pub fn g_object_ref(object: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_unref"]
    pub fn g_object_unref(object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_weak_ref"]
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_weak_unref"]
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_add_weak_pointer"]
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_remove_weak_pointer"]
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
#[doc = " GToggleNotify:"]
#[doc = " @data: Callback data passed to g_object_add_toggle_ref()"]
#[doc = " @object: The object on which g_object_add_toggle_ref() was called."]
#[doc = " @is_last_ref: %TRUE if the toggle reference is now the"]
#[doc = "  last reference to the object. %FALSE if the toggle"]
#[doc = "  reference was the last reference and there are now other"]
#[doc = "  references."]
#[doc = ""]
#[doc = " A callback function used for notification when the state"]
#[doc = " of a toggle reference changes. See g_object_add_toggle_ref()."]
pub type GToggleNotify = ::std::option::Option<
    unsafe extern "C" fn(data: gpointer, object: *mut GObject, is_last_ref: gboolean),
>;
extern "C" {
    #[link_name = "\u{1}_g_object_add_toggle_ref"]
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_remove_toggle_ref"]
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_qdata"]
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_qdata"]
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_qdata_full"]
    pub fn g_object_set_qdata_full(
        object: *mut GObject,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_steal_qdata"]
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_dup_qdata"]
    pub fn g_object_dup_qdata(
        object: *mut GObject,
        quark: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_replace_qdata"]
    pub fn g_object_replace_qdata(
        object: *mut GObject,
        quark: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_data"]
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_data"]
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_data_full"]
    pub fn g_object_set_data_full(
        object: *mut GObject,
        key: *const gchar,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_steal_data"]
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_dup_data"]
    pub fn g_object_dup_data(
        object: *mut GObject,
        key: *const gchar,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_replace_data"]
    pub fn g_object_replace_data(
        object: *mut GObject,
        key: *const gchar,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_object_watch_closure"]
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_new_object"]
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_new_object_swap"]
    pub fn g_cclosure_new_object_swap(
        callback_func: GCallback,
        object: *mut GObject,
    ) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_new_object"]
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_object"]
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_object"]
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_object"]
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_connect_object"]
    pub fn g_signal_connect_object(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        gobject: gpointer,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_object_force_floating"]
    pub fn g_object_force_floating(object: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_g_object_run_dispose"]
    pub fn g_object_run_dispose(object: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_object"]
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_object_take_ownership"]
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_compat_control"]
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_clear_object"]
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GWeakRef {
    pub priv_: GWeakRef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GWeakRef__bindgen_ty_1 {
    pub p: gpointer,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_GWeakRef__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GWeakRef__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_GWeakRef() {
    assert_eq!(
        ::std::mem::size_of::<GWeakRef>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GWeakRef>())).priv_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_weak_ref_init"]
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_weak_ref_clear"]
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
}
extern "C" {
    #[link_name = "\u{1}_g_weak_ref_get"]
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_weak_ref_set"]
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBinding {
    _unused: [u8; 0],
}
#[doc = " GBinding:"]
#[doc = ""]
#[doc = " GBinding is an opaque structure whose members"]
#[doc = " cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GBinding = _GBinding;
#[doc = " GBindingTransformFunc:"]
#[doc = " @binding: a #GBinding"]
#[doc = " @from_value: the #GValue containing the value to transform"]
#[doc = " @to_value: the #GValue in which to store the transformed value"]
#[doc = " @user_data: data passed to the transform function"]
#[doc = ""]
#[doc = " A function to be called to transform @from_value to @to_value. If"]
#[doc = " this is the @transform_to function of a binding, then @from_value"]
#[doc = " is the @source_property on the @source object, and @to_value is the"]
#[doc = " @target_property on the @target object. If this is the"]
#[doc = " @transform_from function of a %G_BINDING_BIDIRECTIONAL binding,"]
#[doc = " then those roles are reversed."]
#[doc = ""]
#[doc = " Returns: %TRUE if the transformation was successful, and %FALSE"]
#[doc = "   otherwise"]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GBindingTransformFunc = ::std::option::Option<
    unsafe extern "C" fn(
        binding: *mut GBinding,
        from_value: *const GValue,
        to_value: *mut GValue,
        user_data: gpointer,
    ) -> gboolean,
>;
#[repr(u32)]
#[doc = " GBindingFlags:"]
#[doc = " @G_BINDING_DEFAULT: The default binding; if the source property"]
#[doc = "   changes, the target property is updated with its value."]
#[doc = " @G_BINDING_BIDIRECTIONAL: Bidirectional binding; if either the"]
#[doc = "   property of the source or the property of the target changes,"]
#[doc = "   the other is updated."]
#[doc = " @G_BINDING_SYNC_CREATE: Synchronize the values of the source and"]
#[doc = "   target properties when creating the binding; the direction of"]
#[doc = "   the synchronization is always from the source to the target."]
#[doc = " @G_BINDING_INVERT_BOOLEAN: If the two properties being bound are"]
#[doc = "   booleans, setting one to %TRUE will result in the other being"]
#[doc = "   set to %FALSE and vice versa. This flag will only work for"]
#[doc = "   boolean properties, and cannot be used when passing custom"]
#[doc = "   transformation functions to g_object_bind_property_full()."]
#[doc = ""]
#[doc = " Flags to be passed to g_object_bind_property() or"]
#[doc = " g_object_bind_property_full()."]
#[doc = ""]
#[doc = " This enumeration can be extended at later date."]
#[doc = ""]
#[doc = " Since: 2.26"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GBindingFlags {
    G_BINDING_DEFAULT = 0,
    G_BINDING_BIDIRECTIONAL = 1,
    G_BINDING_SYNC_CREATE = 2,
    G_BINDING_INVERT_BOOLEAN = 4,
}
extern "C" {
    #[link_name = "\u{1}_g_binding_flags_get_type"]
    pub fn g_binding_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_type"]
    pub fn g_binding_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_flags"]
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_source"]
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_target"]
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_source_property"]
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_target_property"]
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_unbind"]
    pub fn g_binding_unbind(binding: *mut GBinding);
}
extern "C" {
    #[link_name = "\u{1}_g_object_bind_property"]
    pub fn g_object_bind_property(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    ) -> *mut GBinding;
}
extern "C" {
    #[link_name = "\u{1}_g_object_bind_property_full"]
    pub fn g_object_bind_property_full(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GBinding;
}
extern "C" {
    #[link_name = "\u{1}_g_object_bind_property_with_closures"]
    pub fn g_object_bind_property_with_closures(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    ) -> *mut GBinding;
}
pub type GEnumClass = _GEnumClass;
pub type GFlagsClass = _GFlagsClass;
pub type GEnumValue = _GEnumValue;
pub type GFlagsValue = _GFlagsValue;
#[doc = " GEnumClass:"]
#[doc = " @g_type_class: the parent class"]
#[doc = " @minimum: the smallest possible value."]
#[doc = " @maximum: the largest possible value."]
#[doc = " @n_values: the number of possible values."]
#[doc = " @values: an array of #GEnumValue structs describing the"]
#[doc = "  individual values."]
#[doc = ""]
#[doc = " The class of an enumeration type holds information about its"]
#[doc = " possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
#[test]
fn bindgen_test_layout__GEnumClass() {
    assert_eq!(
        ::std::mem::size_of::<_GEnumClass>(),
        32usize,
        concat!("Size of: ", stringify!(_GEnumClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).minimum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).maximum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).n_values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).values as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(values)
        )
    );
}
#[doc = " GFlagsClass:"]
#[doc = " @g_type_class: the parent class"]
#[doc = " @mask: a mask covering all possible values."]
#[doc = " @n_values: the number of possible values."]
#[doc = " @values: an array of #GFlagsValue structs describing the"]
#[doc = "  individual values."]
#[doc = ""]
#[doc = " The class of a flags type holds information about its"]
#[doc = " possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
#[test]
fn bindgen_test_layout__GFlagsClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFlagsClass>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).n_values as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(values)
        )
    );
}
#[doc = " GEnumValue:"]
#[doc = " @value: the enum value"]
#[doc = " @value_name: the name of the value"]
#[doc = " @value_nick: the nickname of the value"]
#[doc = ""]
#[doc = " A structure which contains a single enum value, its name, and its"]
#[doc = " nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GEnumValue() {
    assert_eq!(
        ::std::mem::size_of::<_GEnumValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GEnumValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value_nick as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_nick)
        )
    );
}
#[doc = " GFlagsValue:"]
#[doc = " @value: the flags value"]
#[doc = " @value_name: the name of the value"]
#[doc = " @value_nick: the nickname of the value"]
#[doc = ""]
#[doc = " A structure which contains a single flags value, its name, and its"]
#[doc = " nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GFlagsValue() {
    assert_eq!(
        ::std::mem::size_of::<_GFlagsValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value_nick as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_nick)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_enum_get_value"]
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint) -> *mut GEnumValue;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_get_value_by_name"]
    pub fn g_enum_get_value_by_name(
        enum_class: *mut GEnumClass,
        name: *const gchar,
    ) -> *mut GEnumValue;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_get_value_by_nick"]
    pub fn g_enum_get_value_by_nick(
        enum_class: *mut GEnumClass,
        nick: *const gchar,
    ) -> *mut GEnumValue;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_get_first_value"]
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: guint)
        -> *mut GFlagsValue;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_get_value_by_name"]
    pub fn g_flags_get_value_by_name(
        flags_class: *mut GFlagsClass,
        name: *const gchar,
    ) -> *mut GFlagsValue;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_get_value_by_nick"]
    pub fn g_flags_get_value_by_nick(
        flags_class: *mut GFlagsClass,
        nick: *const gchar,
    ) -> *mut GFlagsValue;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_to_string"]
    pub fn g_enum_to_string(g_enum_type: GType, value: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_to_string"]
    pub fn g_flags_to_string(flags_type: GType, value: guint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_enum"]
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_enum"]
    pub fn g_value_get_enum(value: *const GValue) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_flags"]
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_flags"]
    pub fn g_value_get_flags(value: *const GValue) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_register_static"]
    pub fn g_enum_register_static(
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_register_static"]
    pub fn g_flags_register_static(
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_complete_type_info"]
    pub fn g_enum_complete_type_info(
        g_enum_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GEnumValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_flags_complete_type_info"]
    pub fn g_flags_complete_type_info(
        g_flags_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GFlagsValue,
    );
}
pub type GParamSpecChar = _GParamSpecChar;
pub type GParamSpecUChar = _GParamSpecUChar;
pub type GParamSpecBoolean = _GParamSpecBoolean;
pub type GParamSpecInt = _GParamSpecInt;
pub type GParamSpecUInt = _GParamSpecUInt;
pub type GParamSpecLong = _GParamSpecLong;
pub type GParamSpecULong = _GParamSpecULong;
pub type GParamSpecInt64 = _GParamSpecInt64;
pub type GParamSpecUInt64 = _GParamSpecUInt64;
pub type GParamSpecUnichar = _GParamSpecUnichar;
pub type GParamSpecEnum = _GParamSpecEnum;
pub type GParamSpecFlags = _GParamSpecFlags;
pub type GParamSpecFloat = _GParamSpecFloat;
pub type GParamSpecDouble = _GParamSpecDouble;
pub type GParamSpecString = _GParamSpecString;
pub type GParamSpecParam = _GParamSpecParam;
pub type GParamSpecBoxed = _GParamSpecBoxed;
pub type GParamSpecPointer = _GParamSpecPointer;
pub type GParamSpecValueArray = _GParamSpecValueArray;
pub type GParamSpecObject = _GParamSpecObject;
pub type GParamSpecOverride = _GParamSpecOverride;
pub type GParamSpecGType = _GParamSpecGType;
pub type GParamSpecVariant = _GParamSpecVariant;
#[doc = " GParamSpecChar:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
#[test]
fn bindgen_test_layout__GParamSpecChar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).maximum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).default_value as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUChar:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
#[test]
fn bindgen_test_layout__GParamSpecUChar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecUChar>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).maximum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).default_value as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecBoolean:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for boolean properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
#[test]
fn bindgen_test_layout__GParamSpecBoolean() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoolean>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecBoolean>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecBoolean>())).default_value as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecInt:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecInt() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUInt:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecLong:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
#[test]
fn bindgen_test_layout__GParamSpecLong() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecLong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecLong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecULong:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
#[test]
fn bindgen_test_layout__GParamSpecULong() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecULong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecULong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecULong>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecInt64:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
#[test]
fn bindgen_test_layout__GParamSpecInt64() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecInt64>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUInt64:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt64() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecUInt64>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUnichar:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
#[test]
fn bindgen_test_layout__GParamSpecUnichar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUnichar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUnichar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecUnichar>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecUnichar>())).default_value as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecEnum:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @enum_class: the #GEnumClass for the enum"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for enum"]
#[doc = " properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecEnum() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecEnum>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecEnum>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).enum_class as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(enum_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecFlags:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @flags_class: the #GFlagsClass for the flags"]
#[doc = " @default_value: default value for the property specified"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for flags"]
#[doc = " properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecFlags() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFlags>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecFlags>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFlags>())).flags_class as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(flags_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFlags>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecFloat:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = " @epsilon: values closer than @epsilon will be considered identical"]
#[doc = "  by g_param_values_cmp(); the default value is 1e-30."]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for float properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
#[test]
fn bindgen_test_layout__GParamSpecFloat() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFloat>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecFloat>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).epsilon as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(epsilon)
        )
    );
}
#[doc = " GParamSpecDouble:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @minimum: minimum value for the property specified"]
#[doc = " @maximum: maximum value for the property specified"]
#[doc = " @default_value: default value for the property specified"]
#[doc = " @epsilon: values closer than @epsilon will be considered identical"]
#[doc = "  by g_param_values_cmp(); the default value is 1e-90."]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for double properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
#[test]
fn bindgen_test_layout__GParamSpecDouble() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecDouble>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecDouble>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).epsilon as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(epsilon)
        )
    );
}
#[doc = " GParamSpecString:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @default_value: default value for the property specified"]
#[doc = " @cset_first: a string containing the allowed values for the first byte"]
#[doc = " @cset_nth: a string containing the allowed values for the subsequent bytes"]
#[doc = " @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth."]
#[doc = " @null_fold_if_empty: replace empty string by %NULL"]
#[doc = " @ensure_non_null: replace %NULL strings by an empty string"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for string"]
#[doc = " properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout__GParamSpecString() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecString>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecString>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).default_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).cset_first as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).cset_nth as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_nth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).substitutor as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(substitutor)
        )
    );
}
impl _GParamSpecString {
    #[inline]
    pub fn null_fold_if_empty(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_null_fold_if_empty(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ensure_non_null(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ensure_non_null(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        null_fold_if_empty: guint,
        ensure_non_null: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let null_fold_if_empty: u32 = unsafe { ::std::mem::transmute(null_fold_if_empty) };
            null_fold_if_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ensure_non_null: u32 = unsafe { ::std::mem::transmute(ensure_non_null) };
            ensure_non_null as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " GParamSpecParam:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM"]
#[doc = " properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecParam {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecParam() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecParam>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecParam>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecParam),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecBoxed:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for boxed properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecBoxed() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoxed>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoxed>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecBoxed>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoxed),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecPointer:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for pointer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecPointer() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecPointer>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecPointer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecPointer>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecPointer),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecValueArray:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL"]
#[doc = " @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecValueArray() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecValueArray>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecValueArray>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecValueArray>())).element_spec as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(element_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecValueArray>())).fixed_n_elements as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(fixed_n_elements)
        )
    );
}
#[doc = " GParamSpecObject:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for object properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecObject {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecObject() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecObject>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecObject>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecObject),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecOverride:"]
#[doc = ""]
#[doc = " This is a type of #GParamSpec type that simply redirects operations to"]
#[doc = " another paramspec.  All operations other than getting or"]
#[doc = " setting the value are redirected, including accessing the nick and"]
#[doc = " blurb, validating a value, and so forth. See"]
#[doc = " g_param_spec_get_redirect_target() for retrieving the overidden"]
#[doc = " property. #GParamSpecOverride is used in implementing"]
#[doc = " g_object_class_override_property(), and will not be directly useful"]
#[doc = " unless you are implementing a new base type similar to GObject."]
#[doc = ""]
#[doc = " Since: 2.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecOverride() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecOverride>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecOverride>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecOverride>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecOverride>())).overridden as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(overridden)
        )
    );
}
#[doc = " GParamSpecGType:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @is_a_type: a #GType whose subtypes can occur as values"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for #GType properties."]
#[doc = ""]
#[doc = " Since: 2.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
#[test]
fn bindgen_test_layout__GParamSpecGType() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecGType>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecGType>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecGType>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecGType>())).is_a_type as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(is_a_type)
        )
    );
}
#[doc = " GParamSpecVariant:"]
#[doc = " @parent_instance: private #GParamSpec portion"]
#[doc = " @type: a #GVariantType, or %NULL"]
#[doc = " @default_value: a #GVariant, or %NULL"]
#[doc = ""]
#[doc = " A #GParamSpec derived structure that contains the meta data for #GVariant properties."]
#[doc = ""]
#[doc = " When comparing values with g_param_values_cmp(), scalar values with the same"]
#[doc = " type will be compared with g_variant_compare(). Other non-%NULL variants will"]
#[doc = " be checked for equality with g_variant_equal(), and their sort order is"]
#[doc = " otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL"]
#[doc = " values compare equal."]
#[doc = ""]
#[doc = " Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GParamSpecVariant() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecVariant>(),
        120usize,
        concat!("Size of: ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecVariant>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecVariant>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecVariant>())).type_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecVariant>())).default_value as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecVariant>())).padding as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_char"]
    pub fn g_param_spec_char(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint8,
        maximum: gint8,
        default_value: gint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_uchar"]
    pub fn g_param_spec_uchar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint8,
        maximum: guint8,
        default_value: guint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_boolean"]
    pub fn g_param_spec_boolean(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gboolean,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_int"]
    pub fn g_param_spec_int(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint,
        maximum: gint,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_uint"]
    pub fn g_param_spec_uint(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint,
        maximum: guint,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_long"]
    pub fn g_param_spec_long(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: glong,
        maximum: glong,
        default_value: glong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_ulong"]
    pub fn g_param_spec_ulong(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gulong,
        maximum: gulong,
        default_value: gulong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_int64"]
    pub fn g_param_spec_int64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint64,
        maximum: gint64,
        default_value: gint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_uint64"]
    pub fn g_param_spec_uint64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint64,
        maximum: guint64,
        default_value: guint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_unichar"]
    pub fn g_param_spec_unichar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gunichar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_enum"]
    pub fn g_param_spec_enum(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        enum_type: GType,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_flags"]
    pub fn g_param_spec_flags(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags_type: GType,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_float"]
    pub fn g_param_spec_float(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gfloat,
        maximum: gfloat,
        default_value: gfloat,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_double"]
    pub fn g_param_spec_double(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gdouble,
        maximum: gdouble,
        default_value: gdouble,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_string"]
    pub fn g_param_spec_string(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_param"]
    pub fn g_param_spec_param(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        param_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_boxed"]
    pub fn g_param_spec_boxed(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        boxed_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pointer"]
    pub fn g_param_spec_pointer(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_value_array"]
    pub fn g_param_spec_value_array(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_object"]
    pub fn g_param_spec_object(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        object_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_override"]
    pub fn g_param_spec_override(
        name: *const gchar,
        overridden: *mut GParamSpec,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_gtype"]
    pub fn g_param_spec_gtype(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        is_a_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_variant"]
    pub fn g_param_spec_variant(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        type_: *const GVariantType,
        default_value: *mut GVariant,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_types"]
    pub static mut g_param_spec_types: *mut GType;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_closure"]
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_dummy_callback"]
    pub fn g_source_set_dummy_callback(source: *mut GSource);
}
pub type GTypeModule = _GTypeModule;
pub type GTypeModuleClass = _GTypeModuleClass;
pub type GTypeModule_autoptr = *mut GTypeModule;
pub type GTypeModule_listautoptr = *mut GList;
pub type GTypeModule_slistautoptr = *mut GSList;
#[doc = " GTypeModule:"]
#[doc = " @name: the name of the module"]
#[doc = ""]
#[doc = " The members of the GTypeModule structure should not"]
#[doc = " be accessed directly, except for the @name field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
#[test]
fn bindgen_test_layout__GTypeModule() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeModule>(),
        56usize,
        concat!("Size of: ", stringify!(_GTypeModule))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModule>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).use_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(use_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).type_infos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(type_infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).interface_infos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(interface_infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " GTypeModuleClass:"]
#[doc = " @parent_class: the parent class"]
#[doc = " @load: loads the module and registers one or more types using"]
#[doc = "  g_type_module_register_type()."]
#[doc = " @unload: unloads the module"]
#[doc = ""]
#[doc = " In order to implement dynamic loading of types based on #GTypeModule,"]
#[doc = " the @load and @unload functions in #GTypeModuleClass must be implemented."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule) -> gboolean>,
    pub unload: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GTypeModuleClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeModuleClass>(),
        184usize,
        concat!("Size of: ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModuleClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).load as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).unload as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(unload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved4)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_get_type"]
    pub fn g_type_module_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_use"]
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_unuse"]
    pub fn g_type_module_unuse(module: *mut GTypeModule);
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_set_name"]
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_register_type"]
    pub fn g_type_module_register_type(
        module: *mut GTypeModule,
        parent_type: GType,
        type_name: *const gchar,
        type_info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_add_interface"]
    pub fn g_type_module_add_interface(
        module: *mut GTypeModule,
        instance_type: GType,
        interface_type: GType,
        interface_info: *const GInterfaceInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_register_enum"]
    pub fn g_type_module_register_enum(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_register_flags"]
    pub fn g_type_module_register_flags(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
pub type GTypePluginClass = _GTypePluginClass;
#[doc = " GTypePluginUse:"]
#[doc = " @plugin: the #GTypePlugin whose use count should be increased"]
#[doc = ""]
#[doc = " The type of the @use_plugin function of #GTypePluginClass, which gets called"]
#[doc = " to increase the use count of @plugin."]
pub type GTypePluginUse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginUnuse:"]
#[doc = " @plugin: the #GTypePlugin whose use count should be decreased"]
#[doc = ""]
#[doc = " The type of the @unuse_plugin function of #GTypePluginClass."]
pub type GTypePluginUnuse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginCompleteTypeInfo:"]
#[doc = " @plugin: the #GTypePlugin"]
#[doc = " @g_type: the #GType whose info is completed"]
#[doc = " @info: the #GTypeInfo struct to fill in"]
#[doc = " @value_table: the #GTypeValueTable to fill in"]
#[doc = ""]
#[doc = " The type of the @complete_type_info function of #GTypePluginClass."]
pub type GTypePluginCompleteTypeInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    ),
>;
#[doc = " GTypePluginCompleteInterfaceInfo:"]
#[doc = " @plugin: the #GTypePlugin"]
#[doc = " @instance_type: the #GType of an instantiable type to which the interface"]
#[doc = "  is added"]
#[doc = " @interface_type: the #GType of the interface whose info is completed"]
#[doc = " @info: the #GInterfaceInfo to fill in"]
#[doc = ""]
#[doc = " The type of the @complete_interface_info function of #GTypePluginClass."]
pub type GTypePluginCompleteInterfaceInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    ),
>;
#[doc = " GTypePlugin:"]
#[doc = ""]
#[doc = " The GTypePlugin typedef is used as a placeholder"]
#[doc = " for objects that implement the GTypePlugin interface."]
#[doc = " GTypePluginClass:"]
#[doc = " @use_plugin: Increases the use count of the plugin."]
#[doc = " @unuse_plugin: Decreases the use count of the plugin."]
#[doc = " @complete_type_info: Fills in the #GTypeInfo and"]
#[doc = "  #GTypeValueTable structs for the type. The structs are initialized"]
#[doc = "  with `memset(s, 0, sizeof (s))` before calling this function."]
#[doc = " @complete_interface_info: Fills in missing parts of the #GInterfaceInfo"]
#[doc = "  for the interface. The structs is initialized with"]
#[doc = "  `memset(s, 0, sizeof (s))` before calling this function."]
#[doc = ""]
#[doc = " The #GTypePlugin interface is used by the type system in order to handle"]
#[doc = " the lifecycle of dynamically loaded types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
#[test]
fn bindgen_test_layout__GTypePluginClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypePluginClass>(),
        48usize,
        concat!("Size of: ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypePluginClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).base_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(base_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).use_plugin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(use_plugin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).unuse_plugin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(unuse_plugin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTypePluginClass>())).complete_type_info as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_type_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTypePluginClass>())).complete_interface_info as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_interface_info)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_get_type"]
    pub fn g_type_plugin_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_use"]
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_unuse"]
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_complete_type_info"]
    pub fn g_type_plugin_complete_type_info(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_complete_interface_info"]
    pub fn g_type_plugin_complete_interface_info(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    );
}
pub type GValueArray = _GValueArray;
#[doc = " GValueArray:"]
#[doc = " @n_values: number of values contained in the array"]
#[doc = " @values: array of values"]
#[doc = ""]
#[doc = " A #GValueArray contains an array of #GValue elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
#[test]
fn bindgen_test_layout__GValueArray() {
    assert_eq!(
        ::std::mem::size_of::<_GValueArray>(),
        24usize,
        concat!("Size of: ", stringify!(_GValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValueArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).n_values as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).n_prealloced as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_prealloced)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_get_type"]
    pub fn g_value_array_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_get_nth"]
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint) -> *mut GValue;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_new"]
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_free"]
    pub fn g_value_array_free(value_array: *mut GValueArray);
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_copy"]
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_prepend"]
    pub fn g_value_array_prepend(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_append"]
    pub fn g_value_array_append(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_insert"]
    pub fn g_value_array_insert(
        value_array: *mut GValueArray,
        index_: guint,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_remove"]
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_sort"]
    pub fn g_value_array_sort(
        value_array: *mut GValueArray,
        compare_func: GCompareFunc,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_sort_with_data"]
    pub fn g_value_array_sort_with_data(
        value_array: *mut GValueArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_char"]
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_char"]
    pub fn g_value_get_char(value: *const GValue) -> gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_schar"]
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_schar"]
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_uchar"]
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_uchar"]
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_boolean"]
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_boolean"]
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_int"]
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_int"]
    pub fn g_value_get_int(value: *const GValue) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_uint"]
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_uint"]
    pub fn g_value_get_uint(value: *const GValue) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_long"]
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_long"]
    pub fn g_value_get_long(value: *const GValue) -> glong;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_ulong"]
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_ulong"]
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_int64"]
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_int64"]
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_uint64"]
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_uint64"]
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_float"]
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_float"]
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_double"]
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_double"]
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_string"]
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_static_string"]
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_string"]
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_string"]
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_pointer"]
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_pointer"]
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_gtype_get_type"]
    pub fn g_gtype_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_gtype"]
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_gtype"]
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_variant"]
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_variant"]
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_variant"]
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_variant"]
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_pointer_type_register_static"]
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_strdup_value_contents"]
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_string"]
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_string_take_ownership"]
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut gchar);
}
#[doc = " gchararray:"]
#[doc = ""]
#[doc = " A C representable type name for #G_TYPE_STRING."]
pub type gchararray = *mut gchar;
extern "C" {
    #[link_name = "\u{1}_g_unicode_type_get_type"]
    pub fn g_unicode_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_break_type_get_type"]
    pub fn g_unicode_break_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_script_get_type"]
    pub fn g_unicode_script_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_normalize_mode_get_type"]
    pub fn g_normalize_mode_get_type() -> GType;
}
pub type GClosure_autoptr = *mut GClosure;
pub type GClosure_listautoptr = *mut GList;
pub type GClosure_slistautoptr = *mut GSList;
pub type GEnumClass_autoptr = *mut GEnumClass;
pub type GEnumClass_listautoptr = *mut GList;
pub type GEnumClass_slistautoptr = *mut GSList;
pub type GFlagsClass_autoptr = *mut GFlagsClass;
pub type GFlagsClass_listautoptr = *mut GList;
pub type GFlagsClass_slistautoptr = *mut GSList;
pub type GObject_autoptr = *mut GObject;
pub type GObject_listautoptr = *mut GList;
pub type GObject_slistautoptr = *mut GSList;
pub type GInitiallyUnowned_autoptr = *mut GInitiallyUnowned;
pub type GInitiallyUnowned_listautoptr = *mut GList;
pub type GInitiallyUnowned_slistautoptr = *mut GSList;
pub type GParamSpec_autoptr = *mut GParamSpec;
pub type GParamSpec_listautoptr = *mut GList;
pub type GParamSpec_slistautoptr = *mut GSList;
pub type GTypeClass_autoptr = *mut GTypeClass;
pub type GTypeClass_listautoptr = *mut GList;
pub type GTypeClass_slistautoptr = *mut GSList;
#[doc = " VipsPel:"]
#[doc = ""]
#[doc = " A picture element. Cast this to whatever the associated VipsBandFormat says"]
#[doc = " to get the value."]
pub type VipsPel = ::std::os::raw::c_uchar;
pub type VipsCallbackFn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsSListMap2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsSListMap4Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsSListFold2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsPrecision {
    VIPS_PRECISION_INTEGER = 0,
    VIPS_PRECISION_FLOAT = 1,
    VIPS_PRECISION_APPROXIMATE = 2,
    VIPS_PRECISION_LAST = 3,
}
extern "C" {
    #[link_name = "\u{1}_vips_path_filename7"]
    pub fn vips_path_filename7(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_path_mode7"]
    pub fn vips_path_mode7(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsBuf {
    pub base: *mut ::std::os::raw::c_char,
    pub mx: ::std::os::raw::c_int,
    pub i: ::std::os::raw::c_int,
    pub full: gboolean,
    pub lasti: ::std::os::raw::c_int,
    pub dynamic: gboolean,
}
#[test]
fn bindgen_test_layout__VipsBuf() {
    assert_eq!(
        ::std::mem::size_of::<_VipsBuf>(),
        32usize,
        concat!("Size of: ", stringify!(_VipsBuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsBuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuf>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuf>())).mx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(mx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuf>())).i as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuf>())).full as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(full)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuf>())).lasti as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(lasti)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuf>())).dynamic as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuf),
            "::",
            stringify!(dynamic)
        )
    );
}
pub type VipsBuf = _VipsBuf;
extern "C" {
    #[link_name = "\u{1}_vips_buf_rewind"]
    pub fn vips_buf_rewind(buf: *mut VipsBuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_destroy"]
    pub fn vips_buf_destroy(buf: *mut VipsBuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_init"]
    pub fn vips_buf_init(buf: *mut VipsBuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_set_static"]
    pub fn vips_buf_set_static(
        buf: *mut VipsBuf,
        base: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_set_dynamic"]
    pub fn vips_buf_set_dynamic(buf: *mut VipsBuf, mx: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_init_static"]
    pub fn vips_buf_init_static(
        buf: *mut VipsBuf,
        base: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_init_dynamic"]
    pub fn vips_buf_init_dynamic(buf: *mut VipsBuf, mx: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_appendns"]
    pub fn vips_buf_appendns(
        buf: *mut VipsBuf,
        str: *const ::std::os::raw::c_char,
        sz: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_appends"]
    pub fn vips_buf_appends(buf: *mut VipsBuf, str: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_appendf"]
    pub fn vips_buf_appendf(buf: *mut VipsBuf, fmt: *const ::std::os::raw::c_char, ...)
        -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_vappendf"]
    pub fn vips_buf_vappendf(
        buf: *mut VipsBuf,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_appendc"]
    pub fn vips_buf_appendc(buf: *mut VipsBuf, ch: ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_appendsc"]
    pub fn vips_buf_appendsc(
        buf: *mut VipsBuf,
        quote: gboolean,
        str: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_appendgv"]
    pub fn vips_buf_appendgv(buf: *mut VipsBuf, value: *mut GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_append_size"]
    pub fn vips_buf_append_size(buf: *mut VipsBuf, n: usize) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_removec"]
    pub fn vips_buf_removec(buf: *mut VipsBuf, ch: ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_change"]
    pub fn vips_buf_change(
        buf: *mut VipsBuf,
        o: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_is_empty"]
    pub fn vips_buf_is_empty(buf: *mut VipsBuf) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_is_full"]
    pub fn vips_buf_is_full(buf: *mut VipsBuf) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_all"]
    pub fn vips_buf_all(buf: *mut VipsBuf) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_firstline"]
    pub fn vips_buf_firstline(buf: *mut VipsBuf) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_appendg"]
    pub fn vips_buf_appendg(buf: *mut VipsBuf, g: f64) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_appendd"]
    pub fn vips_buf_appendd(buf: *mut VipsBuf, d: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_buf_len"]
    pub fn vips_buf_len(buf: *mut VipsBuf) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsDbuf {
    pub data: *mut ::std::os::raw::c_uchar,
    pub allocated_size: usize,
    pub data_size: usize,
    pub write_point: usize,
}
#[test]
fn bindgen_test_layout__VipsDbuf() {
    assert_eq!(
        ::std::mem::size_of::<_VipsDbuf>(),
        32usize,
        concat!("Size of: ", stringify!(_VipsDbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsDbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsDbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsDbuf>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsDbuf),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsDbuf>())).allocated_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsDbuf),
            "::",
            stringify!(allocated_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsDbuf>())).data_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsDbuf),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsDbuf>())).write_point as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsDbuf),
            "::",
            stringify!(write_point)
        )
    );
}
pub type VipsDbuf = _VipsDbuf;
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_destroy"]
    pub fn vips_dbuf_destroy(dbuf: *mut VipsDbuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_init"]
    pub fn vips_dbuf_init(dbuf: *mut VipsDbuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_allocate"]
    pub fn vips_dbuf_allocate(dbuf: *mut VipsDbuf, size: usize) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_read"]
    pub fn vips_dbuf_read(
        dbuf: *mut VipsDbuf,
        data: *mut ::std::os::raw::c_uchar,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_get_write"]
    pub fn vips_dbuf_get_write(
        dbuf: *mut VipsDbuf,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_write"]
    pub fn vips_dbuf_write(
        dbuf: *mut VipsDbuf,
        data: *const ::std::os::raw::c_uchar,
        size: usize,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_writef"]
    pub fn vips_dbuf_writef(
        dbuf: *mut VipsDbuf,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_reset"]
    pub fn vips_dbuf_reset(dbuf: *mut VipsDbuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_seek"]
    pub fn vips_dbuf_seek(
        dbuf: *mut VipsDbuf,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_truncate"]
    pub fn vips_dbuf_truncate(dbuf: *mut VipsDbuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_tell"]
    pub fn vips_dbuf_tell(dbuf: *mut VipsDbuf) -> off_t;
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_string"]
    pub fn vips_dbuf_string(dbuf: *mut VipsDbuf, size: *mut usize) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_vips_dbuf_steal"]
    pub fn vips_dbuf_steal(dbuf: *mut VipsDbuf, size: *mut usize) -> *mut ::std::os::raw::c_uchar;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    #[link_name = "\u{1}___math_errhandling"]
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyf"]
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyd"]
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyl"]
    pub fn __fpclassifyl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_acosf"]
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_acos"]
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_acosl"]
    pub fn acosl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_asinf"]
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_asin"]
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinl"]
    pub fn asinl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_atanf"]
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atan"]
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanl"]
    pub fn atanl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_atan2f"]
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atan2"]
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atan2l"]
    pub fn atan2l(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_cosf"]
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cos"]
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cosl"]
    pub fn cosl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_sinf"]
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sin"]
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinl"]
    pub fn sinl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_tanf"]
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tan"]
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanl"]
    pub fn tanl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_acoshf"]
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_acosh"]
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_acoshl"]
    pub fn acoshl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_asinhf"]
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_asinh"]
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinhl"]
    pub fn asinhl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_atanhf"]
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atanh"]
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanhl"]
    pub fn atanhl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_coshf"]
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cosh"]
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_coshl"]
    pub fn coshl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_sinhf"]
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sinh"]
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinhl"]
    pub fn sinhl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_tanhf"]
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tanh"]
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanhl"]
    pub fn tanhl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_expf"]
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_exp"]
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expl"]
    pub fn expl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_exp2f"]
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_exp2"]
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_exp2l"]
    pub fn exp2l(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_expm1f"]
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_expm1"]
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expm1l"]
    pub fn expm1l(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_logf"]
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log"]
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logl"]
    pub fn logl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_log10f"]
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log10"]
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log10l"]
    pub fn log10l(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_log2f"]
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log2"]
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log2l"]
    pub fn log2l(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_log1pf"]
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log1p"]
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log1pl"]
    pub fn log1pl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_logbf"]
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_logb"]
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logbl"]
    pub fn logbl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_modff"]
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_modf"]
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_modfl"]
    pub fn modfl(arg1: u128, arg2: *mut u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_ldexpf"]
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ldexp"]
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ldexpl"]
    pub fn ldexpl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_frexpf"]
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_frexp"]
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_frexpl"]
    pub fn frexpl(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_ilogbf"]
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ilogb"]
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ilogbl"]
    pub fn ilogbl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_scalbnf"]
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_scalbn"]
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalbnl"]
    pub fn scalbnl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_scalblnf"]
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_scalbln"]
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalblnl"]
    pub fn scalblnl(arg1: u128, arg2: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_fabsf"]
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fabs"]
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fabsl"]
    pub fn fabsl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_cbrtf"]
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cbrt"]
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cbrtl"]
    pub fn cbrtl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_hypotf"]
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_hypot"]
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_hypotl"]
    pub fn hypotl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_powf"]
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_pow"]
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_powl"]
    pub fn powl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_sqrtf"]
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sqrt"]
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sqrtl"]
    pub fn sqrtl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_erff"]
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_erf"]
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erfl"]
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_erfcf"]
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_erfc"]
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erfcl"]
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_lgammaf"]
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_lgamma"]
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lgammal"]
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_tgammaf"]
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tgamma"]
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tgammal"]
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_ceilf"]
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ceil"]
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ceill"]
    pub fn ceill(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_floorf"]
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_floor"]
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_floorl"]
    pub fn floorl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_nearbyintf"]
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nearbyint"]
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nearbyintl"]
    pub fn nearbyintl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_rintf"]
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_rint"]
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_rintl"]
    pub fn rintl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_lrintf"]
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lrint"]
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lrintl"]
    pub fn lrintl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_roundf"]
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_round"]
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_roundl"]
    pub fn roundl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_lroundf"]
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lround"]
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lroundl"]
    pub fn lroundl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_llrintf"]
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llrint"]
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llrintl"]
    pub fn llrintl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llroundf"]
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llround"]
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llroundl"]
    pub fn llroundl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_truncf"]
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_trunc"]
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_truncl"]
    pub fn truncl(arg1: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_fmodf"]
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmod"]
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmodl"]
    pub fn fmodl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_remainderf"]
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_remainder"]
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remainderl"]
    pub fn remainderl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_remquof"]
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_remquo"]
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remquol"]
    pub fn remquol(arg1: u128, arg2: u128, arg3: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_copysignf"]
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_copysign"]
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_copysignl"]
    pub fn copysignl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_nanf"]
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nan"]
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nanl"]
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_nextafterf"]
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nextafter"]
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nextafterl"]
    pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_nexttoward"]
    pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nexttowardf"]
    pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nexttowardl"]
    pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_fdimf"]
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fdim"]
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fdiml"]
    pub fn fdiml(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_fmaxf"]
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmax"]
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmaxl"]
    pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_fminf"]
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmin"]
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fminl"]
    pub fn fminl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}_fmaf"]
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fma"]
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmal"]
    pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
}
extern "C" {
    #[link_name = "\u{1}___inff"]
    pub fn __inff() -> f32;
}
extern "C" {
    #[link_name = "\u{1}___inf"]
    pub fn __inf() -> f64;
}
extern "C" {
    #[link_name = "\u{1}___infl"]
    pub fn __infl() -> u128;
}
extern "C" {
    #[link_name = "\u{1}___nan"]
    pub fn __nan() -> f32;
}
extern "C" {
    #[link_name = "\u{1}___exp10f"]
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___exp10"]
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___cospif"]
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___cospi"]
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___sinpif"]
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___sinpi"]
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___tanpif"]
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___tanpi"]
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    assert_eq!(
        ::std::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::std::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__float2>())).__sinval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__float2>())).__cosval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__cosval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    assert_eq!(
        ::std::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::std::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__double2>())).__sinval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__double2>())).__cosval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__cosval)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}___sincosf_stret"]
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    #[link_name = "\u{1}___sincos_stret"]
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    #[link_name = "\u{1}___sincospif_stret"]
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    #[link_name = "\u{1}___sincospi_stret"]
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    #[link_name = "\u{1}_j0"]
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_j1"]
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_jn"]
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_y0"]
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_y1"]
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_yn"]
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalb"]
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rinttol"]
    pub fn rinttol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_roundtol"]
    pub fn roundtol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_drem"]
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_finite"]
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gamma"]
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_significand"]
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_enum_string"]
    pub fn vips_enum_string(
        enm: GType,
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_enum_nick"]
    pub fn vips_enum_nick(
        enm: GType,
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_enum_from_nick"]
    pub fn vips_enum_from_nick(
        domain: *const ::std::os::raw::c_char,
        type_: GType,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_flags_from_nick"]
    pub fn vips_flags_from_nick(
        domain: *const ::std::os::raw::c_char,
        type_: GType,
        nick: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_slist_equal"]
    pub fn vips_slist_equal(l1: *mut GSList, l2: *mut GSList) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_slist_map2"]
    pub fn vips_slist_map2(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_slist_map2_rev"]
    pub fn vips_slist_map2_rev(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_slist_map4"]
    pub fn vips_slist_map4(
        list: *mut GSList,
        fn_: VipsSListMap4Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_slist_fold2"]
    pub fn vips_slist_fold2(
        list: *mut GSList,
        start: *mut ::std::os::raw::c_void,
        fn_: VipsSListFold2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_slist_filter"]
    pub fn vips_slist_filter(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_vips_slist_free_all"]
    pub fn vips_slist_free_all(list: *mut GSList);
}
extern "C" {
    #[link_name = "\u{1}_vips_map_equal"]
    pub fn vips_map_equal(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_hash_table_map"]
    pub fn vips_hash_table_map(
        hash: *mut GHashTable,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_strncpy"]
    pub fn vips_strncpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_strrstr"]
    pub fn vips_strrstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_ispostfix"]
    pub fn vips_ispostfix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_iscasepostfix"]
    pub fn vips_iscasepostfix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_isprefix"]
    pub fn vips_isprefix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_break_token"]
    pub fn vips_break_token(
        str: *mut ::std::os::raw::c_char,
        brk: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__chomp"]
    pub fn vips__chomp(str: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_vips_vsnprintf"]
    pub fn vips_vsnprintf(
        str: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_snprintf"]
    pub fn vips_snprintf(
        str: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_filename_suffix_match"]
    pub fn vips_filename_suffix_match(
        path: *const ::std::os::raw::c_char,
        suffixes: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_file_length"]
    pub fn vips_file_length(fd: ::std::os::raw::c_int) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_vips__write"]
    pub fn vips__write(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__open"]
    pub fn vips__open(
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__open_read"]
    pub fn vips__open_read(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__fopen"]
    pub fn vips__fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_vips__file_open_read"]
    pub fn vips__file_open_read(
        filename: *const ::std::os::raw::c_char,
        fallback_dir: *const ::std::os::raw::c_char,
        text_mode: gboolean,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_vips__file_open_write"]
    pub fn vips__file_open_write(
        filename: *const ::std::os::raw::c_char,
        text_mode: gboolean,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_vips__file_read"]
    pub fn vips__file_read(
        fp: *mut FILE,
        name: *const ::std::os::raw::c_char,
        length_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__file_read_name"]
    pub fn vips__file_read_name(
        name: *const ::std::os::raw::c_char,
        fallback_dir: *const ::std::os::raw::c_char,
        length_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__file_write"]
    pub fn vips__file_write(
        data: *mut ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__get_bytes"]
    pub fn vips__get_bytes(
        filename: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_uchar,
        len: guint64,
    ) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_vips__fgetc"]
    pub fn vips__fgetc(fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__gvalue_ref_string_new"]
    pub fn vips__gvalue_ref_string_new(text: *const ::std::os::raw::c_char) -> *mut GValue;
}
extern "C" {
    #[link_name = "\u{1}_vips__gslist_gvalue_free"]
    pub fn vips__gslist_gvalue_free(list: *mut GSList);
}
extern "C" {
    #[link_name = "\u{1}_vips__gslist_gvalue_copy"]
    pub fn vips__gslist_gvalue_copy(list: *const GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_vips__gslist_gvalue_merge"]
    pub fn vips__gslist_gvalue_merge(a: *mut GSList, b: *const GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_vips__gslist_gvalue_get"]
    pub fn vips__gslist_gvalue_get(list: *const GSList) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__seek"]
    pub fn vips__seek(fd: ::std::os::raw::c_int, pos: gint64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__ftruncate"]
    pub fn vips__ftruncate(fd: ::std::os::raw::c_int, pos: gint64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_existsf"]
    pub fn vips_existsf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mkdirf"]
    pub fn vips_mkdirf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rmdirf"]
    pub fn vips_rmdirf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rename"]
    pub fn vips_rename(
        old_name: *const ::std::os::raw::c_char,
        new_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_popenf"]
    pub fn vips_popenf(
        fmt: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
        ...
    ) -> *mut FILE;
}
#[repr(u32)]
#[doc = " VipsToken:"]
#[doc = " @VIPS_TOKEN_LEFT: left bracket"]
#[doc = " @VIPS_TOKEN_RIGHT: right bracket"]
#[doc = " @VIPS_TOKEN_STRING: string constant"]
#[doc = " @VIPS_TOKEN_EQUALS: equals sign"]
#[doc = " @VIPS_TOKEN_COMMA: comma"]
#[doc = ""]
#[doc = " Tokens returned by the vips lexical analyzer, see vips__token_get(). This"]
#[doc = " is used to parse option strings for arguments."]
#[doc = ""]
#[doc = " Left and right brackets can be any of (, {, [, <."]
#[doc = ""]
#[doc = " Strings may be in double quotes, and may contain escaped quote characters,"]
#[doc = " for example string, \"string\" and \"str\\\"ing\"."]
#[doc = ""]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsToken {
    VIPS_TOKEN_LEFT = 1,
    VIPS_TOKEN_RIGHT = 2,
    VIPS_TOKEN_STRING = 3,
    VIPS_TOKEN_EQUALS = 4,
    VIPS_TOKEN_COMMA = 5,
}
extern "C" {
    #[link_name = "\u{1}_vips__token_get"]
    pub fn vips__token_get(
        buffer: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__token_must"]
    pub fn vips__token_must(
        buffer: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__token_need"]
    pub fn vips__token_need(
        buffer: *const ::std::os::raw::c_char,
        need_token: VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__token_segment"]
    pub fn vips__token_segment(
        p: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__token_segment_need"]
    pub fn vips__token_segment_need(
        p: *const ::std::os::raw::c_char,
        need_token: VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__find_rightmost_brackets"]
    pub fn vips__find_rightmost_brackets(
        p: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__filename_split8"]
    pub fn vips__filename_split8(
        name: *const ::std::os::raw::c_char,
        filename: *mut ::std::os::raw::c_char,
        option_string: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_ispoweroftwo"]
    pub fn vips_ispoweroftwo(p: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_amiMSBfirst"]
    pub fn vips_amiMSBfirst() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__temp_name"]
    pub fn vips__temp_name(format: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__change_suffix"]
    pub fn vips__change_suffix(
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
        new_suff: *const ::std::os::raw::c_char,
        olds: *mut *const ::std::os::raw::c_char,
        nolds: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_realpath"]
    pub fn vips_realpath(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__random"]
    pub fn vips__random(seed: guint32) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_vips__random_add"]
    pub fn vips__random_add(seed: guint32, value: ::std::os::raw::c_int) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_vips__icc_dir"]
    pub fn vips__icc_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips__windows_prefix"]
    pub fn vips__windows_prefix() -> *const ::std::os::raw::c_char;
}
pub type VipsObject = _VipsObject;
pub type VipsObjectClass = _VipsObjectClass;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsArgumentFlags {
    VIPS_ARGUMENT_NONE = 0,
    VIPS_ARGUMENT_REQUIRED = 1,
    VIPS_ARGUMENT_CONSTRUCT = 2,
    VIPS_ARGUMENT_SET_ONCE = 4,
    VIPS_ARGUMENT_SET_ALWAYS = 8,
    VIPS_ARGUMENT_INPUT = 16,
    VIPS_ARGUMENT_OUTPUT = 32,
    VIPS_ARGUMENT_DEPRECATED = 64,
    VIPS_ARGUMENT_MODIFY = 128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArgument {
    pub pspec: *mut GParamSpec,
}
#[test]
fn bindgen_test_layout__VipsArgument() {
    assert_eq!(
        ::std::mem::size_of::<_VipsArgument>(),
        8usize,
        concat!("Size of: ", stringify!(_VipsArgument))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArgument>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArgument))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgument>())).pspec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgument),
            "::",
            stringify!(pspec)
        )
    );
}
pub type VipsArgument = _VipsArgument;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArgumentClass {
    pub parent: VipsArgument,
    pub object_class: *mut VipsObjectClass,
    pub flags: VipsArgumentFlags,
    pub priority: ::std::os::raw::c_int,
    pub offset: guint,
}
#[test]
fn bindgen_test_layout__VipsArgumentClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsArgumentClass>(),
        32usize,
        concat!("Size of: ", stringify!(_VipsArgumentClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArgumentClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArgumentClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentClass>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentClass>())).object_class as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(object_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentClass>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentClass>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentClass>())).offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentClass),
            "::",
            stringify!(offset)
        )
    );
}
pub type VipsArgumentClass = _VipsArgumentClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArgumentInstance {
    pub parent: VipsArgument,
    pub argument_class: *mut VipsArgumentClass,
    pub object: *mut VipsObject,
    pub assigned: gboolean,
    pub close_id: gulong,
    pub invalidate_id: gulong,
}
#[test]
fn bindgen_test_layout__VipsArgumentInstance() {
    assert_eq!(
        ::std::mem::size_of::<_VipsArgumentInstance>(),
        48usize,
        concat!("Size of: ", stringify!(_VipsArgumentInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArgumentInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArgumentInstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentInstance>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsArgumentInstance>())).argument_class as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(argument_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentInstance>())).object as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentInstance>())).assigned as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(assigned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArgumentInstance>())).close_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(close_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsArgumentInstance>())).invalidate_id as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArgumentInstance),
            "::",
            stringify!(invalidate_id)
        )
    );
}
pub type VipsArgumentInstance = _VipsArgumentInstance;
pub type VipsArgumentTable = GHashTable;
extern "C" {
    #[link_name = "\u{1}_vips_argument_get_id"]
    pub fn vips_argument_get_id() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__object_set_member"]
    pub fn vips__object_set_member(
        object: *mut VipsObject,
        pspec: *mut GParamSpec,
        member: *mut *mut GObject,
        argument: *mut GObject,
    );
}
pub type VipsArgumentMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut VipsObject,
        pspec: *mut GParamSpec,
        argument_class: *mut VipsArgumentClass,
        argument_instance: *mut VipsArgumentInstance,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[link_name = "\u{1}_vips_argument_map"]
    pub fn vips_argument_map(
        object: *mut VipsObject,
        fn_: VipsArgumentMapFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_get_args"]
    pub fn vips_object_get_args(
        object: *mut VipsObject,
        names: *mut *mut *const ::std::os::raw::c_char,
        flags: *mut *mut ::std::os::raw::c_int,
        n_args: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type VipsArgumentClassMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        object_class: *mut VipsObjectClass,
        pspec: *mut GParamSpec,
        argument_class: *mut VipsArgumentClass,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[link_name = "\u{1}_vips_argument_class_map"]
    pub fn vips_argument_class_map(
        object_class: *mut VipsObjectClass,
        fn_: VipsArgumentClassMapFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_argument_class_needsstring"]
    pub fn vips_argument_class_needsstring(argument_class: *mut VipsArgumentClass) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_get_argument"]
    pub fn vips_object_get_argument(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        pspec: *mut *mut GParamSpec,
        argument_class: *mut *mut VipsArgumentClass,
        argument_instance: *mut *mut VipsArgumentInstance,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_argument_isset"]
    pub fn vips_object_argument_isset(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_get_argument_flags"]
    pub fn vips_object_get_argument_flags(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> VipsArgumentFlags;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_get_argument_priority"]
    pub fn vips_object_get_argument_priority(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsObject {
    pub parent_instance: GObject,
    pub constructed: gboolean,
    pub static_object: gboolean,
    pub argument_table: *mut VipsArgumentTable,
    pub nickname: *mut ::std::os::raw::c_char,
    pub description: *mut ::std::os::raw::c_char,
    pub preclose: gboolean,
    pub close: gboolean,
    pub postclose: gboolean,
    pub local_memory: usize,
}
#[test]
fn bindgen_test_layout__VipsObject() {
    assert_eq!(
        ::std::mem::size_of::<_VipsObject>(),
        80usize,
        concat!("Size of: ", stringify!(_VipsObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).constructed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(constructed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).static_object as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(static_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).argument_table as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(argument_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).nickname as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(nickname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).description as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).preclose as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(preclose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).close as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).postclose as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(postclose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObject>())).local_memory as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObject),
            "::",
            stringify!(local_memory)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsObjectClass {
    pub parent_class: GObjectClass,
    pub build: ::std::option::Option<
        unsafe extern "C" fn(object: *mut VipsObject) -> ::std::os::raw::c_int,
    >,
    pub postbuild: ::std::option::Option<
        unsafe extern "C" fn(object: *mut VipsObject) -> ::std::os::raw::c_int,
    >,
    pub summary_class:
        ::std::option::Option<unsafe extern "C" fn(cls: *mut _VipsObjectClass, buf: *mut VipsBuf)>,
    pub summary:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub dump:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub sanity:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub rewind: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub preclose: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub close: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub postclose: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub new_from_string: ::std::option::Option<
        unsafe extern "C" fn(string: *const ::std::os::raw::c_char) -> *mut VipsObject,
    >,
    pub to_string:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub output_needs_arg: gboolean,
    pub output_to_arg: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut VipsObject,
            string: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub nickname: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub argument_table: *mut VipsArgumentTable,
    pub argument_table_traverse: *mut GSList,
    pub argument_table_traverse_gtype: GType,
    pub deprecated: gboolean,
    pub _vips_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__VipsObjectClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsObjectClass>(),
        328usize,
        concat!("Size of: ", stringify!(_VipsObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsObjectClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).build as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(build)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).postbuild as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(postbuild)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).summary_class as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(summary_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).summary as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(summary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).dump as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).sanity as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(sanity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).rewind as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(rewind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).preclose as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(preclose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).close as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).postclose as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(postclose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsObjectClass>())).new_from_string as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(new_from_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).to_string as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(to_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsObjectClass>())).output_needs_arg as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(output_needs_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).output_to_arg as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(output_to_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).nickname as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(nickname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).description as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).argument_table as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(argument_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsObjectClass>())).argument_table_traverse as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(argument_table_traverse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsObjectClass>())).argument_table_traverse_gtype as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(argument_table_traverse_gtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsObjectClass>())).deprecated as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(deprecated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsObjectClass>()))._vips_reserved1 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(_vips_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsObjectClass>()))._vips_reserved2 as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(_vips_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsObjectClass>()))._vips_reserved3 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(_vips_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsObjectClass>()))._vips_reserved4 as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsObjectClass),
            "::",
            stringify!(_vips_reserved4)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_value_is_null"]
    pub fn vips_value_is_null(psoec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_set_property"]
    pub fn vips_object_set_property(
        gobject: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_object_get_property"]
    pub fn vips_object_get_property(
        gobject: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_object_preclose"]
    pub fn vips_object_preclose(object: *mut VipsObject);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_build"]
    pub fn vips_object_build(object: *mut VipsObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_summary_class"]
    pub fn vips_object_summary_class(klass: *mut VipsObjectClass, buf: *mut VipsBuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_summary"]
    pub fn vips_object_summary(object: *mut VipsObject, buf: *mut VipsBuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_dump"]
    pub fn vips_object_dump(object: *mut VipsObject, buf: *mut VipsBuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_print_summary_class"]
    pub fn vips_object_print_summary_class(klass: *mut VipsObjectClass);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_print_summary"]
    pub fn vips_object_print_summary(object: *mut VipsObject);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_print_dump"]
    pub fn vips_object_print_dump(object: *mut VipsObject);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_print_name"]
    pub fn vips_object_print_name(object: *mut VipsObject);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_sanity"]
    pub fn vips_object_sanity(object: *mut VipsObject) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_get_type"]
    pub fn vips_object_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_class_install_argument"]
    pub fn vips_object_class_install_argument(
        cls: *mut VipsObjectClass,
        pspec: *mut GParamSpec,
        flags: VipsArgumentFlags,
        priority: ::std::os::raw::c_int,
        offset: guint,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_object_set_argument_from_string"]
    pub fn vips_object_set_argument_from_string(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_argument_needsstring"]
    pub fn vips_object_argument_needsstring(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_get_argument_to_string"]
    pub fn vips_object_get_argument_to_string(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_set_required"]
    pub fn vips_object_set_required(
        object: *mut VipsObject,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type VipsObjectSetArguments = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut VipsObject,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[link_name = "\u{1}_vips_object_new"]
    pub fn vips_object_new(
        type_: GType,
        set: VipsObjectSetArguments,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut VipsObject;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_set_valist"]
    pub fn vips_object_set_valist(
        object: *mut VipsObject,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_set"]
    pub fn vips_object_set(object: *mut VipsObject, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_set_from_string"]
    pub fn vips_object_set_from_string(
        object: *mut VipsObject,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_new_from_string"]
    pub fn vips_object_new_from_string(
        object_class: *mut VipsObjectClass,
        p: *const ::std::os::raw::c_char,
    ) -> *mut VipsObject;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_to_string"]
    pub fn vips_object_to_string(object: *mut VipsObject, buf: *mut VipsBuf);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_map"]
    pub fn vips_object_map(
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub type VipsTypeMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        type_: GType,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsTypeMap2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        type_: GType,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsClassMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut VipsObjectClass,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[link_name = "\u{1}_vips_type_map"]
    pub fn vips_type_map(
        base: GType,
        fn_: VipsTypeMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_type_map_all"]
    pub fn vips_type_map_all(
        base: GType,
        fn_: VipsTypeMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_type_depth"]
    pub fn vips_type_depth(type_: GType) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_type_find"]
    pub fn vips_type_find(
        basename: *const ::std::os::raw::c_char,
        nickname: *const ::std::os::raw::c_char,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_nickname_find"]
    pub fn vips_nickname_find(type_: GType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_class_map_all"]
    pub fn vips_class_map_all(
        type_: GType,
        fn_: VipsClassMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_class_find"]
    pub fn vips_class_find(
        basename: *const ::std::os::raw::c_char,
        nickname: *const ::std::os::raw::c_char,
    ) -> *const VipsObjectClass;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_local_array"]
    pub fn vips_object_local_array(
        parent: *mut VipsObject,
        n: ::std::os::raw::c_int,
    ) -> *mut *mut VipsObject;
}
extern "C" {
    #[link_name = "\u{1}_vips_object_local_cb"]
    pub fn vips_object_local_cb(vobject: *mut VipsObject, gobject: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_set_static"]
    pub fn vips_object_set_static(object: *mut VipsObject, static_object: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_print_all"]
    pub fn vips_object_print_all();
}
extern "C" {
    #[link_name = "\u{1}_vips_object_sanity_all"]
    pub fn vips_object_sanity_all();
}
extern "C" {
    #[link_name = "\u{1}_vips_object_rewind"]
    pub fn vips_object_rewind(object: *mut VipsObject);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_unref_outputs"]
    pub fn vips_object_unref_outputs(object: *mut VipsObject);
}
extern "C" {
    #[link_name = "\u{1}_vips_object_get_description"]
    pub fn vips_object_get_description(object: *mut VipsObject) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsThing {
    pub i: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsThing() {
    assert_eq!(
        ::std::mem::size_of::<_VipsThing>(),
        4usize,
        concat!("Size of: ", stringify!(_VipsThing))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsThing>(),
        4usize,
        concat!("Alignment of ", stringify!(_VipsThing))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThing>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThing),
            "::",
            stringify!(i)
        )
    );
}
pub type VipsThing = _VipsThing;
extern "C" {
    #[link_name = "\u{1}_vips_thing_get_type"]
    pub fn vips_thing_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_thing_new"]
    pub fn vips_thing_new(i: ::std::os::raw::c_int) -> *mut VipsThing;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArea {
    pub data: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub n: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub lock: *mut GMutex,
    pub free_fn: VipsCallbackFn,
    pub type_: GType,
    pub sizeof_type: usize,
}
#[test]
fn bindgen_test_layout__VipsArea() {
    assert_eq!(
        ::std::mem::size_of::<_VipsArea>(),
        56usize,
        concat!("Size of: ", stringify!(_VipsArea))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArea>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArea))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArea>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArea>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArea>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArea>())).count as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArea>())).lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArea>())).free_fn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArea>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArea>())).sizeof_type as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArea),
            "::",
            stringify!(sizeof_type)
        )
    );
}
pub type VipsArea = _VipsArea;
extern "C" {
    #[link_name = "\u{1}_vips_area_copy"]
    pub fn vips_area_copy(area: *mut VipsArea) -> *mut VipsArea;
}
extern "C" {
    #[link_name = "\u{1}_vips_area_unref"]
    pub fn vips_area_unref(area: *mut VipsArea);
}
extern "C" {
    #[link_name = "\u{1}_vips_area_new"]
    pub fn vips_area_new(
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut VipsArea;
}
extern "C" {
    #[link_name = "\u{1}_vips_area_new_array"]
    pub fn vips_area_new_array(
        type_: GType,
        sizeof_type: usize,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArea;
}
extern "C" {
    #[link_name = "\u{1}_vips_area_new_array_object"]
    pub fn vips_area_new_array_object(n: ::std::os::raw::c_int) -> *mut VipsArea;
}
extern "C" {
    #[link_name = "\u{1}_vips_area_get_data"]
    pub fn vips_area_get_data(
        area: *mut VipsArea,
        length: *mut usize,
        n: *mut ::std::os::raw::c_int,
        type_: *mut GType,
        sizeof_type: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_area_get_type"]
    pub fn vips_area_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_save_string_get_type"]
    pub fn vips_save_string_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsRefString {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsRefString() {
    assert_eq!(
        ::std::mem::size_of::<_VipsRefString>(),
        56usize,
        concat!("Size of: ", stringify!(_VipsRefString))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsRefString>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsRefString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRefString>())).area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRefString),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsRefString = _VipsRefString;
extern "C" {
    #[link_name = "\u{1}_vips_ref_string_new"]
    pub fn vips_ref_string_new(str: *const ::std::os::raw::c_char) -> *mut VipsRefString;
}
extern "C" {
    #[link_name = "\u{1}_vips_ref_string_get"]
    pub fn vips_ref_string_get(
        refstr: *mut VipsRefString,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_ref_string_get_type"]
    pub fn vips_ref_string_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsBlob {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsBlob() {
    assert_eq!(
        ::std::mem::size_of::<_VipsBlob>(),
        56usize,
        concat!("Size of: ", stringify!(_VipsBlob))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsBlob>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsBlob))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBlob>())).area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBlob),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsBlob = _VipsBlob;
extern "C" {
    #[link_name = "\u{1}_vips_blob_new"]
    pub fn vips_blob_new(
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut VipsBlob;
}
extern "C" {
    #[link_name = "\u{1}_vips_blob_copy"]
    pub fn vips_blob_copy(data: *const ::std::os::raw::c_void, size: usize) -> *mut VipsBlob;
}
extern "C" {
    #[link_name = "\u{1}_vips_blob_get"]
    pub fn vips_blob_get(blob: *mut VipsBlob, size: *mut usize) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_blob_get_type"]
    pub fn vips_blob_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArrayDouble {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsArrayDouble() {
    assert_eq!(
        ::std::mem::size_of::<_VipsArrayDouble>(),
        56usize,
        concat!("Size of: ", stringify!(_VipsArrayDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArrayDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArrayDouble))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArrayDouble>())).area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArrayDouble),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsArrayDouble = _VipsArrayDouble;
extern "C" {
    #[link_name = "\u{1}_vips_array_double_new"]
    pub fn vips_array_double_new(
        array: *const f64,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayDouble;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_double_newv"]
    pub fn vips_array_double_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayDouble;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_double_get"]
    pub fn vips_array_double_get(
        array: *mut VipsArrayDouble,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut f64;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_double_get_type"]
    pub fn vips_array_double_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArrayInt {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsArrayInt() {
    assert_eq!(
        ::std::mem::size_of::<_VipsArrayInt>(),
        56usize,
        concat!("Size of: ", stringify!(_VipsArrayInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArrayInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArrayInt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArrayInt>())).area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArrayInt),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsArrayInt = _VipsArrayInt;
extern "C" {
    #[link_name = "\u{1}_vips_array_int_new"]
    pub fn vips_array_int_new(
        array: *const ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayInt;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_int_newv"]
    pub fn vips_array_int_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayInt;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_int_get"]
    pub fn vips_array_int_get(
        array: *mut VipsArrayInt,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_int_get_type"]
    pub fn vips_array_int_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArrayImage {
    pub area: VipsArea,
}
#[test]
fn bindgen_test_layout__VipsArrayImage() {
    assert_eq!(
        ::std::mem::size_of::<_VipsArrayImage>(),
        56usize,
        concat!("Size of: ", stringify!(_VipsArrayImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsArrayImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsArrayImage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsArrayImage>())).area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsArrayImage),
            "::",
            stringify!(area)
        )
    );
}
pub type VipsArrayImage = _VipsArrayImage;
extern "C" {
    #[link_name = "\u{1}_vips_array_image_get_type"]
    pub fn vips_array_image_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_area"]
    pub fn vips_value_set_area(
        value: *mut GValue,
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_area"]
    pub fn vips_value_get_area(
        value: *const GValue,
        length: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_save_string"]
    pub fn vips_value_get_save_string(value: *const GValue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_save_string"]
    pub fn vips_value_set_save_string(value: *mut GValue, str: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_save_stringf"]
    pub fn vips_value_set_save_stringf(value: *mut GValue, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_ref_string"]
    pub fn vips_value_get_ref_string(
        value: *const GValue,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_ref_string"]
    pub fn vips_value_set_ref_string(value: *mut GValue, str: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_blob"]
    pub fn vips_value_get_blob(
        value: *const GValue,
        length: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_blob"]
    pub fn vips_value_set_blob(
        value: *mut GValue,
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_blob_free"]
    pub fn vips_value_set_blob_free(
        value: *mut GValue,
        data: *mut ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_array"]
    pub fn vips_value_set_array(
        value: *mut GValue,
        n: ::std::os::raw::c_int,
        type_: GType,
        sizeof_type: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_array"]
    pub fn vips_value_get_array(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
        type_: *mut GType,
        sizeof_type: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_array_double"]
    pub fn vips_value_get_array_double(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut f64;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_array_double"]
    pub fn vips_value_set_array_double(
        value: *mut GValue,
        array: *const f64,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_array_int"]
    pub fn vips_value_get_array_int(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_array_int"]
    pub fn vips_value_set_array_int(
        value: *mut GValue,
        array: *const ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_array_object"]
    pub fn vips_value_get_array_object(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_array_object"]
    pub fn vips_value_set_array_object(value: *mut GValue, n: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips__thread_profile"]
    pub static mut vips__thread_profile: gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_profile_set"]
    pub fn vips_profile_set(profile: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_vips__thread_profile_attach"]
    pub fn vips__thread_profile_attach(thread_name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_vips__thread_profile_detach"]
    pub fn vips__thread_profile_detach();
}
extern "C" {
    #[link_name = "\u{1}_vips__thread_profile_stop"]
    pub fn vips__thread_profile_stop();
}
extern "C" {
    #[link_name = "\u{1}_vips__thread_gate_start"]
    pub fn vips__thread_gate_start(gate_name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_vips__thread_gate_stop"]
    pub fn vips__thread_gate_stop(gate_name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_vips__thread_malloc_free"]
    pub fn vips__thread_malloc_free(size: gint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsRect {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsRect() {
    assert_eq!(
        ::std::mem::size_of::<_VipsRect>(),
        16usize,
        concat!("Size of: ", stringify!(_VipsRect))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsRect>(),
        4usize,
        concat!("Alignment of ", stringify!(_VipsRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRect>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRect>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRect>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRect>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRect),
            "::",
            stringify!(height)
        )
    );
}
pub type VipsRect = _VipsRect;
extern "C" {
    #[link_name = "\u{1}_vips_rect_isempty"]
    pub fn vips_rect_isempty(r: *const VipsRect) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_rect_includespoint"]
    pub fn vips_rect_includespoint(
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_rect_includesrect"]
    pub fn vips_rect_includesrect(r1: *const VipsRect, r2: *const VipsRect) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_rect_equalsrect"]
    pub fn vips_rect_equalsrect(r1: *const VipsRect, r2: *const VipsRect) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_rect_marginadjust"]
    pub fn vips_rect_marginadjust(r: *mut VipsRect, n: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips_rect_intersectrect"]
    pub fn vips_rect_intersectrect(r1: *const VipsRect, r2: *const VipsRect, out: *mut VipsRect);
}
extern "C" {
    #[link_name = "\u{1}_vips_rect_unionrect"]
    pub fn vips_rect_unionrect(r1: *const VipsRect, r2: *const VipsRect, out: *mut VipsRect);
}
extern "C" {
    #[link_name = "\u{1}_vips_rect_dup"]
    pub fn vips_rect_dup(r: *const VipsRect) -> *mut VipsRect;
}
extern "C" {
    #[link_name = "\u{1}_vips_rect_normalise"]
    pub fn vips_rect_normalise(r: *mut VipsRect);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VipsWindow {
    pub ref_count: ::std::os::raw::c_int,
    pub im: *mut _VipsImage,
    pub top: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub data: *mut VipsPel,
    pub baseaddr: *mut ::std::os::raw::c_void,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_VipsWindow() {
    assert_eq!(
        ::std::mem::size_of::<VipsWindow>(),
        48usize,
        concat!("Size of: ", stringify!(VipsWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<VipsWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(VipsWindow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsWindow>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsWindow>())).im as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsWindow>())).top as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsWindow>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsWindow>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsWindow>())).baseaddr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(baseaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsWindow>())).length as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsWindow),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_window_unref"]
    pub fn vips_window_unref(window: *mut VipsWindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_window_print"]
    pub fn vips_window_print(window: *mut VipsWindow);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VipsBufferThread {
    pub hash: *mut GHashTable,
    pub thread: *mut GThread,
}
#[test]
fn bindgen_test_layout_VipsBufferThread() {
    assert_eq!(
        ::std::mem::size_of::<VipsBufferThread>(),
        16usize,
        concat!("Size of: ", stringify!(VipsBufferThread))
    );
    assert_eq!(
        ::std::mem::align_of::<VipsBufferThread>(),
        8usize,
        concat!("Alignment of ", stringify!(VipsBufferThread))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsBufferThread>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsBufferThread),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsBufferThread>())).thread as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsBufferThread),
            "::",
            stringify!(thread)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsBufferCache {
    pub buffers: *mut GSList,
    pub thread: *mut GThread,
    pub im: *mut _VipsImage,
    pub buffer_thread: *mut VipsBufferThread,
    pub reserve: *mut GSList,
    pub n_reserve: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsBufferCache() {
    assert_eq!(
        ::std::mem::size_of::<_VipsBufferCache>(),
        48usize,
        concat!("Size of: ", stringify!(_VipsBufferCache))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsBufferCache>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsBufferCache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBufferCache>())).buffers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBufferCache>())).thread as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBufferCache>())).im as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBufferCache>())).buffer_thread as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(buffer_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBufferCache>())).reserve as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBufferCache>())).n_reserve as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBufferCache),
            "::",
            stringify!(n_reserve)
        )
    );
}
pub type VipsBufferCache = _VipsBufferCache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsBuffer {
    pub ref_count: ::std::os::raw::c_int,
    pub im: *mut _VipsImage,
    pub area: VipsRect,
    pub done: gboolean,
    pub cache: *mut VipsBufferCache,
    pub buf: *mut VipsPel,
    pub bsize: usize,
}
#[test]
fn bindgen_test_layout__VipsBuffer() {
    assert_eq!(
        ::std::mem::size_of::<_VipsBuffer>(),
        64usize,
        concat!("Size of: ", stringify!(_VipsBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuffer>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuffer>())).im as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuffer>())).area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuffer>())).done as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuffer>())).cache as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuffer>())).buf as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsBuffer>())).bsize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsBuffer),
            "::",
            stringify!(bsize)
        )
    );
}
pub type VipsBuffer = _VipsBuffer;
extern "C" {
    #[link_name = "\u{1}_vips_buffer_dump_all"]
    pub fn vips_buffer_dump_all();
}
extern "C" {
    #[link_name = "\u{1}_vips_buffer_done"]
    pub fn vips_buffer_done(buffer: *mut VipsBuffer);
}
extern "C" {
    #[link_name = "\u{1}_vips_buffer_undone"]
    pub fn vips_buffer_undone(buffer: *mut VipsBuffer);
}
extern "C" {
    #[link_name = "\u{1}_vips_buffer_unref"]
    pub fn vips_buffer_unref(buffer: *mut VipsBuffer);
}
extern "C" {
    #[link_name = "\u{1}_vips_buffer_new"]
    pub fn vips_buffer_new(im: *mut _VipsImage, area: *mut VipsRect) -> *mut VipsBuffer;
}
extern "C" {
    #[link_name = "\u{1}_vips_buffer_ref"]
    pub fn vips_buffer_ref(im: *mut _VipsImage, area: *mut VipsRect) -> *mut VipsBuffer;
}
extern "C" {
    #[link_name = "\u{1}_vips_buffer_unref_ref"]
    pub fn vips_buffer_unref_ref(
        buffer: *mut VipsBuffer,
        im: *mut _VipsImage,
        area: *mut VipsRect,
    ) -> *mut VipsBuffer;
}
extern "C" {
    #[link_name = "\u{1}_vips_buffer_print"]
    pub fn vips_buffer_print(buffer: *mut VipsBuffer);
}
extern "C" {
    #[link_name = "\u{1}_vips__render_shutdown"]
    pub fn vips__render_shutdown();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RegionType {
    VIPS_REGION_NONE = 0,
    VIPS_REGION_BUFFER = 1,
    VIPS_REGION_OTHER_REGION = 2,
    VIPS_REGION_OTHER_IMAGE = 3,
    VIPS_REGION_WINDOW = 4,
}
pub use self::_RegionType as RegionType;
extern "C" {
    #[link_name = "\u{1}_vips__region_take_ownership"]
    pub fn vips__region_take_ownership(reg: *mut _VipsRegion);
}
extern "C" {
    #[link_name = "\u{1}_vips__region_check_ownership"]
    pub fn vips__region_check_ownership(reg: *mut _VipsRegion);
}
extern "C" {
    #[link_name = "\u{1}_vips__region_no_ownership"]
    pub fn vips__region_no_ownership(reg: *mut _VipsRegion);
}
pub type VipsRegionFillFn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _VipsRegion,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[link_name = "\u{1}_vips_region_fill"]
    pub fn vips_region_fill(
        reg: *mut _VipsRegion,
        r: *const VipsRect,
        fn_: VipsRegionFillFn,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__image_wio_output"]
    pub fn vips__image_wio_output(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__image_pio_output"]
    pub fn vips__image_pio_output(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__argument_get_instance"]
    pub fn vips__argument_get_instance(
        argument_class: *mut VipsArgumentClass,
        object: *mut VipsObject,
    ) -> *mut VipsArgumentInstance;
}
extern "C" {
    #[link_name = "\u{1}_vips__argument_table_lookup"]
    pub fn vips__argument_table_lookup(
        table: *mut VipsArgumentTable,
        pspec: *mut GParamSpec,
    ) -> *mut VipsArgument;
}
extern "C" {
    #[link_name = "\u{1}_vips__demand_hint_array"]
    pub fn vips__demand_hint_array(
        image: *mut _VipsImage,
        hint: ::std::os::raw::c_int,
        in_: *mut *mut _VipsImage,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips__image_copy_fields_array"]
    pub fn vips__image_copy_fields_array(
        out: *mut _VipsImage,
        in_: *mut *mut _VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__region_count_pixels"]
    pub fn vips__region_count_pixels(
        region: *mut _VipsRegion,
        nickname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_region_dump_all"]
    pub fn vips_region_dump_all();
}
extern "C" {
    #[link_name = "\u{1}_vips__init"]
    pub fn vips__init(argv0: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__get_sizeof_vipsobject"]
    pub fn vips__get_sizeof_vipsobject() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_prepare_many"]
    pub fn vips_region_prepare_many(
        reg: *mut *mut _VipsRegion,
        r: *const VipsRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips__view_image"]
    pub fn vips__view_image(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__vips__argument_id"]
    pub static mut _vips__argument_id: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct im__INTMASK {
    pub xsize: ::std::os::raw::c_int,
    pub ysize: ::std::os::raw::c_int,
    pub scale: ::std::os::raw::c_int,
    pub offset: ::std::os::raw::c_int,
    pub coeff: *mut ::std::os::raw::c_int,
    pub filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_im__INTMASK() {
    assert_eq!(
        ::std::mem::size_of::<im__INTMASK>(),
        32usize,
        concat!("Size of: ", stringify!(im__INTMASK))
    );
    assert_eq!(
        ::std::mem::align_of::<im__INTMASK>(),
        8usize,
        concat!("Alignment of ", stringify!(im__INTMASK))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__INTMASK>())).xsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__INTMASK>())).ysize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(ysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__INTMASK>())).scale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__INTMASK>())).offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__INTMASK>())).coeff as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__INTMASK>())).filename as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(im__INTMASK),
            "::",
            stringify!(filename)
        )
    );
}
pub type INTMASK = im__INTMASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct im__DOUBLEMASK {
    pub xsize: ::std::os::raw::c_int,
    pub ysize: ::std::os::raw::c_int,
    pub scale: f64,
    pub offset: f64,
    pub coeff: *mut f64,
    pub filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_im__DOUBLEMASK() {
    assert_eq!(
        ::std::mem::size_of::<im__DOUBLEMASK>(),
        40usize,
        concat!("Size of: ", stringify!(im__DOUBLEMASK))
    );
    assert_eq!(
        ::std::mem::align_of::<im__DOUBLEMASK>(),
        8usize,
        concat!("Alignment of ", stringify!(im__DOUBLEMASK))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__DOUBLEMASK>())).xsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__DOUBLEMASK>())).ysize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(ysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__DOUBLEMASK>())).scale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__DOUBLEMASK>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__DOUBLEMASK>())).coeff as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<im__DOUBLEMASK>())).filename as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(im__DOUBLEMASK),
            "::",
            stringify!(filename)
        )
    );
}
pub type DOUBLEMASK = im__DOUBLEMASK;
extern "C" {
    #[link_name = "\u{1}_im_create_imask"]
    pub fn im_create_imask(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_create_imaskv"]
    pub fn im_create_imaskv(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        ...
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_create_dmask"]
    pub fn im_create_dmask(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_create_dmaskv"]
    pub fn im_create_dmaskv(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        ...
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_read_imask"]
    pub fn im_read_imask(filename: *const ::std::os::raw::c_char) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_read_dmask"]
    pub fn im_read_dmask(filename: *const ::std::os::raw::c_char) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_print_imask"]
    pub fn im_print_imask(in_: *mut INTMASK);
}
extern "C" {
    #[link_name = "\u{1}_im_print_dmask"]
    pub fn im_print_dmask(in_: *mut DOUBLEMASK);
}
extern "C" {
    #[link_name = "\u{1}_im_write_imask"]
    pub fn im_write_imask(in_: *mut INTMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_write_dmask"]
    pub fn im_write_dmask(in_: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_write_imask_name"]
    pub fn im_write_imask_name(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_write_dmask_name"]
    pub fn im_write_dmask_name(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_free_imask"]
    pub fn im_free_imask(in_: *mut INTMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_free_dmask"]
    pub fn im_free_dmask(in_: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_log_imask"]
    pub fn im_log_imask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_log_dmask"]
    pub fn im_log_dmask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_gauss_imask"]
    pub fn im_gauss_imask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_gauss_imask_sep"]
    pub fn im_gauss_imask_sep(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_gauss_dmask"]
    pub fn im_gauss_dmask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_gauss_dmask_sep"]
    pub fn im_gauss_dmask_sep(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_dup_imask"]
    pub fn im_dup_imask(in_: *mut INTMASK, filename: *const ::std::os::raw::c_char)
        -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_dup_dmask"]
    pub fn im_dup_dmask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_scale_dmask"]
    pub fn im_scale_dmask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_norm_dmask"]
    pub fn im_norm_dmask(mask: *mut DOUBLEMASK);
}
extern "C" {
    #[link_name = "\u{1}_im_imask2dmask"]
    pub fn im_imask2dmask(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_dmask2imask"]
    pub fn im_dmask2imask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_rotate_imask90"]
    pub fn im_rotate_imask90(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_rotate_imask45"]
    pub fn im_rotate_imask45(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_rotate_dmask90"]
    pub fn im_rotate_dmask90(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_rotate_dmask45"]
    pub fn im_rotate_dmask45(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_mattrn"]
    pub fn im_mattrn(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_matcat"]
    pub fn im_matcat(
        top: *mut DOUBLEMASK,
        bottom: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_matmul"]
    pub fn im_matmul(
        in1: *mut DOUBLEMASK,
        in2: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_lu_decomp"]
    pub fn im_lu_decomp(
        mat: *const DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_lu_solve"]
    pub fn im_lu_solve(lu: *const DOUBLEMASK, vec: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_matinv"]
    pub fn im_matinv(
        mat: *const DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_matinv_inplace"]
    pub fn im_matinv_inplace(mat: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_local_dmask"]
    pub fn im_local_dmask(out: *mut _VipsImage, mask: *mut DOUBLEMASK) -> *mut DOUBLEMASK;
}
extern "C" {
    #[link_name = "\u{1}_im_local_imask"]
    pub fn im_local_imask(out: *mut _VipsImage, mask: *mut INTMASK) -> *mut INTMASK;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsDemandStyle {
    VIPS_DEMAND_STYLE_ERROR = -1,
    VIPS_DEMAND_STYLE_SMALLTILE = 0,
    VIPS_DEMAND_STYLE_FATSTRIP = 1,
    VIPS_DEMAND_STYLE_THINSTRIP = 2,
    VIPS_DEMAND_STYLE_ANY = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsImageType {
    VIPS_IMAGE_ERROR = -1,
    VIPS_IMAGE_NONE = 0,
    VIPS_IMAGE_SETBUF = 1,
    VIPS_IMAGE_SETBUF_FOREIGN = 2,
    VIPS_IMAGE_OPENIN = 3,
    VIPS_IMAGE_MMAPIN = 4,
    VIPS_IMAGE_MMAPINRW = 5,
    VIPS_IMAGE_OPENOUT = 6,
    VIPS_IMAGE_PARTIAL = 7,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsInterpretation {
    VIPS_INTERPRETATION_ERROR = -1,
    VIPS_INTERPRETATION_MULTIBAND = 0,
    VIPS_INTERPRETATION_B_W = 1,
    VIPS_INTERPRETATION_HISTOGRAM = 10,
    VIPS_INTERPRETATION_XYZ = 12,
    VIPS_INTERPRETATION_LAB = 13,
    VIPS_INTERPRETATION_CMYK = 15,
    VIPS_INTERPRETATION_LABQ = 16,
    VIPS_INTERPRETATION_RGB = 17,
    VIPS_INTERPRETATION_CMC = 18,
    VIPS_INTERPRETATION_LCH = 19,
    VIPS_INTERPRETATION_LABS = 21,
    VIPS_INTERPRETATION_sRGB = 22,
    VIPS_INTERPRETATION_YXY = 23,
    VIPS_INTERPRETATION_FOURIER = 24,
    VIPS_INTERPRETATION_RGB16 = 25,
    VIPS_INTERPRETATION_GREY16 = 26,
    VIPS_INTERPRETATION_MATRIX = 27,
    VIPS_INTERPRETATION_scRGB = 28,
    VIPS_INTERPRETATION_HSV = 29,
    VIPS_INTERPRETATION_LAST = 30,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsBandFormat {
    VIPS_FORMAT_NOTSET = -1,
    VIPS_FORMAT_UCHAR = 0,
    VIPS_FORMAT_CHAR = 1,
    VIPS_FORMAT_USHORT = 2,
    VIPS_FORMAT_SHORT = 3,
    VIPS_FORMAT_UINT = 4,
    VIPS_FORMAT_INT = 5,
    VIPS_FORMAT_FLOAT = 6,
    VIPS_FORMAT_COMPLEX = 7,
    VIPS_FORMAT_DOUBLE = 8,
    VIPS_FORMAT_DPCOMPLEX = 9,
    VIPS_FORMAT_LAST = 10,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsCoding {
    VIPS_CODING_ERROR = -1,
    VIPS_CODING_NONE = 0,
    VIPS_CODING_LABQ = 2,
    VIPS_CODING_RAD = 6,
    VIPS_CODING_LAST = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsAccess {
    VIPS_ACCESS_RANDOM = 0,
    VIPS_ACCESS_SEQUENTIAL = 1,
    VIPS_ACCESS_SEQUENTIAL_UNBUFFERED = 2,
    VIPS_ACCESS_LAST = 3,
}
pub type VipsStartFn = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut _VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsGenerateFn = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut _VipsRegion,
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        stop: *mut gboolean,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsStopFn = ::std::option::Option<
    unsafe extern "C" fn(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsProgress {
    pub im: *mut _VipsImage,
    pub run: ::std::os::raw::c_int,
    pub eta: ::std::os::raw::c_int,
    pub tpels: gint64,
    pub npels: gint64,
    pub percent: ::std::os::raw::c_int,
    pub start: *mut GTimer,
}
#[test]
fn bindgen_test_layout__VipsProgress() {
    assert_eq!(
        ::std::mem::size_of::<_VipsProgress>(),
        48usize,
        concat!("Size of: ", stringify!(_VipsProgress))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsProgress>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsProgress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsProgress>())).im as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsProgress>())).run as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsProgress>())).eta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(eta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsProgress>())).tpels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(tpels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsProgress>())).npels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(npels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsProgress>())).percent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsProgress>())).start as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsProgress),
            "::",
            stringify!(start)
        )
    );
}
pub type VipsProgress = _VipsProgress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsImage {
    pub parent_instance: VipsObject,
    pub Xsize: ::std::os::raw::c_int,
    pub Ysize: ::std::os::raw::c_int,
    pub Bands: ::std::os::raw::c_int,
    pub BandFmt: VipsBandFormat,
    pub Coding: VipsCoding,
    pub Type: VipsInterpretation,
    pub Xres: f64,
    pub Yres: f64,
    pub Xoffset: ::std::os::raw::c_int,
    pub Yoffset: ::std::os::raw::c_int,
    pub Length: ::std::os::raw::c_int,
    pub Compression: ::std::os::raw::c_short,
    pub Level: ::std::os::raw::c_short,
    pub Bbits: ::std::os::raw::c_int,
    pub time: *mut VipsProgress,
    pub Hist: *mut ::std::os::raw::c_char,
    pub filename: *mut ::std::os::raw::c_char,
    pub data: *mut VipsPel,
    pub kill: ::std::os::raw::c_int,
    pub Xres_float: f32,
    pub Yres_float: f32,
    pub mode: *mut ::std::os::raw::c_char,
    pub dtype: VipsImageType,
    pub fd: ::std::os::raw::c_int,
    pub baseaddr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub magic: guint32,
    pub start_fn: VipsStartFn,
    pub generate_fn: VipsGenerateFn,
    pub stop_fn: VipsStopFn,
    pub client1: *mut ::std::os::raw::c_void,
    pub client2: *mut ::std::os::raw::c_void,
    pub sslock: *mut GMutex,
    pub regions: *mut GSList,
    pub dhint: VipsDemandStyle,
    pub meta: *mut GHashTable,
    pub meta_traverse: *mut GSList,
    pub sizeof_header: gint64,
    pub windows: *mut GSList,
    pub upstream: *mut GSList,
    pub downstream: *mut GSList,
    pub serial: ::std::os::raw::c_int,
    pub history_list: *mut GSList,
    pub progress_signal: *mut _VipsImage,
    pub file_length: gint64,
    pub hint_set: gboolean,
    pub delete_on_close: gboolean,
    pub delete_on_close_filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsImage() {
    assert_eq!(
        ::std::mem::size_of::<_VipsImage>(),
        392usize,
        concat!("Size of: ", stringify!(_VipsImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsImage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Xsize as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Xsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Ysize as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Ysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Bands as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Bands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).BandFmt as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(BandFmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Coding as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Coding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Type as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Xres as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Yres as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Xoffset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Xoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Yoffset as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Yoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Length as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Compression as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Compression)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Level as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Bbits as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Bbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).time as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Hist as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Hist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).filename as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).data as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).kill as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Xres_float as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Xres_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).Yres_float as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(Yres_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).dtype as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(dtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).fd as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).baseaddr as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(baseaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).length as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).magic as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).start_fn as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(start_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).generate_fn as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(generate_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).stop_fn as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(stop_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).client1 as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(client1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).client2 as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(client2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).sslock as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(sslock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).regions as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(regions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).dhint as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(dhint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).meta as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).meta_traverse as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(meta_traverse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).sizeof_header as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(sizeof_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).windows as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(windows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).upstream as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(upstream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).downstream as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(downstream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).serial as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).history_list as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(history_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).progress_signal as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(progress_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).file_length as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(file_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).hint_set as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(hint_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImage>())).delete_on_close as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(delete_on_close)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsImage>())).delete_on_close_filename as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImage),
            "::",
            stringify!(delete_on_close_filename)
        )
    );
}
pub type VipsImage = _VipsImage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsImageClass {
    pub parent_class: VipsObjectClass,
    pub preeval: ::std::option::Option<
        unsafe extern "C" fn(image: *mut VipsImage, progress: *mut VipsProgress),
    >,
    pub eval: ::std::option::Option<
        unsafe extern "C" fn(image: *mut VipsImage, progress: *mut VipsProgress),
    >,
    pub posteval: ::std::option::Option<
        unsafe extern "C" fn(image: *mut VipsImage, progress: *mut VipsProgress),
    >,
    pub written: ::std::option::Option<
        unsafe extern "C" fn(image: *mut VipsImage, result: *mut ::std::os::raw::c_int),
    >,
    pub invalidate: ::std::option::Option<unsafe extern "C" fn(image: *mut VipsImage)>,
    pub minimise: ::std::option::Option<unsafe extern "C" fn(image: *mut VipsImage)>,
}
#[test]
fn bindgen_test_layout__VipsImageClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsImageClass>(),
        376usize,
        concat!("Size of: ", stringify!(_VipsImageClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsImageClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsImageClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImageClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImageClass>())).preeval as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(preeval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImageClass>())).eval as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(eval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImageClass>())).posteval as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(posteval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImageClass>())).written as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(written)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImageClass>())).invalidate as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(invalidate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsImageClass>())).minimise as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsImageClass),
            "::",
            stringify!(minimise)
        )
    );
}
pub type VipsImageClass = _VipsImageClass;
extern "C" {
    #[link_name = "\u{1}_vips_image_get_type"]
    pub fn vips_image_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_progress_set"]
    pub fn vips_progress_set(progress: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_vips_image_invalidate_all"]
    pub fn vips_image_invalidate_all(image: *mut VipsImage);
}
extern "C" {
    #[link_name = "\u{1}_vips_image_minimise_all"]
    pub fn vips_image_minimise_all(image: *mut VipsImage);
}
extern "C" {
    #[link_name = "\u{1}_vips_image_set_progress"]
    pub fn vips_image_set_progress(image: *mut VipsImage, progress: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_vips_filename_get_filename"]
    pub fn vips_filename_get_filename(
        vips_filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_filename_get_options"]
    pub fn vips_filename_get_options(
        vips_filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new"]
    pub fn vips_image_new() -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_memory"]
    pub fn vips_image_new_memory() -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_memory"]
    pub fn vips_image_memory() -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_from_file"]
    pub fn vips_image_new_from_file(name: *const ::std::os::raw::c_char, ...) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_from_file_RW"]
    pub fn vips_image_new_from_file_RW(filename: *const ::std::os::raw::c_char) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_from_file_raw"]
    pub fn vips_image_new_from_file_raw(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        offset: guint64,
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_from_memory"]
    pub fn vips_image_new_from_memory(
        data: *const ::std::os::raw::c_void,
        size: usize,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_from_memory_copy"]
    pub fn vips_image_new_from_memory_copy(
        data: *const ::std::os::raw::c_void,
        size: usize,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_from_buffer"]
    pub fn vips_image_new_from_buffer(
        buf: *const ::std::os::raw::c_void,
        len: usize,
        option_string: *const ::std::os::raw::c_char,
        ...
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_matrix"]
    pub fn vips_image_new_matrix(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_matrixv"]
    pub fn vips_image_new_matrixv(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_matrix_from_array"]
    pub fn vips_image_new_matrix_from_array(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        array: *const f64,
        size: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_matrix_from_array"]
    pub fn vips_image_matrix_from_array(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        array: *const f64,
        size: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_from_image"]
    pub fn vips_image_new_from_image(
        image: *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_from_image1"]
    pub fn vips_image_new_from_image1(image: *mut VipsImage, c: f64) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_set_delete_on_close"]
    pub fn vips_image_set_delete_on_close(image: *mut VipsImage, delete_on_close: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_vips_get_disc_threshold"]
    pub fn vips_get_disc_threshold() -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_new_temp_file"]
    pub fn vips_image_new_temp_file(format: *const ::std::os::raw::c_char) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_write"]
    pub fn vips_image_write(image: *mut VipsImage, out: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_write_to_file"]
    pub fn vips_image_write_to_file(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_write_to_buffer"]
    pub fn vips_image_write_to_buffer(
        in_: *mut VipsImage,
        suffix: *const ::std::os::raw::c_char,
        buf: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_write_to_memory"]
    pub fn vips_image_write_to_memory(
        in_: *mut VipsImage,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_decode_predict"]
    pub fn vips_image_decode_predict(
        in_: *mut VipsImage,
        bands: *mut ::std::os::raw::c_int,
        format: *mut VipsBandFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_decode"]
    pub fn vips_image_decode(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_encode"]
    pub fn vips_image_encode(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        coding: VipsCoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_isMSBfirst"]
    pub fn vips_image_isMSBfirst(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_isfile"]
    pub fn vips_image_isfile(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_ispartial"]
    pub fn vips_image_ispartial(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_hasalpha"]
    pub fn vips_image_hasalpha(image: *mut VipsImage) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_copy_memory"]
    pub fn vips_image_copy_memory(image: *mut VipsImage) -> *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_wio_input"]
    pub fn vips_image_wio_input(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_pio_input"]
    pub fn vips_image_pio_input(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_pio_output"]
    pub fn vips_image_pio_output(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_inplace"]
    pub fn vips_image_inplace(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_write_prepare"]
    pub fn vips_image_write_prepare(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_write_line"]
    pub fn vips_image_write_line(
        image: *mut VipsImage,
        ypos: ::std::os::raw::c_int,
        linebuffer: *mut VipsPel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_band_format_isint"]
    pub fn vips_band_format_isint(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_band_format_isuint"]
    pub fn vips_band_format_isuint(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_band_format_is8bit"]
    pub fn vips_band_format_is8bit(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_band_format_isfloat"]
    pub fn vips_band_format_isfloat(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_band_format_iscomplex"]
    pub fn vips_band_format_iscomplex(format: VipsBandFormat) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_system"]
    pub fn vips_system(cmd_format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_image_new"]
    pub fn vips_array_image_new(
        array: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_image_newv"]
    pub fn vips_array_image_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_image_new_from_string"]
    pub fn vips_array_image_new_from_string(
        string: *const ::std::os::raw::c_char,
        flags: VipsAccess,
    ) -> *mut VipsArrayImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_image_empty"]
    pub fn vips_array_image_empty() -> *mut VipsArrayImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_image_append"]
    pub fn vips_array_image_append(
        array: *mut VipsArrayImage,
        image: *mut VipsImage,
    ) -> *mut VipsArrayImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_array_image_get"]
    pub fn vips_array_image_get(
        array: *mut VipsArrayImage,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_get_array_image"]
    pub fn vips_value_get_array_image(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_value_set_array_image"]
    pub fn vips_value_set_array_image(value: *mut GValue, n: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips_reorder_prepare_many"]
    pub fn vips_reorder_prepare_many(
        image: *mut VipsImage,
        regions: *mut *mut _VipsRegion,
        r: *mut VipsRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_reorder_margin_hint"]
    pub fn vips_reorder_margin_hint(image: *mut VipsImage, margin: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips_malloc"]
    pub fn vips_malloc(object: *mut VipsObject, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_strdup"]
    pub fn vips_strdup(
        object: *mut VipsObject,
        str: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_free"]
    pub fn vips_free(buf: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tracked_free"]
    pub fn vips_tracked_free(s: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_vips_tracked_malloc"]
    pub fn vips_tracked_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_tracked_get_mem"]
    pub fn vips_tracked_get_mem() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_vips_tracked_get_mem_highwater"]
    pub fn vips_tracked_get_mem_highwater() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_vips_tracked_get_allocs"]
    pub fn vips_tracked_get_allocs() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tracked_open"]
    pub fn vips_tracked_open(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tracked_close"]
    pub fn vips_tracked_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tracked_get_files"]
    pub fn vips_tracked_get_files() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_error_buffer"]
    pub fn vips_error_buffer() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_error_clear"]
    pub fn vips_error_clear();
}
extern "C" {
    #[link_name = "\u{1}_vips_error_freeze"]
    pub fn vips_error_freeze();
}
extern "C" {
    #[link_name = "\u{1}_vips_error_thaw"]
    pub fn vips_error_thaw();
}
extern "C" {
    #[link_name = "\u{1}_vips_error"]
    pub fn vips_error(
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_verror"]
    pub fn vips_verror(
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_error_system"]
    pub fn vips_error_system(
        err: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_verror_system"]
    pub fn vips_verror_system(
        err: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_error_g"]
    pub fn vips_error_g(error: *mut *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_vips_g_error"]
    pub fn vips_g_error(error: *mut *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_vips_error_exit"]
    pub fn vips_error_exit(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_vips_check_uncoded"]
    pub fn vips_check_uncoded(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_coding"]
    pub fn vips_check_coding(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        coding: VipsCoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_coding_known"]
    pub fn vips_check_coding_known(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_coding_noneorlabq"]
    pub fn vips_check_coding_noneorlabq(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_coding_same"]
    pub fn vips_check_coding_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_mono"]
    pub fn vips_check_mono(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_bands"]
    pub fn vips_check_bands(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bands: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_bands_1or3"]
    pub fn vips_check_bands_1or3(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_bands_atleast"]
    pub fn vips_check_bands_atleast(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bands: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_bands_1orn"]
    pub fn vips_check_bands_1orn(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_bands_1orn_unary"]
    pub fn vips_check_bands_1orn_unary(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_bands_same"]
    pub fn vips_check_bands_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_bandno"]
    pub fn vips_check_bandno(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bandno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_int"]
    pub fn vips_check_int(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_uint"]
    pub fn vips_check_uint(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_uintorf"]
    pub fn vips_check_uintorf(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_noncomplex"]
    pub fn vips_check_noncomplex(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_complex"]
    pub fn vips_check_complex(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_twocomponents"]
    pub fn vips_check_twocomponents(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_format"]
    pub fn vips_check_format(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        fmt: VipsBandFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_u8or16"]
    pub fn vips_check_u8or16(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_8or16"]
    pub fn vips_check_8or16(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_u8or16orf"]
    pub fn vips_check_u8or16orf(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_format_same"]
    pub fn vips_check_format_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_size_same"]
    pub fn vips_check_size_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_oddsquare"]
    pub fn vips_check_oddsquare(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_vector_length"]
    pub fn vips_check_vector_length(
        domain: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_vector"]
    pub fn vips_check_vector(
        domain: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_hist"]
    pub fn vips_check_hist(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_matrix"]
    pub fn vips_check_matrix(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        out: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_separable"]
    pub fn vips_check_separable(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_check_precision_intfloat"]
    pub fn vips_check_precision_intfloat(
        domain: *const ::std::os::raw::c_char,
        precision: VipsPrecision,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsFormatFlags {
    VIPS_FORMAT_NONE = 0,
    VIPS_FORMAT_PARTIAL = 1,
    VIPS_FORMAT_BIGENDIAN = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsFormat {
    pub parent_object: VipsObject,
}
#[test]
fn bindgen_test_layout__VipsFormat() {
    assert_eq!(
        ::std::mem::size_of::<_VipsFormat>(),
        80usize,
        concat!("Size of: ", stringify!(_VipsFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormat>())).parent_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormat),
            "::",
            stringify!(parent_object)
        )
    );
}
pub type VipsFormat = _VipsFormat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsFormatClass {
    pub parent_class: VipsObjectClass,
    pub is_a: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> gboolean,
    >,
    pub header: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut VipsImage,
        ) -> ::std::os::raw::c_int,
    >,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut VipsImage,
        ) -> ::std::os::raw::c_int,
    >,
    pub save: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsImage,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_flags: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> VipsFormatFlags,
    >,
    pub priority: ::std::os::raw::c_int,
    pub suffs: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsFormatClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsFormatClass>(),
        384usize,
        concat!("Size of: ", stringify!(_VipsFormatClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsFormatClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsFormatClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormatClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormatClass>())).is_a as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(is_a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormatClass>())).header as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormatClass>())).load as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormatClass>())).save as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(save)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormatClass>())).get_flags as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(get_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormatClass>())).priority as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsFormatClass>())).suffs as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsFormatClass),
            "::",
            stringify!(suffs)
        )
    );
}
pub type VipsFormatClass = _VipsFormatClass;
extern "C" {
    #[link_name = "\u{1}_vips_format_get_type"]
    pub fn vips_format_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_format_map"]
    pub fn vips_format_map(
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_format_for_file"]
    pub fn vips_format_for_file(filename: *const ::std::os::raw::c_char) -> *mut VipsFormatClass;
}
extern "C" {
    #[link_name = "\u{1}_vips_format_for_name"]
    pub fn vips_format_for_name(filename: *const ::std::os::raw::c_char) -> *mut VipsFormatClass;
}
extern "C" {
    #[link_name = "\u{1}_vips_format_get_flags"]
    pub fn vips_format_get_flags(
        format: *mut VipsFormatClass,
        filename: *const ::std::os::raw::c_char,
    ) -> VipsFormatFlags;
}
extern "C" {
    #[link_name = "\u{1}_vips_format_read"]
    pub fn vips_format_read(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_format_write"]
    pub fn vips_format_write(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_jpeg2vips"]
    pub fn im_jpeg2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_bufjpeg2vips"]
    pub fn im_bufjpeg2vips(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut VipsImage,
        header_only: gboolean,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2jpeg"]
    pub fn im_vips2jpeg(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2mimejpeg"]
    pub fn im_vips2mimejpeg(
        in_: *mut VipsImage,
        qfac: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2bufjpeg"]
    pub fn im_vips2bufjpeg(
        in_: *mut VipsImage,
        out: *mut VipsImage,
        qfac: ::std::os::raw::c_int,
        obuf: *mut *mut ::std::os::raw::c_char,
        olen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_tiff2vips"]
    pub fn im_tiff2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2tiff"]
    pub fn im_vips2tiff(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_tile_cache"]
    pub fn im_tile_cache(
        in_: *mut VipsImage,
        out: *mut VipsImage,
        tile_width: ::std::os::raw::c_int,
        tile_height: ::std::os::raw::c_int,
        max_tiles: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_magick2vips"]
    pub fn im_magick2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_bufmagick2vips"]
    pub fn im_bufmagick2vips(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut VipsImage,
        header_only: gboolean,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_exr2vips"]
    pub fn im_exr2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_ppm2vips"]
    pub fn im_ppm2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2ppm"]
    pub fn im_vips2ppm(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_analyze2vips"]
    pub fn im_analyze2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_csv2vips"]
    pub fn im_csv2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2csv"]
    pub fn im_vips2csv(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_png2vips"]
    pub fn im_png2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2png"]
    pub fn im_vips2png(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2bufpng"]
    pub fn im_vips2bufpng(
        in_: *mut VipsImage,
        out: *mut VipsImage,
        compression: ::std::os::raw::c_int,
        interlace: ::std::os::raw::c_int,
        obuf: *mut *mut ::std::os::raw::c_char,
        olen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_webp2vips"]
    pub fn im_webp2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2webp"]
    pub fn im_vips2webp(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_raw2vips"]
    pub fn im_raw2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2raw"]
    pub fn im_vips2raw(in_: *mut VipsImage, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_mat2vips"]
    pub fn im_mat2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_rad2vips"]
    pub fn im_rad2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2rad"]
    pub fn im_vips2rad(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_fits2vips"]
    pub fn im_fits2vips(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2fits"]
    pub fn im_vips2fits(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_vips2dz"]
    pub fn im_vips2dz(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " VipsRegionShrink:"]
#[doc = " @VIPS_REGION_SHRINK_MEAN: use the average"]
#[doc = " @VIPS_REGION_SHRINK_MEDIAN: use the median"]
#[doc = " @VIPS_REGION_SHRINK_MODE: use the mode"]
#[doc = ""]
#[doc = " How to calculate the output pixels when shrinking a 2x2 region."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsRegionShrink {
    VIPS_REGION_SHRINK_MEAN = 0,
    VIPS_REGION_SHRINK_MEDIAN = 1,
    VIPS_REGION_SHRINK_MODE = 2,
    VIPS_REGION_SHRINK_LAST = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsRegion {
    pub parent_object: VipsObject,
    pub im: *mut VipsImage,
    pub valid: VipsRect,
    pub type_: RegionType,
    pub data: *mut VipsPel,
    pub bpl: ::std::os::raw::c_int,
    pub seq: *mut ::std::os::raw::c_void,
    pub thread: *mut GThread,
    pub window: *mut VipsWindow,
    pub buffer: *mut VipsBuffer,
    pub invalid: gboolean,
}
#[test]
fn bindgen_test_layout__VipsRegion() {
    assert_eq!(
        ::std::mem::size_of::<_VipsRegion>(),
        168usize,
        concat!("Size of: ", stringify!(_VipsRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsRegion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).parent_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).im as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).valid as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).type_ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).bpl as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(bpl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).seq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).thread as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).window as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).buffer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegion>())).invalid as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegion),
            "::",
            stringify!(invalid)
        )
    );
}
pub type VipsRegion = _VipsRegion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsRegionClass {
    pub parent_class: VipsObjectClass,
}
#[test]
fn bindgen_test_layout__VipsRegionClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsRegionClass>(),
        328usize,
        concat!("Size of: ", stringify!(_VipsRegionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsRegionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsRegionClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsRegionClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsRegionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type VipsRegionClass = _VipsRegionClass;
extern "C" {
    #[link_name = "\u{1}_vips_region_get_type"]
    pub fn vips_region_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_new"]
    pub fn vips_region_new(image: *mut VipsImage) -> *mut VipsRegion;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_buffer"]
    pub fn vips_region_buffer(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_image"]
    pub fn vips_region_image(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_region"]
    pub fn vips_region_region(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_equalsregion"]
    pub fn vips_region_equalsregion(
        reg1: *mut VipsRegion,
        reg2: *mut VipsRegion,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_position"]
    pub fn vips_region_position(
        reg: *mut VipsRegion,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_paint"]
    pub fn vips_region_paint(
        reg: *mut VipsRegion,
        r: *const VipsRect,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_region_paint_pel"]
    pub fn vips_region_paint_pel(reg: *mut VipsRegion, r: *const VipsRect, ink: *const VipsPel);
}
extern "C" {
    #[link_name = "\u{1}_vips_region_black"]
    pub fn vips_region_black(reg: *mut VipsRegion);
}
extern "C" {
    #[link_name = "\u{1}_vips_region_copy"]
    pub fn vips_region_copy(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_region_shrink_method"]
    pub fn vips_region_shrink_method(
        from: *mut VipsRegion,
        to: *mut VipsRegion,
        target: *const VipsRect,
        method: VipsRegionShrink,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_shrink"]
    pub fn vips_region_shrink(
        from: *mut VipsRegion,
        to: *mut VipsRegion,
        target: *const VipsRect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_prepare"]
    pub fn vips_region_prepare(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_prepare_to"]
    pub fn vips_region_prepare_to(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_invalidate"]
    pub fn vips_region_invalidate(reg: *mut VipsRegion);
}
pub type VipsRegionWrite = ::std::option::Option<
    unsafe extern "C" fn(
        region: *mut VipsRegion,
        area: *mut VipsRect,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[link_name = "\u{1}_vips_sink_disc"]
    pub fn vips_sink_disc(
        im: *mut VipsImage,
        write_fn: VipsRegionWrite,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sink"]
    pub fn vips_sink(
        im: *mut VipsImage,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sink_tile"]
    pub fn vips_sink_tile(
        im: *mut VipsImage,
        tile_width: ::std::os::raw::c_int,
        tile_height: ::std::os::raw::c_int,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type VipsSinkNotify = ::std::option::Option<
    unsafe extern "C" fn(im: *mut VipsImage, rect: *mut VipsRect, a: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[link_name = "\u{1}_vips_sink_screen"]
    pub fn vips_sink_screen(
        in_: *mut VipsImage,
        out: *mut VipsImage,
        mask: *mut VipsImage,
        tile_width: ::std::os::raw::c_int,
        tile_height: ::std::os::raw::c_int,
        max_tiles: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
        notify_fn: VipsSinkNotify,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sink_memory"]
    pub fn vips_sink_memory(im: *mut VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_start_one"]
    pub fn vips_start_one(
        out: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_stop_one"]
    pub fn vips_stop_one(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_start_many"]
    pub fn vips_start_many(
        out: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_stop_many"]
    pub fn vips_stop_many(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_allocate_input_array"]
    pub fn vips_allocate_input_array(out: *mut VipsImage, ...) -> *mut *mut VipsImage;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_generate"]
    pub fn vips_image_generate(
        image: *mut VipsImage,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_pipeline_array"]
    pub fn vips_image_pipeline_array(
        image: *mut VipsImage,
        hint: VipsDemandStyle,
        in_: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_pipelinev"]
    pub fn vips_image_pipelinev(
        image: *mut VipsImage,
        hint: VipsDemandStyle,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsInterpolate {
    pub parent_object: VipsObject,
}
#[test]
fn bindgen_test_layout__VipsInterpolate() {
    assert_eq!(
        ::std::mem::size_of::<_VipsInterpolate>(),
        80usize,
        concat!("Size of: ", stringify!(_VipsInterpolate))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsInterpolate>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsInterpolate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsInterpolate>())).parent_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolate),
            "::",
            stringify!(parent_object)
        )
    );
}
pub type VipsInterpolate = _VipsInterpolate;
pub type VipsInterpolateMethod = ::std::option::Option<
    unsafe extern "C" fn(
        interpolate: *mut VipsInterpolate,
        out: *mut ::std::os::raw::c_void,
        in_: *mut VipsRegion,
        x: f64,
        y: f64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsInterpolateClass {
    pub parent_class: VipsObjectClass,
    pub interpolate: VipsInterpolateMethod,
    pub get_window_size: ::std::option::Option<
        unsafe extern "C" fn(interpolate: *mut VipsInterpolate) -> ::std::os::raw::c_int,
    >,
    pub window_size: ::std::os::raw::c_int,
    pub get_window_offset: ::std::option::Option<
        unsafe extern "C" fn(interpolate: *mut VipsInterpolate) -> ::std::os::raw::c_int,
    >,
    pub window_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsInterpolateClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsInterpolateClass>(),
        368usize,
        concat!("Size of: ", stringify!(_VipsInterpolateClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsInterpolateClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsInterpolateClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsInterpolateClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsInterpolateClass>())).interpolate as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(interpolate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsInterpolateClass>())).get_window_size as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(get_window_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsInterpolateClass>())).window_size as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(window_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsInterpolateClass>())).get_window_offset as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(get_window_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsInterpolateClass>())).window_offset as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsInterpolateClass),
            "::",
            stringify!(window_offset)
        )
    );
}
pub type VipsInterpolateClass = _VipsInterpolateClass;
extern "C" {
    #[link_name = "\u{1}_vips_interpolate_get_type"]
    pub fn vips_interpolate_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_interpolate"]
    pub fn vips_interpolate(
        interpolate: *mut VipsInterpolate,
        out: *mut ::std::os::raw::c_void,
        in_: *mut VipsRegion,
        x: f64,
        y: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_interpolate_get_method"]
    pub fn vips_interpolate_get_method(interpolate: *mut VipsInterpolate) -> VipsInterpolateMethod;
}
extern "C" {
    #[link_name = "\u{1}_vips_interpolate_get_window_size"]
    pub fn vips_interpolate_get_window_size(
        interpolate: *mut VipsInterpolate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_interpolate_get_window_offset"]
    pub fn vips_interpolate_get_window_offset(
        interpolate: *mut VipsInterpolate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_interpolate_nearest_static"]
    pub fn vips_interpolate_nearest_static() -> *mut VipsInterpolate;
}
extern "C" {
    #[link_name = "\u{1}_vips_interpolate_bilinear_static"]
    pub fn vips_interpolate_bilinear_static() -> *mut VipsInterpolate;
}
extern "C" {
    #[link_name = "\u{1}_vips_interpolate_new"]
    pub fn vips_interpolate_new(nickname: *const ::std::os::raw::c_char) -> *mut VipsInterpolate;
}
extern "C" {
    #[link_name = "\u{1}_vips_g_mutex_new"]
    pub fn vips_g_mutex_new() -> *mut GMutex;
}
extern "C" {
    #[link_name = "\u{1}_vips_g_mutex_free"]
    pub fn vips_g_mutex_free(arg1: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_vips_g_cond_new"]
    pub fn vips_g_cond_new() -> *mut GCond;
}
extern "C" {
    #[link_name = "\u{1}_vips_g_cond_free"]
    pub fn vips_g_cond_free(arg1: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_vips_g_thread_new"]
    pub fn vips_g_thread_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: GThreadFunc,
        arg3: gpointer,
    ) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_vips_g_thread_join"]
    pub fn vips_g_thread_join(thread: *mut GThread) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_thread_isworker"]
    pub fn vips_thread_isworker() -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VipsSemaphore {
    pub name: *mut ::std::os::raw::c_char,
    pub v: ::std::os::raw::c_int,
    pub mutex: *mut GMutex,
    pub cond: *mut GCond,
}
#[test]
fn bindgen_test_layout_VipsSemaphore() {
    assert_eq!(
        ::std::mem::size_of::<VipsSemaphore>(),
        32usize,
        concat!("Size of: ", stringify!(VipsSemaphore))
    );
    assert_eq!(
        ::std::mem::align_of::<VipsSemaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(VipsSemaphore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsSemaphore>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsSemaphore),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsSemaphore>())).v as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsSemaphore),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsSemaphore>())).mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsSemaphore),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VipsSemaphore>())).cond as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VipsSemaphore),
            "::",
            stringify!(cond)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_semaphore_up"]
    pub fn vips_semaphore_up(s: *mut VipsSemaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_semaphore_down"]
    pub fn vips_semaphore_down(s: *mut VipsSemaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_semaphore_upn"]
    pub fn vips_semaphore_upn(
        s: *mut VipsSemaphore,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_semaphore_downn"]
    pub fn vips_semaphore_downn(
        s: *mut VipsSemaphore,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_semaphore_destroy"]
    pub fn vips_semaphore_destroy(s: *mut VipsSemaphore);
}
extern "C" {
    #[link_name = "\u{1}_vips_semaphore_init"]
    pub fn vips_semaphore_init(
        s: *mut VipsSemaphore,
        v: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsThreadState {
    pub parent_object: VipsObject,
    pub im: *mut VipsImage,
    pub reg: *mut VipsRegion,
    pub pos: VipsRect,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub stop: gboolean,
    pub a: *mut ::std::os::raw::c_void,
    pub stall: gboolean,
}
#[test]
fn bindgen_test_layout__VipsThreadState() {
    assert_eq!(
        ::std::mem::size_of::<_VipsThreadState>(),
        144usize,
        concat!("Size of: ", stringify!(_VipsThreadState))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsThreadState>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsThreadState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).parent_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).im as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).reg as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).pos as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).x as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).y as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).stop as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).a as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsThreadState>())).stall as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadState),
            "::",
            stringify!(stall)
        )
    );
}
pub type VipsThreadState = _VipsThreadState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsThreadStateClass {
    pub parent_class: VipsObjectClass,
}
#[test]
fn bindgen_test_layout__VipsThreadStateClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsThreadStateClass>(),
        328usize,
        concat!("Size of: ", stringify!(_VipsThreadStateClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsThreadStateClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsThreadStateClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsThreadStateClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsThreadStateClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type VipsThreadStateClass = _VipsThreadStateClass;
extern "C" {
    #[link_name = "\u{1}_vips_thread_state_set"]
    pub fn vips_thread_state_set(
        object: *mut VipsObject,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_thread_state_get_type"]
    pub fn vips_thread_state_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_thread_state_new"]
    pub fn vips_thread_state_new(
        im: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut VipsThreadState;
}
pub type VipsThreadStartFn = ::std::option::Option<
    unsafe extern "C" fn(
        im: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut VipsThreadState,
>;
pub type VipsThreadpoolAllocateFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VipsThreadState,
        a: *mut ::std::os::raw::c_void,
        stop: *mut gboolean,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsThreadpoolWorkFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VipsThreadState,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsThreadpoolProgressFn = ::std::option::Option<
    unsafe extern "C" fn(a: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[link_name = "\u{1}_vips_threadpool_run"]
    pub fn vips_threadpool_run(
        im: *mut VipsImage,
        start: VipsThreadStartFn,
        allocate: VipsThreadpoolAllocateFn,
        work: VipsThreadpoolWorkFn,
        progress: VipsThreadpoolProgressFn,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_get_tile_size"]
    pub fn vips_get_tile_size(
        im: *mut VipsImage,
        tile_width: *mut ::std::os::raw::c_int,
        tile_height: *mut ::std::os::raw::c_int,
        n_lines: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_format_sizeof"]
    pub fn vips_format_sizeof(format: VipsBandFormat) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_vips_format_sizeof_unsafe"]
    pub fn vips_format_sizeof_unsafe(format: VipsBandFormat) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_width"]
    pub fn vips_image_get_width(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_height"]
    pub fn vips_image_get_height(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_bands"]
    pub fn vips_image_get_bands(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_format"]
    pub fn vips_image_get_format(image: *const VipsImage) -> VipsBandFormat;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_guess_format"]
    pub fn vips_image_guess_format(image: *const VipsImage) -> VipsBandFormat;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_coding"]
    pub fn vips_image_get_coding(image: *const VipsImage) -> VipsCoding;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_interpretation"]
    pub fn vips_image_get_interpretation(image: *const VipsImage) -> VipsInterpretation;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_guess_interpretation"]
    pub fn vips_image_guess_interpretation(image: *const VipsImage) -> VipsInterpretation;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_xres"]
    pub fn vips_image_get_xres(image: *const VipsImage) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_yres"]
    pub fn vips_image_get_yres(image: *const VipsImage) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_xoffset"]
    pub fn vips_image_get_xoffset(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_yoffset"]
    pub fn vips_image_get_yoffset(image: *const VipsImage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_filename"]
    pub fn vips_image_get_filename(image: *const VipsImage) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_mode"]
    pub fn vips_image_get_mode(image: *const VipsImage) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_scale"]
    pub fn vips_image_get_scale(image: *const VipsImage) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_offset"]
    pub fn vips_image_get_offset(image: *const VipsImage) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_data"]
    pub fn vips_image_get_data(image: *mut VipsImage) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_init_fields"]
    pub fn vips_image_init_fields(
        image: *mut VipsImage,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
        coding: VipsCoding,
        interpretation: VipsInterpretation,
        xres: f64,
        yres: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_image_set"]
    pub fn vips_image_set(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        value: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get"]
    pub fn vips_image_get(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        value_copy: *mut GValue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_as_string"]
    pub fn vips_image_get_as_string(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_typeof"]
    pub fn vips_image_get_typeof(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_remove"]
    pub fn vips_image_remove(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
pub type VipsImageMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        value: *mut GValue,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[link_name = "\u{1}_vips_image_map"]
    pub fn vips_image_map(
        image: *mut VipsImage,
        fn_: VipsImageMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_fields"]
    pub fn vips_image_get_fields(image: *mut VipsImage) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_set_area"]
    pub fn vips_image_set_area(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_area"]
    pub fn vips_image_get_area(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_set_blob"]
    pub fn vips_image_set_blob(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_blob"]
    pub fn vips_image_get_blob(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
        length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_int"]
    pub fn vips_image_get_int(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_set_int"]
    pub fn vips_image_set_int(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_double"]
    pub fn vips_image_get_double(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_set_double"]
    pub fn vips_image_set_double(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        d: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_string"]
    pub fn vips_image_get_string(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_set_string"]
    pub fn vips_image_set_string(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        str: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_vips_image_print_field"]
    pub fn vips_image_print_field(image: *const VipsImage, field: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_vips_image_history_printf"]
    pub fn vips_image_history_printf(
        image: *mut VipsImage,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_history_args"]
    pub fn vips_image_history_args(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_get_history"]
    pub fn vips_image_get_history(image: *mut VipsImage) -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationFlags {
    VIPS_OPERATION_NONE = 0,
    VIPS_OPERATION_SEQUENTIAL = 1,
    VIPS_OPERATION_SEQUENTIAL_UNBUFFERED = 2,
    VIPS_OPERATION_NOCACHE = 4,
    VIPS_OPERATION_DEPRECATED = 8,
}
pub type VipsOperationBuildFn =
    ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject) -> gboolean>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsOperation {
    pub parent_instance: VipsObject,
    pub hash: guint,
    pub found_hash: gboolean,
    pub pixels: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VipsOperation() {
    assert_eq!(
        ::std::mem::size_of::<_VipsOperation>(),
        96usize,
        concat!("Size of: ", stringify!(_VipsOperation))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsOperation>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsOperation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsOperation>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperation),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsOperation>())).hash as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperation),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsOperation>())).found_hash as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperation),
            "::",
            stringify!(found_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsOperation>())).pixels as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperation),
            "::",
            stringify!(pixels)
        )
    );
}
pub type VipsOperation = _VipsOperation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsOperationClass {
    pub parent_class: VipsObjectClass,
    pub usage: ::std::option::Option<
        unsafe extern "C" fn(cls: *mut _VipsOperationClass, buf: *mut VipsBuf),
    >,
    pub get_flags: ::std::option::Option<
        unsafe extern "C" fn(operation: *mut VipsOperation) -> VipsOperationFlags,
    >,
    pub flags: VipsOperationFlags,
    pub invalidate: ::std::option::Option<unsafe extern "C" fn(operation: *mut VipsOperation)>,
}
#[test]
fn bindgen_test_layout__VipsOperationClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsOperationClass>(),
        360usize,
        concat!("Size of: ", stringify!(_VipsOperationClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsOperationClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsOperationClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsOperationClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsOperationClass>())).usage as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsOperationClass>())).get_flags as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(get_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsOperationClass>())).flags as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsOperationClass>())).invalidate as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsOperationClass),
            "::",
            stringify!(invalidate)
        )
    );
}
pub type VipsOperationClass = _VipsOperationClass;
extern "C" {
    #[link_name = "\u{1}_vips_operation_get_type"]
    pub fn vips_operation_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_get_flags"]
    pub fn vips_operation_get_flags(operation: *mut VipsOperation) -> VipsOperationFlags;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_class_print_usage"]
    pub fn vips_operation_class_print_usage(operation_class: *mut VipsOperationClass);
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_invalidate"]
    pub fn vips_operation_invalidate(operation: *mut VipsOperation);
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_call_valist"]
    pub fn vips_operation_call_valist(
        operation: *mut VipsOperation,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_new"]
    pub fn vips_operation_new(name: *const ::std::os::raw::c_char) -> *mut VipsOperation;
}
extern "C" {
    #[link_name = "\u{1}_vips_call_required_optional"]
    pub fn vips_call_required_optional(
        operation: *mut *mut VipsOperation,
        required: *mut __va_list_tag,
        optional: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_call"]
    pub fn vips_call(operation_name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_call_split"]
    pub fn vips_call_split(
        operation_name: *const ::std::os::raw::c_char,
        optional: *mut __va_list_tag,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_call_split_option_string"]
    pub fn vips_call_split_option_string(
        operation_name: *const ::std::os::raw::c_char,
        option_string: *const ::std::os::raw::c_char,
        optional: *mut __va_list_tag,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_call_options"]
    pub fn vips_call_options(group: *mut GOptionGroup, operation: *mut VipsOperation);
}
extern "C" {
    #[link_name = "\u{1}_vips_call_argv"]
    pub fn vips_call_argv(
        operation: *mut VipsOperation,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_drop_all"]
    pub fn vips_cache_drop_all();
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_operation_lookup"]
    pub fn vips_cache_operation_lookup(operation: *mut VipsOperation) -> *mut VipsOperation;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_operation_add"]
    pub fn vips_cache_operation_add(operation: *mut VipsOperation);
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_operation_buildp"]
    pub fn vips_cache_operation_buildp(operation: *mut *mut VipsOperation)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_operation_build"]
    pub fn vips_cache_operation_build(operation: *mut VipsOperation) -> *mut VipsOperation;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_print"]
    pub fn vips_cache_print();
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_set_max"]
    pub fn vips_cache_set_max(max: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_set_max_mem"]
    pub fn vips_cache_set_max_mem(max_mem: usize);
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_get_max"]
    pub fn vips_cache_get_max() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_get_size"]
    pub fn vips_cache_get_size() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_get_max_mem"]
    pub fn vips_cache_get_max_mem() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_get_max_files"]
    pub fn vips_cache_get_max_files() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_set_max_files"]
    pub fn vips_cache_set_max_files(max_files: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_set_dump"]
    pub fn vips_cache_set_dump(dump: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_vips_cache_set_trace"]
    pub fn vips_cache_set_trace(trace: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_vips_concurrency_set"]
    pub fn vips_concurrency_set(concurrency: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_vips_concurrency_get"]
    pub fn vips_concurrency_get() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeign {
    pub parent_object: VipsOperation,
}
#[test]
fn bindgen_test_layout__VipsForeign() {
    assert_eq!(
        ::std::mem::size_of::<_VipsForeign>(),
        96usize,
        concat!("Size of: ", stringify!(_VipsForeign))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeign>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeign))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeign>())).parent_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeign),
            "::",
            stringify!(parent_object)
        )
    );
}
pub type VipsForeign = _VipsForeign;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignClass {
    pub parent_class: VipsOperationClass,
    pub priority: ::std::os::raw::c_int,
    pub suffs: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__VipsForeignClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignClass>(),
        376usize,
        concat!("Size of: ", stringify!(_VipsForeignClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignClass>())).priority as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignClass),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignClass>())).suffs as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignClass),
            "::",
            stringify!(suffs)
        )
    );
}
pub type VipsForeignClass = _VipsForeignClass;
extern "C" {
    #[link_name = "\u{1}_vips_foreign_get_type"]
    pub fn vips_foreign_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_map"]
    pub fn vips_foreign_map(
        base: *const ::std::os::raw::c_char,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignFlags {
    VIPS_FOREIGN_NONE = 0,
    VIPS_FOREIGN_PARTIAL = 1,
    VIPS_FOREIGN_BIGENDIAN = 2,
    VIPS_FOREIGN_SEQUENTIAL = 4,
    VIPS_FOREIGN_ALL = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignLoad {
    pub parent_object: VipsForeign,
    pub memory: gboolean,
    pub access: VipsAccess,
    pub flags: VipsForeignFlags,
    pub fail: gboolean,
    pub sequential: gboolean,
    pub out: *mut VipsImage,
    pub real: *mut VipsImage,
    pub nocache: gboolean,
    pub disc: gboolean,
    pub error: gboolean,
}
#[test]
fn bindgen_test_layout__VipsForeignLoad() {
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignLoad>(),
        152usize,
        concat!("Size of: ", stringify!(_VipsForeignLoad))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignLoad>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignLoad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).parent_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).memory as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).access as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).flags as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).fail as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(fail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).sequential as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(sequential)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).out as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).real as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).nocache as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(nocache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).disc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(disc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoad>())).error as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoad),
            "::",
            stringify!(error)
        )
    );
}
pub type VipsForeignLoad = _VipsForeignLoad;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignLoadClass {
    pub parent_class: VipsForeignClass,
    pub is_a: ::std::option::Option<
        unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> gboolean,
    >,
    pub is_a_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *const ::std::os::raw::c_void, size: usize) -> gboolean,
    >,
    pub get_flags_filename: ::std::option::Option<
        unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> VipsForeignFlags,
    >,
    pub get_flags:
        ::std::option::Option<unsafe extern "C" fn(load: *mut VipsForeignLoad) -> VipsForeignFlags>,
    pub header: ::std::option::Option<
        unsafe extern "C" fn(load: *mut VipsForeignLoad) -> ::std::os::raw::c_int,
    >,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(load: *mut VipsForeignLoad) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__VipsForeignLoadClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignLoadClass>(),
        424usize,
        concat!("Size of: ", stringify!(_VipsForeignLoadClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignLoadClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignLoadClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsForeignLoadClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoadClass>())).is_a as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(is_a)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsForeignLoadClass>())).is_a_buffer as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(is_a_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsForeignLoadClass>())).get_flags_filename as *const _
                as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(get_flags_filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoadClass>())).get_flags as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(get_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoadClass>())).header as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignLoadClass>())).load as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignLoadClass),
            "::",
            stringify!(load)
        )
    );
}
pub type VipsForeignLoadClass = _VipsForeignLoadClass;
extern "C" {
    #[link_name = "\u{1}_vips_foreign_load_get_type"]
    pub fn vips_foreign_load_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_find_load"]
    pub fn vips_foreign_find_load(
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_find_load_buffer"]
    pub fn vips_foreign_find_load_buffer(
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_flags"]
    pub fn vips_foreign_flags(
        loader: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> VipsForeignFlags;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_is_a"]
    pub fn vips_foreign_is_a(
        loader: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_is_a_buffer"]
    pub fn vips_foreign_is_a_buffer(
        loader: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_load_invalidate"]
    pub fn vips_foreign_load_invalidate(image: *mut VipsImage);
}
#[repr(u32)]
#[doc = " VipsSaveable:"]
#[doc = " @VIPS_SAVEABLE_MONO: 1 band (eg. CSV)"]
#[doc = " @VIPS_SAVEABLE_RGB: 1 or 3 bands (eg. PPM)"]
#[doc = " @VIPS_SAVEABLE_RGBA: 1, 2, 3 or 4 bands (eg. PNG)"]
#[doc = " @VIPS_SAVEABLE_RGBA_ONLY: 3 or 4 bands (eg. WEBP)"]
#[doc = " @VIPS_SAVEABLE_RGB_CMYK: 1, 3 or 4 bands (eg. JPEG)"]
#[doc = " @VIPS_SAVEABLE_ANY: any number of bands (eg. TIFF)"]
#[doc = ""]
#[doc = " See also: #VipsForeignSave."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsSaveable {
    VIPS_SAVEABLE_MONO = 0,
    VIPS_SAVEABLE_RGB = 1,
    VIPS_SAVEABLE_RGBA = 2,
    VIPS_SAVEABLE_RGBA_ONLY = 3,
    VIPS_SAVEABLE_RGB_CMYK = 4,
    VIPS_SAVEABLE_ANY = 5,
    VIPS_SAVEABLE_LAST = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignSave {
    pub parent_object: VipsForeign,
    pub strip: gboolean,
    pub background: *mut VipsArrayDouble,
    pub page_height: ::std::os::raw::c_int,
    pub in_: *mut VipsImage,
    pub ready: *mut VipsImage,
}
#[test]
fn bindgen_test_layout__VipsForeignSave() {
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignSave>(),
        136usize,
        concat!("Size of: ", stringify!(_VipsForeignSave))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignSave>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignSave))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignSave>())).parent_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(parent_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignSave>())).strip as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(strip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignSave>())).background as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignSave>())).page_height as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(page_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignSave>())).in_ as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignSave>())).ready as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSave),
            "::",
            stringify!(ready)
        )
    );
}
pub type VipsForeignSave = _VipsForeignSave;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignSaveClass {
    pub parent_class: VipsForeignClass,
    pub saveable: VipsSaveable,
    pub format_table: *mut VipsBandFormat,
    pub coding: [gboolean; 7usize],
}
#[test]
fn bindgen_test_layout__VipsForeignSaveClass() {
    assert_eq!(
        ::std::mem::size_of::<_VipsForeignSaveClass>(),
        424usize,
        concat!("Size of: ", stringify!(_VipsForeignSaveClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_VipsForeignSaveClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_VipsForeignSaveClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsForeignSaveClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSaveClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignSaveClass>())).saveable as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSaveClass),
            "::",
            stringify!(saveable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_VipsForeignSaveClass>())).format_table as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSaveClass),
            "::",
            stringify!(format_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_VipsForeignSaveClass>())).coding as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_VipsForeignSaveClass),
            "::",
            stringify!(coding)
        )
    );
}
pub type VipsForeignSaveClass = _VipsForeignSaveClass;
extern "C" {
    #[link_name = "\u{1}_vips_foreign_save_get_type"]
    pub fn vips_foreign_save_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_find_save"]
    pub fn vips_foreign_find_save(
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_find_save_buffer"]
    pub fn vips_foreign_find_save_buffer(
        suffix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_vipsload"]
    pub fn vips_vipsload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_vipssave"]
    pub fn vips_vipssave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_openslideload"]
    pub fn vips_openslideload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_jpegload"]
    pub fn vips_jpegload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_jpegload_buffer"]
    pub fn vips_jpegload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_jpegsave"]
    pub fn vips_jpegsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_jpegsave_buffer"]
    pub fn vips_jpegsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_jpegsave_mime"]
    pub fn vips_jpegsave_mime(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " VipsForeignWebpPreset:"]
#[doc = " @VIPS_FOREIGN_WEBP_PRESET_DEFAULT: default preset"]
#[doc = " @VIPS_FOREIGN_WEBP_PRESET_PICTURE: digital picture, like portrait, inner shot"]
#[doc = " @VIPS_FOREIGN_WEBP_PRESET_PHOTO: outdoor photograph, with natural lighting"]
#[doc = " @VIPS_FOREIGN_WEBP_PRESET_DRAWING: hand or line drawing, with high-contrast details"]
#[doc = " @VIPS_FOREIGN_WEBP_PRESET_ICON: small-sized colorful images"]
#[doc = " @VIPS_FOREIGN_WEBP_PRESET_TEXT: text-like"]
#[doc = ""]
#[doc = " Tune lossy encoder settings for different image types."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignWebpPreset {
    VIPS_FOREIGN_WEBP_PRESET_DEFAULT = 0,
    VIPS_FOREIGN_WEBP_PRESET_PICTURE = 1,
    VIPS_FOREIGN_WEBP_PRESET_PHOTO = 2,
    VIPS_FOREIGN_WEBP_PRESET_DRAWING = 3,
    VIPS_FOREIGN_WEBP_PRESET_ICON = 4,
    VIPS_FOREIGN_WEBP_PRESET_TEXT = 5,
    VIPS_FOREIGN_WEBP_PRESET_LAST = 6,
}
extern "C" {
    #[link_name = "\u{1}_vips_webpload"]
    pub fn vips_webpload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_webpload_buffer"]
    pub fn vips_webpload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_webpsave"]
    pub fn vips_webpsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_webpsave_buffer"]
    pub fn vips_webpsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_webpsave_mime"]
    pub fn vips_webpsave_mime(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " VipsForeignTiffCompression:"]
#[doc = " @VIPS_FOREIGN_TIFF_COMPRESSION_NONE: no compression"]
#[doc = " @VIPS_FOREIGN_TIFF_COMPRESSION_JPEG: jpeg compression"]
#[doc = " @VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE: deflate (zip) compression"]
#[doc = " @VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS: packbits compression"]
#[doc = " @VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4: fax4 compression"]
#[doc = " @VIPS_FOREIGN_TIFF_COMPRESSION_LZW: LZW compression"]
#[doc = ""]
#[doc = " The compression types supported by the tiff writer."]
#[doc = ""]
#[doc = " Use @Q to set the jpeg compression level, default 75."]
#[doc = ""]
#[doc = " Use @prediction to set the lzw or deflate prediction, default none."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignTiffCompression {
    VIPS_FOREIGN_TIFF_COMPRESSION_NONE = 0,
    VIPS_FOREIGN_TIFF_COMPRESSION_JPEG = 1,
    VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE = 2,
    VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS = 3,
    VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4 = 4,
    VIPS_FOREIGN_TIFF_COMPRESSION_LZW = 5,
    VIPS_FOREIGN_TIFF_COMPRESSION_LAST = 6,
}
#[repr(u32)]
#[doc = " VipsForeignTiffPredictor:"]
#[doc = " @VIPS_FOREIGN_TIFF_PREDICTOR_NONE: no prediction"]
#[doc = " @VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL: horizontal differencing"]
#[doc = " @VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT: float predictor"]
#[doc = ""]
#[doc = " The predictor can help deflate and lzw compression. The values are fixed by"]
#[doc = " the tiff library."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignTiffPredictor {
    VIPS_FOREIGN_TIFF_PREDICTOR_NONE = 1,
    VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL = 2,
    VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT = 3,
    VIPS_FOREIGN_TIFF_PREDICTOR_LAST = 4,
}
#[repr(u32)]
#[doc = " VipsForeignTiffResunit:"]
#[doc = " @VIPS_FOREIGN_TIFF_RESUNIT_CM: use centimeters"]
#[doc = " @VIPS_FOREIGN_TIFF_RESUNIT_INCH: use inches"]
#[doc = ""]
#[doc = " Use inches or centimeters as the resolution unit for a tiff file."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignTiffResunit {
    VIPS_FOREIGN_TIFF_RESUNIT_CM = 0,
    VIPS_FOREIGN_TIFF_RESUNIT_INCH = 1,
    VIPS_FOREIGN_TIFF_RESUNIT_LAST = 2,
}
extern "C" {
    #[link_name = "\u{1}_vips_tiffload"]
    pub fn vips_tiffload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tiffload_buffer"]
    pub fn vips_tiffload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tiffsave"]
    pub fn vips_tiffsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tiffsave_buffer"]
    pub fn vips_tiffsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_openexrload"]
    pub fn vips_openexrload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_fitsload"]
    pub fn vips_fitsload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_fitssave"]
    pub fn vips_fitssave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_analyzeload"]
    pub fn vips_analyzeload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rawload"]
    pub fn vips_rawload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rawsave"]
    pub fn vips_rawsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rawsave_fd"]
    pub fn vips_rawsave_fd(
        in_: *mut VipsImage,
        fd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_csvload"]
    pub fn vips_csvload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_csvsave"]
    pub fn vips_csvsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_matrixload"]
    pub fn vips_matrixload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_matrixsave"]
    pub fn vips_matrixsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_matrixprint"]
    pub fn vips_matrixprint(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_magickload"]
    pub fn vips_magickload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_magickload_buffer"]
    pub fn vips_magickload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_magicksave"]
    pub fn vips_magicksave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_magicksave_buffer"]
    pub fn vips_magicksave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " VipsForeignPngFilter:"]
#[doc = " @VIPS_FOREIGN_PNG_FILTER_NONE: no filtering"]
#[doc = " @VIPS_FOREIGN_PNG_FILTER_SUB: difference to the left"]
#[doc = " @VIPS_FOREIGN_PNG_FILTER_UP: difference up"]
#[doc = " @VIPS_FOREIGN_PNG_FILTER_AVG: average of left and up"]
#[doc = " @VIPS_FOREIGN_PNG_FILTER_PAETH: pick best neighbor predictor automatically"]
#[doc = " @VIPS_FOREIGN_PNG_FILTER_ALL: adaptive"]
#[doc = ""]
#[doc = " http://www.w3.org/TR/PNG-Filters.html"]
#[doc = " The values mirror those of png.h in libpng."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignPngFilter {
    VIPS_FOREIGN_PNG_FILTER_NONE = 8,
    VIPS_FOREIGN_PNG_FILTER_SUB = 16,
    VIPS_FOREIGN_PNG_FILTER_UP = 32,
    VIPS_FOREIGN_PNG_FILTER_AVG = 64,
    VIPS_FOREIGN_PNG_FILTER_PAETH = 128,
    VIPS_FOREIGN_PNG_FILTER_ALL = 248,
}
extern "C" {
    #[link_name = "\u{1}_vips_pngload"]
    pub fn vips_pngload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pngload_buffer"]
    pub fn vips_pngload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pngsave"]
    pub fn vips_pngsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pngsave_buffer"]
    pub fn vips_pngsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_ppmload"]
    pub fn vips_ppmload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_ppmsave"]
    pub fn vips_ppmsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_matload"]
    pub fn vips_matload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_radload"]
    pub fn vips_radload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_radsave"]
    pub fn vips_radsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_radsave_buffer"]
    pub fn vips_radsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pdfload"]
    pub fn vips_pdfload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pdfload_buffer"]
    pub fn vips_pdfload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_svgload"]
    pub fn vips_svgload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_svgload_buffer"]
    pub fn vips_svgload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_gifload"]
    pub fn vips_gifload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_gifload_buffer"]
    pub fn vips_gifload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_niftiload"]
    pub fn vips_niftiload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_niftisave"]
    pub fn vips_niftisave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " VipsForeignDzLayout:"]
#[doc = " @VIPS_FOREIGN_DZ_LAYOUT_DZ: use DeepZoom directory layout"]
#[doc = " @VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY: use Zoomify directory layout"]
#[doc = " @VIPS_FOREIGN_DZ_LAYOUT_GOOGLE: use Google maps directory layout"]
#[doc = ""]
#[doc = " What directory layout and metadata standard to use."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignDzLayout {
    VIPS_FOREIGN_DZ_LAYOUT_DZ = 0,
    VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY = 1,
    VIPS_FOREIGN_DZ_LAYOUT_GOOGLE = 2,
    VIPS_FOREIGN_DZ_LAYOUT_LAST = 3,
}
#[repr(u32)]
#[doc = " VipsForeignDzDepth:"]
#[doc = " @VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL: create layers down to 1x1 pixel"]
#[doc = " @VIPS_FOREIGN_DZ_DEPTH_ONETILE: create layers down to 1x1 tile"]
#[doc = " @VIPS_FOREIGN_DZ_DEPTH_ONE: only create a single layer"]
#[doc = ""]
#[doc = " How many pyramid layers to create."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignDzDepth {
    VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL = 0,
    VIPS_FOREIGN_DZ_DEPTH_ONETILE = 1,
    VIPS_FOREIGN_DZ_DEPTH_ONE = 2,
    VIPS_FOREIGN_DZ_DEPTH_LAST = 3,
}
#[repr(u32)]
#[doc = " VipsForeignDzContainer:"]
#[doc = " @VIPS_FOREIGN_DZ_CONTAINER_FS: write tiles to the filesystem"]
#[doc = " @VIPS_FOREIGN_DZ_CONTAINER_ZIP: write tiles to a zip file"]
#[doc = ""]
#[doc = " How many pyramid layers to create."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsForeignDzContainer {
    VIPS_FOREIGN_DZ_CONTAINER_FS = 0,
    VIPS_FOREIGN_DZ_CONTAINER_ZIP = 1,
    VIPS_FOREIGN_DZ_CONTAINER_LAST = 2,
}
extern "C" {
    #[link_name = "\u{1}_vips_dzsave"]
    pub fn vips_dzsave(
        in_: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_math_get_type"]
    pub fn vips_operation_math_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_math2_get_type"]
    pub fn vips_operation_math2_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_round_get_type"]
    pub fn vips_operation_round_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_relational_get_type"]
    pub fn vips_operation_relational_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_boolean_get_type"]
    pub fn vips_operation_boolean_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_complex_get_type"]
    pub fn vips_operation_complex_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_complex2_get_type"]
    pub fn vips_operation_complex2_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_complexget_get_type"]
    pub fn vips_operation_complexget_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_precision_get_type"]
    pub fn vips_precision_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_intent_get_type"]
    pub fn vips_intent_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_pcs_get_type"]
    pub fn vips_pcs_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_extend_get_type"]
    pub fn vips_extend_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_compass_direction_get_type"]
    pub fn vips_compass_direction_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_direction_get_type"]
    pub fn vips_direction_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_align_get_type"]
    pub fn vips_align_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_angle_get_type"]
    pub fn vips_angle_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_angle45_get_type"]
    pub fn vips_angle45_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_interesting_get_type"]
    pub fn vips_interesting_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_blend_mode_get_type"]
    pub fn vips_blend_mode_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_combine_get_type"]
    pub fn vips_combine_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_combine_mode_get_type"]
    pub fn vips_combine_mode_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_flags_get_type"]
    pub fn vips_foreign_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_saveable_get_type"]
    pub fn vips_saveable_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_webp_preset_get_type"]
    pub fn vips_foreign_webp_preset_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_tiff_compression_get_type"]
    pub fn vips_foreign_tiff_compression_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_tiff_predictor_get_type"]
    pub fn vips_foreign_tiff_predictor_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_tiff_resunit_get_type"]
    pub fn vips_foreign_tiff_resunit_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_png_filter_get_type"]
    pub fn vips_foreign_png_filter_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_dz_layout_get_type"]
    pub fn vips_foreign_dz_layout_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_dz_depth_get_type"]
    pub fn vips_foreign_dz_depth_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_foreign_dz_container_get_type"]
    pub fn vips_foreign_dz_container_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_demand_style_get_type"]
    pub fn vips_demand_style_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_image_type_get_type"]
    pub fn vips_image_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_interpretation_get_type"]
    pub fn vips_interpretation_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_band_format_get_type"]
    pub fn vips_band_format_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_coding_get_type"]
    pub fn vips_coding_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_access_get_type"]
    pub fn vips_access_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_morphology_get_type"]
    pub fn vips_operation_morphology_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_argument_flags_get_type"]
    pub fn vips_argument_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_operation_flags_get_type"]
    pub fn vips_operation_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_region_shrink_get_type"]
    pub fn vips_region_shrink_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_kernel_get_type"]
    pub fn vips_kernel_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_size_get_type"]
    pub fn vips_size_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_vips_token_get_type"]
    pub fn vips_token_get_type() -> GType;
}
#[repr(u32)]
#[doc = " VipsOperationMath:"]
#[doc = " @VIPS_OPERATION_MATH_SIN: sin(), angles in degrees"]
#[doc = " @VIPS_OPERATION_MATH_COS: cos(), angles in degrees"]
#[doc = " @VIPS_OPERATION_MATH_TAN: tan(), angles in degrees"]
#[doc = " @VIPS_OPERATION_MATH_ASIN: asin(), angles in degrees"]
#[doc = " @VIPS_OPERATION_MATH_ACOS: acos(), angles in degrees"]
#[doc = " @VIPS_OPERATION_MATH_ATAN: atan(), angles in degrees"]
#[doc = " @VIPS_OPERATION_MATH_LOG: log base e"]
#[doc = " @VIPS_OPERATION_MATH_LOG10: log base 10"]
#[doc = " @VIPS_OPERATION_MATH_EXP: e to the something"]
#[doc = " @VIPS_OPERATION_MATH_EXP10: 10 to the something"]
#[doc = ""]
#[doc = " See also: vips_math()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationMath {
    VIPS_OPERATION_MATH_SIN = 0,
    VIPS_OPERATION_MATH_COS = 1,
    VIPS_OPERATION_MATH_TAN = 2,
    VIPS_OPERATION_MATH_ASIN = 3,
    VIPS_OPERATION_MATH_ACOS = 4,
    VIPS_OPERATION_MATH_ATAN = 5,
    VIPS_OPERATION_MATH_LOG = 6,
    VIPS_OPERATION_MATH_LOG10 = 7,
    VIPS_OPERATION_MATH_EXP = 8,
    VIPS_OPERATION_MATH_EXP10 = 9,
    VIPS_OPERATION_MATH_LAST = 10,
}
#[repr(u32)]
#[doc = " VipsOperationMath2:"]
#[doc = " @VIPS_OPERATION_MATH2_POW: pow( left, right )"]
#[doc = " @VIPS_OPERATION_MATH2_WOP: pow( right, left )"]
#[doc = ""]
#[doc = " See also: vips_math()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationMath2 {
    VIPS_OPERATION_MATH2_POW = 0,
    VIPS_OPERATION_MATH2_WOP = 1,
    VIPS_OPERATION_MATH2_LAST = 2,
}
#[repr(u32)]
#[doc = " VipsOperationRound:"]
#[doc = " @VIPS_OPERATION_ROUND_RINT: round to nearest"]
#[doc = " @VIPS_OPERATION_ROUND_FLOOR: largest integral value not greater than"]
#[doc = " @VIPS_OPERATION_ROUND_CEIL: the smallest integral value not less than"]
#[doc = ""]
#[doc = " See also: vips_round()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationRound {
    VIPS_OPERATION_ROUND_RINT = 0,
    VIPS_OPERATION_ROUND_CEIL = 1,
    VIPS_OPERATION_ROUND_FLOOR = 2,
    VIPS_OPERATION_ROUND_LAST = 3,
}
#[repr(u32)]
#[doc = " VipsOperationRelational:"]
#[doc = " @VIPS_OPERATION_RELATIONAL_EQUAL: =="]
#[doc = " @VIPS_OPERATION_RELATIONAL_NOTEQ: !="]
#[doc = " @VIPS_OPERATION_RELATIONAL_LESS: <"]
#[doc = " @VIPS_OPERATION_RELATIONAL_LESSEQ: <="]
#[doc = " @VIPS_OPERATION_RELATIONAL_MORE: >"]
#[doc = " @VIPS_OPERATION_RELATIONAL_MOREEQ: >="]
#[doc = ""]
#[doc = " See also: vips_relational()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationRelational {
    VIPS_OPERATION_RELATIONAL_EQUAL = 0,
    VIPS_OPERATION_RELATIONAL_NOTEQ = 1,
    VIPS_OPERATION_RELATIONAL_LESS = 2,
    VIPS_OPERATION_RELATIONAL_LESSEQ = 3,
    VIPS_OPERATION_RELATIONAL_MORE = 4,
    VIPS_OPERATION_RELATIONAL_MOREEQ = 5,
    VIPS_OPERATION_RELATIONAL_LAST = 6,
}
#[repr(u32)]
#[doc = " VipsOperationBoolean:"]
#[doc = " @VIPS_OPERATION_BOOLEAN_AND: &"]
#[doc = " @VIPS_OPERATION_BOOLEAN_OR: |"]
#[doc = " @VIPS_OPERATION_BOOLEAN_EOR: ^"]
#[doc = " @VIPS_OPERATION_BOOLEAN_LSHIFT: >>"]
#[doc = " @VIPS_OPERATION_BOOLEAN_RSHIFT: <<"]
#[doc = ""]
#[doc = " See also: vips_boolean()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationBoolean {
    VIPS_OPERATION_BOOLEAN_AND = 0,
    VIPS_OPERATION_BOOLEAN_OR = 1,
    VIPS_OPERATION_BOOLEAN_EOR = 2,
    VIPS_OPERATION_BOOLEAN_LSHIFT = 3,
    VIPS_OPERATION_BOOLEAN_RSHIFT = 4,
    VIPS_OPERATION_BOOLEAN_LAST = 5,
}
#[repr(u32)]
#[doc = " VipsOperationComplex:"]
#[doc = " @VIPS_OPERATION_COMPLEX_POLAR: convert to polar coordinates"]
#[doc = " @VIPS_OPERATION_COMPLEX_RECT: convert to rectangular coordinates"]
#[doc = " @VIPS_OPERATION_COMPLEX_CONJ: complex conjugate"]
#[doc = ""]
#[doc = " See also: vips_complex()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationComplex {
    VIPS_OPERATION_COMPLEX_POLAR = 0,
    VIPS_OPERATION_COMPLEX_RECT = 1,
    VIPS_OPERATION_COMPLEX_CONJ = 2,
    VIPS_OPERATION_COMPLEX_LAST = 3,
}
#[repr(u32)]
#[doc = " VipsOperationComplex2:"]
#[doc = " @VIPS_OPERATION_COMPLEX2_CROSS_PHASE: convert to polar coordinates"]
#[doc = ""]
#[doc = " See also: vips_complex2()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationComplex2 {
    VIPS_OPERATION_COMPLEX2_CROSS_PHASE = 0,
    VIPS_OPERATION_COMPLEX2_LAST = 1,
}
#[repr(u32)]
#[doc = " VipsOperationComplexget:"]
#[doc = " @VIPS_OPERATION_COMPLEXGET_REAL: get real component"]
#[doc = " @VIPS_OPERATION_COMPLEXGET_IMAG: get imaginary component"]
#[doc = ""]
#[doc = " See also: vips_complexget()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationComplexget {
    VIPS_OPERATION_COMPLEXGET_REAL = 0,
    VIPS_OPERATION_COMPLEXGET_IMAG = 1,
    VIPS_OPERATION_COMPLEXGET_LAST = 2,
}
extern "C" {
    #[link_name = "\u{1}_vips_add"]
    pub fn vips_add(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sum"]
    pub fn vips_sum(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_subtract"]
    pub fn vips_subtract(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_multiply"]
    pub fn vips_multiply(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_divide"]
    pub fn vips_divide(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_linear"]
    pub fn vips_linear(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: *mut f64,
        b: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_linear1"]
    pub fn vips_linear1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: f64,
        b: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_remainder"]
    pub fn vips_remainder(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_remainder_const"]
    pub fn vips_remainder_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_remainder_const1"]
    pub fn vips_remainder_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_invert"]
    pub fn vips_invert(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_abs"]
    pub fn vips_abs(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sign"]
    pub fn vips_sign(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_round"]
    pub fn vips_round(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        round: VipsOperationRound,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_floor"]
    pub fn vips_floor(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_ceil"]
    pub fn vips_ceil(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rint"]
    pub fn vips_rint(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_math"]
    pub fn vips_math(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math: VipsOperationMath,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sin"]
    pub fn vips_sin(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cos"]
    pub fn vips_cos(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tan"]
    pub fn vips_tan(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_asin"]
    pub fn vips_asin(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_acos"]
    pub fn vips_acos(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_atan"]
    pub fn vips_atan(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_exp"]
    pub fn vips_exp(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_exp10"]
    pub fn vips_exp10(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_log"]
    pub fn vips_log(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_log10"]
    pub fn vips_log10(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_complex"]
    pub fn vips_complex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        cmplx: VipsOperationComplex,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_polar"]
    pub fn vips_polar(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rect"]
    pub fn vips_rect(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_conj"]
    pub fn vips_conj(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_complex2"]
    pub fn vips_complex2(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        cmplx: VipsOperationComplex2,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cross_phase"]
    pub fn vips_cross_phase(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_complexget"]
    pub fn vips_complexget(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        get: VipsOperationComplexget,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_real"]
    pub fn vips_real(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_imag"]
    pub fn vips_imag(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_complexform"]
    pub fn vips_complexform(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_relational"]
    pub fn vips_relational(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_equal"]
    pub fn vips_equal(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_notequal"]
    pub fn vips_notequal(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_less"]
    pub fn vips_less(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_lesseq"]
    pub fn vips_lesseq(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_more"]
    pub fn vips_more(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_moreeq"]
    pub fn vips_moreeq(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_relational_const"]
    pub fn vips_relational_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_equal_const"]
    pub fn vips_equal_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_notequal_const"]
    pub fn vips_notequal_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_less_const"]
    pub fn vips_less_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_lesseq_const"]
    pub fn vips_lesseq_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_more_const"]
    pub fn vips_more_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_moreeq_const"]
    pub fn vips_moreeq_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_relational_const1"]
    pub fn vips_relational_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_equal_const1"]
    pub fn vips_equal_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_notequal_const1"]
    pub fn vips_notequal_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_less_const1"]
    pub fn vips_less_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_lesseq_const1"]
    pub fn vips_lesseq_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_more_const1"]
    pub fn vips_more_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_moreeq_const1"]
    pub fn vips_moreeq_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_boolean"]
    pub fn vips_boolean(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_andimage"]
    pub fn vips_andimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_orimage"]
    pub fn vips_orimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_eorimage"]
    pub fn vips_eorimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_lshift"]
    pub fn vips_lshift(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rshift"]
    pub fn vips_rshift(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_boolean_const"]
    pub fn vips_boolean_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_andimage_const"]
    pub fn vips_andimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_orimage_const"]
    pub fn vips_orimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_eorimage_const"]
    pub fn vips_eorimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_lshift_const"]
    pub fn vips_lshift_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rshift_const"]
    pub fn vips_rshift_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_boolean_const1"]
    pub fn vips_boolean_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_andimage_const1"]
    pub fn vips_andimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_orimage_const1"]
    pub fn vips_orimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_eorimage_const1"]
    pub fn vips_eorimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_lshift_const1"]
    pub fn vips_lshift_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rshift_const1"]
    pub fn vips_rshift_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_math2"]
    pub fn vips_math2(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pow"]
    pub fn vips_pow(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_wop"]
    pub fn vips_wop(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_math2_const"]
    pub fn vips_math2_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pow_const"]
    pub fn vips_pow_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_wop_const"]
    pub fn vips_wop_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_math2_const1"]
    pub fn vips_math2_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pow_const1"]
    pub fn vips_pow_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_wop_const1"]
    pub fn vips_wop_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_avg"]
    pub fn vips_avg(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_deviate"]
    pub fn vips_deviate(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_min"]
    pub fn vips_min(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_max"]
    pub fn vips_max(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_stats"]
    pub fn vips_stats(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_measure"]
    pub fn vips_measure(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        h: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_find_trim"]
    pub fn vips_find_trim(
        in_: *mut VipsImage,
        left: *mut ::std::os::raw::c_int,
        top: *mut ::std::os::raw::c_int,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_getpoint"]
    pub fn vips_getpoint(
        in_: *mut VipsImage,
        vector: *mut *mut f64,
        n: *mut ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_find"]
    pub fn vips_hist_find(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_find_ndim"]
    pub fn vips_hist_find_ndim(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_find_indexed"]
    pub fn vips_hist_find_indexed(
        in_: *mut VipsImage,
        index: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hough_line"]
    pub fn vips_hough_line(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hough_circle"]
    pub fn vips_hough_circle(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_project"]
    pub fn vips_project(
        in_: *mut VipsImage,
        columns: *mut *mut VipsImage,
        rows: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_profile"]
    pub fn vips_profile(
        in_: *mut VipsImage,
        columns: *mut *mut VipsImage,
        rows: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsExtend {
    VIPS_EXTEND_BLACK = 0,
    VIPS_EXTEND_COPY = 1,
    VIPS_EXTEND_REPEAT = 2,
    VIPS_EXTEND_MIRROR = 3,
    VIPS_EXTEND_WHITE = 4,
    VIPS_EXTEND_BACKGROUND = 5,
    VIPS_EXTEND_LAST = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsCompassDirection {
    VIPS_COMPASS_DIRECTION_CENTRE = 0,
    VIPS_COMPASS_DIRECTION_NORTH = 1,
    VIPS_COMPASS_DIRECTION_EAST = 2,
    VIPS_COMPASS_DIRECTION_SOUTH = 3,
    VIPS_COMPASS_DIRECTION_WEST = 4,
    VIPS_COMPASS_DIRECTION_NORTH_EAST = 5,
    VIPS_COMPASS_DIRECTION_SOUTH_EAST = 6,
    VIPS_COMPASS_DIRECTION_SOUTH_WEST = 7,
    VIPS_COMPASS_DIRECTION_NORTH_WEST = 8,
    VIPS_COMPASS_DIRECTION_LAST = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsDirection {
    VIPS_DIRECTION_HORIZONTAL = 0,
    VIPS_DIRECTION_VERTICAL = 1,
    VIPS_DIRECTION_LAST = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsAlign {
    VIPS_ALIGN_LOW = 0,
    VIPS_ALIGN_CENTRE = 1,
    VIPS_ALIGN_HIGH = 2,
    VIPS_ALIGN_LAST = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsAngle {
    VIPS_ANGLE_D0 = 0,
    VIPS_ANGLE_D90 = 1,
    VIPS_ANGLE_D180 = 2,
    VIPS_ANGLE_D270 = 3,
    VIPS_ANGLE_LAST = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsAngle45 {
    VIPS_ANGLE45_D0 = 0,
    VIPS_ANGLE45_D45 = 1,
    VIPS_ANGLE45_D90 = 2,
    VIPS_ANGLE45_D135 = 3,
    VIPS_ANGLE45_D180 = 4,
    VIPS_ANGLE45_D225 = 5,
    VIPS_ANGLE45_D270 = 6,
    VIPS_ANGLE45_D315 = 7,
    VIPS_ANGLE45_LAST = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsInteresting {
    VIPS_INTERESTING_NONE = 0,
    VIPS_INTERESTING_CENTRE = 1,
    VIPS_INTERESTING_ENTROPY = 2,
    VIPS_INTERESTING_ATTENTION = 3,
    VIPS_INTERESTING_LAST = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsBlendMode {
    VIPS_BLEND_MODE_CLEAR = 0,
    VIPS_BLEND_MODE_SOURCE = 1,
    VIPS_BLEND_MODE_OVER = 2,
    VIPS_BLEND_MODE_IN = 3,
    VIPS_BLEND_MODE_OUT = 4,
    VIPS_BLEND_MODE_ATOP = 5,
    VIPS_BLEND_MODE_DEST = 6,
    VIPS_BLEND_MODE_DEST_OVER = 7,
    VIPS_BLEND_MODE_DEST_IN = 8,
    VIPS_BLEND_MODE_DEST_OUT = 9,
    VIPS_BLEND_MODE_DEST_ATOP = 10,
    VIPS_BLEND_MODE_XOR = 11,
    VIPS_BLEND_MODE_ADD = 12,
    VIPS_BLEND_MODE_SATURATE = 13,
    VIPS_BLEND_MODE_MULTIPLY = 14,
    VIPS_BLEND_MODE_SCREEN = 15,
    VIPS_BLEND_MODE_OVERLAY = 16,
    VIPS_BLEND_MODE_DARKEN = 17,
    VIPS_BLEND_MODE_LIGHTEN = 18,
    VIPS_BLEND_MODE_COLOUR_DODGE = 19,
    VIPS_BLEND_MODE_COLOUR_BURN = 20,
    VIPS_BLEND_MODE_HARD_LIGHT = 21,
    VIPS_BLEND_MODE_SOFT_LIGHT = 22,
    VIPS_BLEND_MODE_DIFFERENCE = 23,
    VIPS_BLEND_MODE_EXCLUSION = 24,
    VIPS_BLEND_MODE_LAST = 25,
}
extern "C" {
    #[link_name = "\u{1}_vips_copy"]
    pub fn vips_copy(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tilecache"]
    pub fn vips_tilecache(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_linecache"]
    pub fn vips_linecache(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sequential"]
    pub fn vips_sequential(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cache"]
    pub fn vips_cache(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_copy_file"]
    pub fn vips_copy_file(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_embed"]
    pub fn vips_embed(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_gravity"]
    pub fn vips_gravity(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsCompassDirection,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_flip"]
    pub fn vips_flip(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_insert"]
    pub fn vips_insert(
        main: *mut VipsImage,
        sub: *mut VipsImage,
        out: *mut *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_join"]
    pub fn vips_join(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_arrayjoin"]
    pub fn vips_arrayjoin(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_extract_area"]
    pub fn vips_extract_area(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_crop"]
    pub fn vips_crop(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_smartcrop"]
    pub fn vips_smartcrop(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_extract_band"]
    pub fn vips_extract_band(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        band: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_replicate"]
    pub fn vips_replicate(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        across: ::std::os::raw::c_int,
        down: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_grid"]
    pub fn vips_grid(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        tile_height: ::std::os::raw::c_int,
        across: ::std::os::raw::c_int,
        down: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_transpose3d"]
    pub fn vips_transpose3d(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_wrap"]
    pub fn vips_wrap(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rot"]
    pub fn vips_rot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        angle: VipsAngle,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rot90"]
    pub fn vips_rot90(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rot180"]
    pub fn vips_rot180(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rot270"]
    pub fn vips_rot270(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rot45"]
    pub fn vips_rot45(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_autorot_get_angle"]
    pub fn vips_autorot_get_angle(image: *mut VipsImage) -> VipsAngle;
}
extern "C" {
    #[link_name = "\u{1}_vips_autorot_remove_angle"]
    pub fn vips_autorot_remove_angle(image: *mut VipsImage);
}
extern "C" {
    #[link_name = "\u{1}_vips_autorot"]
    pub fn vips_autorot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_zoom"]
    pub fn vips_zoom(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        xfac: ::std::os::raw::c_int,
        yfac: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_subsample"]
    pub fn vips_subsample(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        xfac: ::std::os::raw::c_int,
        yfac: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast"]
    pub fn vips_cast(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        format: VipsBandFormat,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_uchar"]
    pub fn vips_cast_uchar(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_char"]
    pub fn vips_cast_char(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_ushort"]
    pub fn vips_cast_ushort(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_short"]
    pub fn vips_cast_short(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_uint"]
    pub fn vips_cast_uint(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_int"]
    pub fn vips_cast_int(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_float"]
    pub fn vips_cast_float(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_double"]
    pub fn vips_cast_double(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_complex"]
    pub fn vips_cast_complex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_cast_dpcomplex"]
    pub fn vips_cast_dpcomplex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_scale"]
    pub fn vips_scale(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_msb"]
    pub fn vips_msb(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_byteswap"]
    pub fn vips_byteswap(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandjoin"]
    pub fn vips_bandjoin(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandjoin2"]
    pub fn vips_bandjoin2(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandjoin_const"]
    pub fn vips_bandjoin_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandjoin_const1"]
    pub fn vips_bandjoin_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandrank"]
    pub fn vips_bandrank(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandfold"]
    pub fn vips_bandfold(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandunfold"]
    pub fn vips_bandunfold(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandbool"]
    pub fn vips_bandbool(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandand"]
    pub fn vips_bandand(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandor"]
    pub fn vips_bandor(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandeor"]
    pub fn vips_bandeor(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_bandmean"]
    pub fn vips_bandmean(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_recomb"]
    pub fn vips_recomb(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        m: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_ifthenelse"]
    pub fn vips_ifthenelse(
        cond: *mut VipsImage,
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_flatten"]
    pub fn vips_flatten(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_addalpha"]
    pub fn vips_addalpha(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_premultiply"]
    pub fn vips_premultiply(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_unpremultiply"]
    pub fn vips_unpremultiply(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_composite"]
    pub fn vips_composite(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        mode: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_composite2"]
    pub fn vips_composite2(
        base: *mut VipsImage,
        overlay: *mut VipsImage,
        out: *mut *mut VipsImage,
        mode1: VipsBlendMode,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_falsecolour"]
    pub fn vips_falsecolour(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_gamma"]
    pub fn vips_gamma(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsCombine {
    VIPS_COMBINE_MAX = 0,
    VIPS_COMBINE_SUM = 1,
    VIPS_COMBINE_MIN = 2,
    VIPS_COMBINE_LAST = 3,
}
extern "C" {
    #[link_name = "\u{1}_vips_conv"]
    pub fn vips_conv(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_convf"]
    pub fn vips_convf(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_convi"]
    pub fn vips_convi(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_conva"]
    pub fn vips_conva(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_convsep"]
    pub fn vips_convsep(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_convasep"]
    pub fn vips_convasep(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_compass"]
    pub fn vips_compass(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_gaussblur"]
    pub fn vips_gaussblur(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        sigma: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sharpen"]
    pub fn vips_sharpen(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_spcor"]
    pub fn vips_spcor(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_fastcor"]
    pub fn vips_fastcor(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sobel"]
    pub fn vips_sobel(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_canny"]
    pub fn vips_canny(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsOperationMorphology {
    VIPS_OPERATION_MORPHOLOGY_ERODE = 0,
    VIPS_OPERATION_MORPHOLOGY_DILATE = 1,
    VIPS_OPERATION_MORPHOLOGY_LAST = 2,
}
extern "C" {
    #[link_name = "\u{1}_vips_morph"]
    pub fn vips_morph(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        morph: VipsOperationMorphology,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rank"]
    pub fn vips_rank(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_median"]
    pub fn vips_median(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        size: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_countlines"]
    pub fn vips_countlines(
        in_: *mut VipsImage,
        nolines: *mut f64,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_labelregions"]
    pub fn vips_labelregions(
        in_: *mut VipsImage,
        mask: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_fill_nearest"]
    pub fn vips_fill_nearest(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_merge"]
    pub fn vips_merge(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mosaic"]
    pub fn vips_mosaic(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        xref: ::std::os::raw::c_int,
        yref: ::std::os::raw::c_int,
        xsec: ::std::os::raw::c_int,
        ysec: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mosaic1"]
    pub fn vips_mosaic1(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        xr1: ::std::os::raw::c_int,
        yr1: ::std::os::raw::c_int,
        xs1: ::std::os::raw::c_int,
        ys1: ::std::os::raw::c_int,
        xr2: ::std::os::raw::c_int,
        yr2: ::std::os::raw::c_int,
        xs2: ::std::os::raw::c_int,
        ys2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_match"]
    pub fn vips_match(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        xr1: ::std::os::raw::c_int,
        yr1: ::std::os::raw::c_int,
        xs1: ::std::os::raw::c_int,
        ys1: ::std::os::raw::c_int,
        xr2: ::std::os::raw::c_int,
        yr2: ::std::os::raw::c_int,
        xs2: ::std::os::raw::c_int,
        ys2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_globalbalance"]
    pub fn vips_globalbalance(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_remosaic"]
    pub fn vips_remosaic(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        old_str: *const ::std::os::raw::c_char,
        new_str: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_maplut"]
    pub fn vips_maplut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        lut: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_percent"]
    pub fn vips_percent(
        in_: *mut VipsImage,
        percent: f64,
        threshold: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_stdif"]
    pub fn vips_stdif(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_cum"]
    pub fn vips_hist_cum(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_norm"]
    pub fn vips_hist_norm(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_equal"]
    pub fn vips_hist_equal(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_plot"]
    pub fn vips_hist_plot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_match"]
    pub fn vips_hist_match(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_local"]
    pub fn vips_hist_local(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_ismonotonic"]
    pub fn vips_hist_ismonotonic(
        in_: *mut VipsImage,
        out: *mut gboolean,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_hist_entropy"]
    pub fn vips_hist_entropy(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_fwfft"]
    pub fn vips_fwfft(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_invfft"]
    pub fn vips_invfft(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_freqmult"]
    pub fn vips_freqmult(
        in_: *mut VipsImage,
        mask: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_spectrum"]
    pub fn vips_spectrum(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_phasecor"]
    pub fn vips_phasecor(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsKernel {
    VIPS_KERNEL_NEAREST = 0,
    VIPS_KERNEL_LINEAR = 1,
    VIPS_KERNEL_CUBIC = 2,
    VIPS_KERNEL_MITCHELL = 3,
    VIPS_KERNEL_LANCZOS2 = 4,
    VIPS_KERNEL_LANCZOS3 = 5,
    VIPS_KERNEL_LAST = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsSize {
    VIPS_SIZE_BOTH = 0,
    VIPS_SIZE_UP = 1,
    VIPS_SIZE_DOWN = 2,
    VIPS_SIZE_FORCE = 3,
    VIPS_SIZE_LAST = 4,
}
extern "C" {
    #[link_name = "\u{1}_vips_shrink"]
    pub fn vips_shrink(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_shrinkh"]
    pub fn vips_shrinkh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_shrinkv"]
    pub fn vips_shrinkv(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        vshrink: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_reduce"]
    pub fn vips_reduce(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_reduceh"]
    pub fn vips_reduceh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_reducev"]
    pub fn vips_reducev(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_thumbnail"]
    pub fn vips_thumbnail(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_thumbnail_buffer"]
    pub fn vips_thumbnail_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_thumbnail_image"]
    pub fn vips_thumbnail_image(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_similarity"]
    pub fn vips_similarity(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rotate"]
    pub fn vips_rotate(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        angle: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_affine"]
    pub fn vips_affine(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_resize"]
    pub fn vips_resize(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        scale: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mapim"]
    pub fn vips_mapim(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        index: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_quadratic"]
    pub fn vips_quadratic(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        coeff: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsIntent {
    VIPS_INTENT_PERCEPTUAL = 0,
    VIPS_INTENT_RELATIVE = 1,
    VIPS_INTENT_SATURATION = 2,
    VIPS_INTENT_ABSOLUTE = 3,
    VIPS_INTENT_LAST = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsPCS {
    VIPS_PCS_LAB = 0,
    VIPS_PCS_XYZ = 1,
    VIPS_PCS_LAST = 2,
}
extern "C" {
    #[link_name = "\u{1}_vips_colourspace_issupported"]
    pub fn vips_colourspace_issupported(image: *const VipsImage) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_colourspace"]
    pub fn vips_colourspace(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        space: VipsInterpretation,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_LabQ2sRGB"]
    pub fn vips_LabQ2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_rad2float"]
    pub fn vips_rad2float(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_float2rad"]
    pub fn vips_float2rad(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_LabS2LabQ"]
    pub fn vips_LabS2LabQ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_LabQ2LabS"]
    pub fn vips_LabQ2LabS(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_LabQ2Lab"]
    pub fn vips_LabQ2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_Lab2LabQ"]
    pub fn vips_Lab2LabQ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_LCh2Lab"]
    pub fn vips_LCh2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_Lab2LCh"]
    pub fn vips_Lab2LCh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_Yxy2Lab"]
    pub fn vips_Yxy2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_CMC2XYZ"]
    pub fn vips_CMC2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_Lab2XYZ"]
    pub fn vips_Lab2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_XYZ2Lab"]
    pub fn vips_XYZ2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_XYZ2scRGB"]
    pub fn vips_XYZ2scRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_scRGB2sRGB"]
    pub fn vips_scRGB2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_scRGB2BW"]
    pub fn vips_scRGB2BW(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sRGB2scRGB"]
    pub fn vips_sRGB2scRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_scRGB2XYZ"]
    pub fn vips_scRGB2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_HSV2sRGB"]
    pub fn vips_HSV2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sRGB2HSV"]
    pub fn vips_sRGB2HSV(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_LCh2CMC"]
    pub fn vips_LCh2CMC(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_CMC2LCh"]
    pub fn vips_CMC2LCh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_XYZ2Yxy"]
    pub fn vips_XYZ2Yxy(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_Yxy2XYZ"]
    pub fn vips_Yxy2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_LabS2Lab"]
    pub fn vips_LabS2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_Lab2LabS"]
    pub fn vips_Lab2LabS(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_icc_present"]
    pub fn vips_icc_present() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_icc_transform"]
    pub fn vips_icc_transform(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        output_profile: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_icc_import"]
    pub fn vips_icc_import(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_icc_export"]
    pub fn vips_icc_export(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_icc_ac2rc"]
    pub fn vips_icc_ac2rc(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        profile_filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_icc_is_compatible_profile"]
    pub fn vips_icc_is_compatible_profile(
        image: *mut VipsImage,
        data: *mut ::std::os::raw::c_void,
        data_length: usize,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_vips_dE76"]
    pub fn vips_dE76(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_dE00"]
    pub fn vips_dE00(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_dECMC"]
    pub fn vips_dECMC(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_Lab2XYZ"]
    pub fn vips_col_Lab2XYZ(L: f32, a: f32, b: f32, X: *mut f32, Y: *mut f32, Z: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_vips_col_XYZ2Lab"]
    pub fn vips_col_XYZ2Lab(X: f32, Y: f32, Z: f32, L: *mut f32, a: *mut f32, b: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_vips_col_ab2h"]
    pub fn vips_col_ab2h(a: f64, b: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_ab2Ch"]
    pub fn vips_col_ab2Ch(a: f32, b: f32, C: *mut f32, h: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_vips_col_Ch2ab"]
    pub fn vips_col_Ch2ab(C: f32, h: f32, a: *mut f32, b: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_vips_col_L2Lcmc"]
    pub fn vips_col_L2Lcmc(L: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_C2Ccmc"]
    pub fn vips_col_C2Ccmc(C: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_Ch2hcmc"]
    pub fn vips_col_Ch2hcmc(C: f32, h: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_make_tables_CMC"]
    pub fn vips_col_make_tables_CMC();
}
extern "C" {
    #[link_name = "\u{1}_vips_col_Lcmc2L"]
    pub fn vips_col_Lcmc2L(Lcmc: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_Ccmc2C"]
    pub fn vips_col_Ccmc2C(Ccmc: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_Chcmc2h"]
    pub fn vips_col_Chcmc2h(C: f32, hcmc: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_sRGB2scRGB_8"]
    pub fn vips_col_sRGB2scRGB_8(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_sRGB2scRGB_16"]
    pub fn vips_col_sRGB2scRGB_16(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_sRGB2scRGB_8_noclip"]
    pub fn vips_col_sRGB2scRGB_8_noclip(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_sRGB2scRGB_16_noclip"]
    pub fn vips_col_sRGB2scRGB_16_noclip(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_scRGB2XYZ"]
    pub fn vips_col_scRGB2XYZ(
        R: f32,
        G: f32,
        B: f32,
        X: *mut f32,
        Y: *mut f32,
        Z: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_XYZ2scRGB"]
    pub fn vips_col_XYZ2scRGB(
        X: f32,
        Y: f32,
        Z: f32,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_scRGB2sRGB_8"]
    pub fn vips_col_scRGB2sRGB_8(
        R: f32,
        G: f32,
        B: f32,
        r: *mut ::std::os::raw::c_int,
        g: *mut ::std::os::raw::c_int,
        b: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_scRGB2sRGB_16"]
    pub fn vips_col_scRGB2sRGB_16(
        R: f32,
        G: f32,
        B: f32,
        r: *mut ::std::os::raw::c_int,
        g: *mut ::std::os::raw::c_int,
        b: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_scRGB2BW_16"]
    pub fn vips_col_scRGB2BW_16(
        R: f32,
        G: f32,
        B: f32,
        g: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_scRGB2BW_8"]
    pub fn vips_col_scRGB2BW_8(
        R: f32,
        G: f32,
        B: f32,
        g: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_pythagoras"]
    pub fn vips_pythagoras(L1: f32, a1: f32, b1: f32, L2: f32, a2: f32, b2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_vips_col_dE00"]
    pub fn vips_col_dE00(L1: f32, a1: f32, b1: f32, L2: f32, a2: f32, b2: f32) -> f32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VipsCombineMode {
    VIPS_COMBINE_MODE_SET = 0,
    VIPS_COMBINE_MODE_ADD = 1,
    VIPS_COMBINE_MODE_LAST = 2,
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_rect"]
    pub fn vips_draw_rect(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_rect1"]
    pub fn vips_draw_rect1(
        image: *mut VipsImage,
        ink: f64,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_point"]
    pub fn vips_draw_point(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_point1"]
    pub fn vips_draw_point1(
        image: *mut VipsImage,
        ink: f64,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_image"]
    pub fn vips_draw_image(
        image: *mut VipsImage,
        sub: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_mask"]
    pub fn vips_draw_mask(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        mask: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_mask1"]
    pub fn vips_draw_mask1(
        image: *mut VipsImage,
        ink: f64,
        mask: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_line"]
    pub fn vips_draw_line(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_line1"]
    pub fn vips_draw_line1(
        image: *mut VipsImage,
        ink: f64,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_circle"]
    pub fn vips_draw_circle(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        radius: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_circle1"]
    pub fn vips_draw_circle1(
        image: *mut VipsImage,
        ink: f64,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        radius: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_flood"]
    pub fn vips_draw_flood(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_flood1"]
    pub fn vips_draw_flood1(
        image: *mut VipsImage,
        ink: f64,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_draw_smudge"]
    pub fn vips_draw_smudge(
        image: *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_black"]
    pub fn vips_black(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_xyz"]
    pub fn vips_xyz(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_grey"]
    pub fn vips_grey(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_gaussmat"]
    pub fn vips_gaussmat(
        out: *mut *mut VipsImage,
        sigma: f64,
        min_ampl: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_logmat"]
    pub fn vips_logmat(
        out: *mut *mut VipsImage,
        sigma: f64,
        min_ampl: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_text"]
    pub fn vips_text(
        out: *mut *mut VipsImage,
        text: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_gaussnoise"]
    pub fn vips_gaussnoise(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_eye"]
    pub fn vips_eye(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_sines"]
    pub fn vips_sines(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_zone"]
    pub fn vips_zone(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_identity"]
    pub fn vips_identity(out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_buildlut"]
    pub fn vips_buildlut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_invertlut"]
    pub fn vips_invertlut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_tonelut"]
    pub fn vips_tonelut(out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_ideal"]
    pub fn vips_mask_ideal(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_ideal_ring"]
    pub fn vips_mask_ideal_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_ideal_band"]
    pub fn vips_mask_ideal_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_butterworth"]
    pub fn vips_mask_butterworth(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_butterworth_ring"]
    pub fn vips_mask_butterworth_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_butterworth_band"]
    pub fn vips_mask_butterworth_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_gaussian"]
    pub fn vips_mask_gaussian(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_gaussian_ring"]
    pub fn vips_mask_gaussian_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_gaussian_band"]
    pub fn vips_mask_gaussian_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_mask_fractal"]
    pub fn vips_mask_fractal(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fractal_dimension: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_fractsurf"]
    pub fn vips_fractsurf(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fractal_dimension: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_worley"]
    pub fn vips_worley(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_perlin"]
    pub fn vips_perlin(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_video_v4l1"]
    pub fn im_video_v4l1(
        im: *mut VipsImage,
        device: *const ::std::os::raw::c_char,
        channel: ::std::os::raw::c_int,
        brightness: ::std::os::raw::c_int,
        colour: ::std::os::raw::c_int,
        contrast: ::std::os::raw::c_int,
        hue: ::std::os::raw::c_int,
        ngrabs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_im_video_test"]
    pub fn im_video_test(
        im: *mut VipsImage,
        brightness: ::std::os::raw::c_int,
        error: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_gmic"]
    pub fn vips_gmic(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        padding: ::std::os::raw::c_int,
        x_scale: f64,
        y_scale: f64,
        command: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_init"]
    pub fn vips_init(argv0: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_get_argv0"]
    pub fn vips_get_argv0() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_shutdown"]
    pub fn vips_shutdown();
}
extern "C" {
    #[link_name = "\u{1}_vips_thread_shutdown"]
    pub fn vips_thread_shutdown();
}
extern "C" {
    #[link_name = "\u{1}_vips_add_option_entries"]
    pub fn vips_add_option_entries(option_group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_vips_leak_set"]
    pub fn vips_leak_set(leak: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_vips_version_string"]
    pub fn vips_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_version"]
    pub fn vips_version(flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vips_guess_prefix"]
    pub fn vips_guess_prefix(
        argv0: *const ::std::os::raw::c_char,
        env_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_vips_guess_libdir"]
    pub fn vips_guess_libdir(
        argv0: *const ::std::os::raw::c_char,
        env_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
